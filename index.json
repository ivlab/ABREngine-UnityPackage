{
  "api/Global.ABRFilterExample.html": {
    "href": "api/Global.ABRFilterExample.html",
    "title": "Class ABRFilterExample | ABREngine",
    "keywords": "Class ABRFilterExample Inheritance object Object Component Behaviour MonoBehaviour ABRFilterExample Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class ABRFilterExample : MonoBehaviour"
  },
  "api/Global.ABRQueryExample.html": {
    "href": "api/Global.ABRQueryExample.html",
    "title": "Class ABRQueryExample | ABREngine",
    "keywords": "Class ABRQueryExample Displays the scalar data value Inheritance object Object Component Behaviour MonoBehaviour ABRQueryExample Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class ABRQueryExample : MonoBehaviour"
  },
  "api/Global.ABRSpaceConvertExample.html": {
    "href": "api/Global.ABRSpaceConvertExample.html",
    "title": "Class ABRSpaceConvertExample | ABREngine",
    "keywords": "Class ABRSpaceConvertExample Measure the distance between two points Inheritance object Object Component Behaviour MonoBehaviour ABRSpaceConvertExample Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class ABRSpaceConvertExample : MonoBehaviour Fields keyDataPathToMeasure Measure the distance between two points Declaration [Header(\"Which key data object to measure data points in\")] public string keyDataPathToMeasure Field Value Type Description string measurePoint1 Measure the distance between two points Declaration [Header(\"Assign these objects and move them around to measure points in space.\")] public Transform measurePoint1 Field Value Type Description Transform measurePoint2 Measure the distance between two points Declaration public Transform measurePoint2 Field Value Type Description Transform"
  },
  "api/Global.BackgroundColor.html": {
    "href": "api/Global.BackgroundColor.html",
    "title": "Class BackgroundColor | ABREngine",
    "keywords": "Class BackgroundColor Inheritance object Object Component Behaviour MonoBehaviour BackgroundColor Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class BackgroundColor : MonoBehaviour Methods SaveBackground() Declaration public void SaveBackground()"
  },
  "api/Global.DebugDraw.html": {
    "href": "api/Global.DebugDraw.html",
    "title": "Class DebugDraw | ABREngine",
    "keywords": "Class DebugDraw Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. Inheritance object DebugDraw Namespace: Global Assembly: Assembly-CSharp.dll Syntax public static class DebugDraw Methods Axes(Matrix4x4, float, float, float) Draw a set of axes corresponding to a Matrix4x4 basis. Uses standard RGB->XYZ coloring. Declaration public static void Axes(Matrix4x4 basis, float size = 0.1, float duration = 0, float thickness = 0.001) Parameters Type Name Description Matrix4x4 basis float size float duration float thickness Bounds(Bounds, Color, float, float) Draw a bounds outline mesh Declaration public static void Bounds(Bounds bounds, Color color, float duration = 0, float thickness = 0.001) Parameters Type Name Description Bounds bounds Color color float duration float thickness Bounds(Bounds, Color, Matrix4x4, float, float) Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. Declaration public static void Bounds(Bounds bounds, Color color, Matrix4x4 boundsTransform, float duration = 0, float thickness = 0.001) Parameters Type Name Description Bounds bounds Color color Matrix4x4 boundsTransform float duration float thickness Circle(Vector3, float, Vector3, Color, float) Draw a circular mesh Declaration public static void Circle(Vector3 center, float radius, Vector3 normal, Color color, float duration = 0) Parameters Type Name Description Vector3 center float radius Vector3 normal Color color float duration Line(Vector3, Vector3, Color, float, float) Draw a line as an in-game-rendered cylinder Declaration public static void Line(Vector3 start, Vector3 end, Color color, float duration = 0, float thickness = 0.001) Parameters Type Name Description Vector3 start Vector3 end Color color float duration float thickness Point(Vector3, float, Color, float) Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. Declaration public static void Point(Vector3 center, float radius, Color color, float duration = 0) Parameters Type Name Description Vector3 center float radius Color color float duration Ray(Vector3, Vector3, Color, float, float) Draw a ray as an in-game-rendered cylinder Declaration public static void Ray(Vector3 start, Vector3 direction, Color color, float duration = 0, float thickness = 0.001) Parameters Type Name Description Vector3 start Vector3 direction Color color float duration float thickness Sphere(Vector3, float, Color, float) Draw a sphere/point mesh Declaration public static void Sphere(Vector3 center, float radius, Color color, float duration = 0) Parameters Type Name Description Vector3 center float radius Color color float duration Text(Vector3, string, Color, float) Draw some text to the screen at a specified position Declaration public static void Text(Vector3 position, string text, Color color, float duration = 0) Parameters Type Name Description Vector3 position string text Color color float duration Remarks Note The Text(Vector3, string, Color, float) method only works in the Unity Editor and only displays in scene view."
  },
  "api/Global.DisableABRLights.html": {
    "href": "api/Global.DisableABRLights.html",
    "title": "Class DisableABRLights | ABREngine",
    "keywords": "Class DisableABRLights Inheritance object Object Component Behaviour MonoBehaviour DisableABRLights Namespace: Global Assembly: Assembly-CSharp.dll Syntax [RequireComponent(typeof(ABREngine))] public class DisableABRLights : MonoBehaviour"
  },
  "api/Global.GenerateDataAndUseStyle.html": {
    "href": "api/Global.GenerateDataAndUseStyle.html",
    "title": "Class GenerateDataAndUseStyle | ABREngine",
    "keywords": "Class GenerateDataAndUseStyle Inheritance object Object Component Behaviour MonoBehaviour GenerateDataAndUseStyle Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class GenerateDataAndUseStyle : MonoBehaviour"
  },
  "api/Global.Grabbable.html": {
    "href": "api/Global.Grabbable.html",
    "title": "Class Grabbable | ABREngine",
    "keywords": "Class Grabbable Inheritance object Object Component Behaviour MonoBehaviour Grabbable Namespace: Global Assembly: Assembly-CSharp.dll Syntax [RequireComponent(typeof(Collider))] public class Grabbable : MonoBehaviour"
  },
  "api/Global.Grabber.html": {
    "href": "api/Global.Grabber.html",
    "title": "Class Grabber | ABREngine",
    "keywords": "Class Grabber Inheritance object Object Component Behaviour MonoBehaviour Grabber Namespace: Global Assembly: Assembly-CSharp.dll Syntax [RequireComponent(typeof(Collider))] public class Grabber : MonoBehaviour Fields grabbing Declaration [HideInInspector] public bool grabbing Field Value Type Description bool otherHand Declaration public Grabber otherHand Field Value Type Description Grabber scaling Declaration [HideInInspector] public bool scaling Field Value Type Description bool"
  },
  "api/Global.HideShowMenu.html": {
    "href": "api/Global.HideShowMenu.html",
    "title": "Class HideShowMenu | ABREngine",
    "keywords": "Class HideShowMenu Inheritance object Object Component Behaviour MonoBehaviour HideShowMenu Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class HideShowMenu : MonoBehaviour Fields onMenuClosed Declaration public UnityEvent onMenuClosed Field Value Type Description UnityEvent onMenuOpened Declaration public UnityEvent onMenuOpened Field Value Type Description UnityEvent Methods ToggleHideShow() Toggles whether the menu is hidden or shown. Declaration public void ToggleHideShow()"
  },
  "api/Global.LightEditor.html": {
    "href": "api/Global.LightEditor.html",
    "title": "Class LightEditor | ABREngine",
    "keywords": "Class LightEditor Inheritance object Object Component Behaviour MonoBehaviour LightEditor Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class LightEditor : MonoBehaviour Methods LimitEditing(LightEditorTile) Declaration public void LimitEditing(LightEditorTile mainLightEditor) Parameters Type Name Description LightEditorTile mainLightEditor"
  },
  "api/Global.LightEditorTile.html": {
    "href": "api/Global.LightEditorTile.html",
    "title": "Class LightEditorTile | ABREngine",
    "keywords": "Class LightEditorTile Inheritance object Object Component Behaviour MonoBehaviour LightEditorTile Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class LightEditorTile : MonoBehaviour Fields lightName Declaration [Header(\"Settings\")] public string lightName Field Value Type Description string Methods CreateLight() Declaration public void CreateLight() DeleteLight() Declaration public void DeleteLight() Disable() Declaration public void Disable() EnableWithLight(string) Declaration public void EnableWithLight(string name) Parameters Type Name Description string name LightIntensity(float) Declaration public void LightIntensity(float value) Parameters Type Name Description float value SaveAndClose() Declaration public void SaveAndClose() SaveChanges() Declaration public void SaveChanges() ToggleEditLight() Declaration public void ToggleEditLight()"
  },
  "api/Global.PerformanceEnhancer.html": {
    "href": "api/Global.PerformanceEnhancer.html",
    "title": "Class PerformanceEnhancer | ABREngine",
    "keywords": "Class PerformanceEnhancer Performance enhancement for older computers running ABR. Essentially, one frame is rendered every 10 seconds unless the ABR state is changed OR there is mouse/keyboard input. Inheritance object Object Component Behaviour MonoBehaviour PerformanceEnhancer Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class PerformanceEnhancer : MonoBehaviour Methods SpeedUpForSeconds(float) Performance enhancement for older computers running ABR. Essentially, one frame is rendered every 10 seconds unless the ABR state is changed OR there is mouse/keyboard input. Declaration public void SpeedUpForSeconds(float speedUpTime) Parameters Type Name Description float speedUpTime"
  },
  "api/Global.SVScreenshot.html": {
    "href": "api/Global.SVScreenshot.html",
    "title": "Class SVScreenshot | ABREngine",
    "keywords": "Class SVScreenshot Inheritance object Object Component Behaviour MonoBehaviour SVScreenshot Namespace: Global Assembly: Assembly-CSharp.dll Syntax public class SVScreenshot : MonoBehaviour Fields heightText Declaration public TMP_InputField heightText Field Value Type Description TMP_InputField nameText Declaration public TMP_InputField nameText Field Value Type Description TMP_InputField pathText Declaration public TMP_InputField pathText Field Value Type Description TMP_InputField screenshotCamera Declaration public Screenshot screenshotCamera Field Value Type Description Screenshot transBg Declaration public Toggle transBg Field Value Type Description Toggle widthText Declaration public TMP_InputField widthText Field Value Type Description TMP_InputField Methods SaveScreenshot() Declaration public void SaveScreenshot()"
  },
  "api/Global.html": {
    "href": "api/Global.html",
    "title": "Namespace | ABREngine",
    "keywords": "Namespace Classes ABRFilterExample ABRQueryExample Displays the scalar data value ABRSpaceConvertExample Measure the distance between two points BackgroundColor DebugDraw Additions to Unity's useful debugging utililies like Debug.DrawRay and Debug.DrawLine. These are particularly useful for AR/VR applications where the debug output needs to be seen in the Game View (not just scene view.) All parameters duration will default to a single frame when left at 0, otherwise duration is in seconds. DisableABRLights GenerateDataAndUseStyle Grabbable Grabber HideShowMenu LightEditor LightEditorTile PerformanceEnhancer Performance enhancement for older computers running ABR. Essentially, one frame is rendered every 10 seconds unless the ABR state is changed OR there is mouse/keyboard input. SVScreenshot"
  },
  "api/IVLab.ABREngine.ABRConfig.Consts.html": {
    "href": "api/IVLab.ABREngine.ABRConfig.Consts.html",
    "title": "Class ABRConfig.Consts | ABREngine",
    "keywords": "Class ABRConfig.Consts Global access to constants in the ABR Engine. Sync this with settings.py in the ABRServer~. Inheritance object ABRConfig.Consts Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public static class ABRConfig.Consts Fields | Improve this Doc View Source DatasetFolder Dataset folder within media folder Declaration public const string DatasetFolder = \"datasets\" Field Value Type Description string | Improve this Doc View Source MediaFolder Default name for the media folder Declaration public const string MediaFolder = \"media\" Field Value Type Description string | Improve this Doc View Source ThumbnailsFolder Folder to save thumbnail screenshots of state in Declaration public const string ThumbnailsFolder = \"thumbnails\" Field Value Type Description string | Improve this Doc View Source VisAssetFolder VisAsset folder within media folder Declaration public const string VisAssetFolder = \"visassets\" Field Value Type Description string | Improve this Doc View Source VisAssetJson Name of VisAsset JSON specifier Declaration public const string VisAssetJson = \"artifact.json\" Field Value Type Description string"
  },
  "api/IVLab.ABREngine.ABRConfig.GroupToDataMatrixOverrideFields.html": {
    "href": "api/IVLab.ABREngine.ABRConfig.GroupToDataMatrixOverrideFields.html",
    "title": "Class ABRConfig.GroupToDataMatrixOverrideFields | ABREngine",
    "keywords": "Class ABRConfig.GroupToDataMatrixOverrideFields Inheritance object ABRConfig.GroupToDataMatrixOverrideFields Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Serializable] public class ABRConfig.GroupToDataMatrixOverrideFields Fields | Improve this Doc View Source datasetPath Declaration [Header(\"Dataset path or Group name or UUID to affect (specify one)\")] [Tooltip(\"Dataset path to affect with this matrix\")] public string datasetPath Field Value Type Description string | Improve this Doc View Source groupName Declaration [Tooltip(\"Name of the group to affect with this matrix\")] public string groupName Field Value Type Description string | Improve this Doc View Source groupToDataMatrix Declaration [Tooltip(\"4x4 transformation matrix to modify the `GroupToDataMatrix` of this group\")] public Matrix4x4 groupToDataMatrix Field Value Type Description Matrix4x4 | Improve this Doc View Source groupUuid Declaration [Tooltip(\"UUID of the group to affect with this matrix\")] public string groupUuid Field Value Type Description string"
  },
  "api/IVLab.ABREngine.ABRConfig.html": {
    "href": "api/IVLab.ABREngine.ABRConfig.html",
    "title": "Class ABRConfig | ABREngine",
    "keywords": "Class ABRConfig This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Inheritance object Object ScriptableObject ABRConfig Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [CreateAssetMenu(fileName = \"ABRConfig\", menuName = \"ABR/ABR Configuration\")] public class ABRConfig : ScriptableObject Fields | Improve this Doc View Source dataListenerPort Port to listen for data on, if any. Useful if, for instance, you want to have a live connection to ParaView that pushes data into ABR. Default: null Declaration [Tooltip(\"Port to listen for data connections (e.g. from ParaView on). A port `0` is assumed to mean no connection.\")] public int dataListenerPort Field Value Type Description int | Improve this Doc View Source dataServerUrl What server to obtain data from, if any. If none provided, ABR will assume that everything is in Unity's persistentData path. If server is provided and resource doesn't exist in persistentData, it will be downloaded. Default: null Declaration [Tooltip(\"Server to load VisAssets from (e.g. `http://192.168.137.1:8001/api`\")] public string dataServerUrl Field Value Type Description string | Improve this Doc View Source defaultColor This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Tooltip(\"Default color for geometries that have not had a colormap applied yet\")] public Color defaultColor Field Value Type Description Color | Improve this Doc View Source defaultDataContainer Default bounds for datasets when showing (in Unity world coordinates) Declaration [Tooltip(\"Unity world-space container to automatically 'squish' all data into to avoid overflowing Unity coordinates\")] public Bounds defaultDataContainer Field Value Type Description Bounds | Improve this Doc View Source defaultGlyph This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Header(\"Styling Defaults\")] [Tooltip(\"Default shape/color for glyphs in the Glyph layer\")] public GameObject defaultGlyph Field Value Type Description GameObject | Improve this Doc View Source defaultNanColor This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Tooltip(\"Default color for NaN values\")] public Color defaultNanColor Field Value Type Description Color | Improve this Doc View Source defaultNanLine This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Tooltip(\"Default line texture for NaN values on ribbons\")] public Texture2D defaultNanLine Field Value Type Description Texture2D | Improve this Doc View Source defaultNanTexture This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Tooltip(\"Default texture for NaN values on surfaces\")] public Texture2D defaultNanTexture Field Value Type Description Texture2D | Improve this Doc View Source loadStateOnStart Load a state from resources on ABREngine startup Declaration [Tooltip(\"Load a state from Resources or StreamingAssets folder on ABREngine startup. Example: `testState.json` Leave blank for no startup state.\")] public string loadStateOnStart Field Value Type Description string | Improve this Doc View Source mediaPath This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Header(\"Common Configuration Options (hover for more info)\")] [Tooltip(\"Location on this computer where VisAssets and Datasets are located. Relative paths (e.g. `../media`) are also acceptable.\")] public string mediaPath Field Value Type Description string | Improve this Doc View Source persistBetweenScenes This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Tooltip(\"Should the ABREngine GameObject persist between scenes?\")] public bool persistBetweenScenes Field Value Type Description bool | Improve this Doc View Source schemaName This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Header(\"ABR Schema Configuration\")] [Tooltip(\"Name of the schema to use in ABRSchemas~ folder at root of this package\")] public string schemaName Field Value Type Description string | Improve this Doc View Source serverUrl What server to connect to, if any. If provided, ABR will try to register with the server immediately upon startup. Default: null Declaration [Tooltip(\"Full URL of the ABR server / visualization manager that this app should connect to. Leave blank for no server.\")] public string serverUrl Field Value Type Description string | Improve this Doc View Source startServer This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Tooltip(\"Should the ABREngine try to start the ABRServer when it is started? Use this option with caution. In most cases the ABR Server should be started externally.\")] public bool startServer Field Value Type Description bool | Improve this Doc View Source useAutoDataContainers This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Header(\"Data Container Options\")] [Tooltip(\"Use the automatic data containers (defined in-scene with ABRDataBounds or the defaultDataBounds), or just import coordinates as-is\")] public bool useAutoDataContainers Field Value Type Description bool | Improve this Doc View Source visAssetServerUrl This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration [Header(\"Network-Based VisAssets and Data Configuration\")] [Tooltip(\"Server to load VisAssets from (e.g. `http://192.168.137.1:8000/media/visassets`\")] public string visAssetServerUrl Field Value Type Description string Properties | Improve this Doc View Source DefaultCamera Camera to use as ABR's main camera. If left blank, will assume @Camera.main. Declaration public Camera DefaultCamera { get; set; } Property Value Type Description Camera | Improve this Doc View Source Schema The Json Schema to use for validation of ABR states Declaration public JSchema Schema { get; } Property Value Type Description JSchema | Improve this Doc View Source SchemaJson Schema to use for internally grabbing default values Declaration public JObject SchemaJson { get; } Property Value Type Description JObject | Improve this Doc View Source ServerUrl Actual URI-ified URL of the server that ABR should connect to Declaration public Uri ServerUrl { get; } Property Value Type Description Uri Methods | Improve this Doc View Source GetDefaultRawABRInput(string, string) This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration public RawABRInput GetDefaultRawABRInput(string plateName, string inputName) Parameters Type Name Description string plateName string inputName Returns Type Description RawABRInput | Improve this Doc View Source GetInputNames(string) Obtain a full list of all inputs available to this plate Declaration public string[] GetInputNames(string plateName) Parameters Type Name Description string plateName Returns Type Description string[] | Improve this Doc View Source GetInputValueDefault<T>(string, string) Get the default primitive value for a particular data impression's parameter Declaration public T GetInputValueDefault<T>(string plateName, string inputName) where T : IPrimitive Parameters Type Name Description string plateName string inputName Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source LoadSchema() This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. Declaration public void LoadSchema() | Improve this Doc View Source ToString() Returns the name of the object. Declaration public override string ToString() Returns Type Description string The name returned by ToString. Overrides UnityEngine.Object.ToString()"
  },
  "api/IVLab.ABREngine.ABRDataContainer.html": {
    "href": "api/IVLab.ABREngine.ABRDataContainer.html",
    "title": "Class ABRDataContainer | ABREngine",
    "keywords": "Class ABRDataContainer Inheritance object Object Component Behaviour MonoBehaviour ABRDataContainer Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [AddComponentMenu(\"ABR/ABR Data Container\")] public class ABRDataContainer : MonoBehaviour Fields | Improve this Doc View Source bounds Declaration [SerializeField] [Tooltip(\"Bounds to constrain the data to\")] public Bounds bounds Field Value Type Description Bounds | Improve this Doc View Source overwriteStateBounds Declaration [SerializeField] [Tooltip(\"Overwrite the bounds for this group found in an ABR state file that is loaded, if any exist\")] public bool overwriteStateBounds Field Value Type Description bool"
  },
  "api/IVLab.ABREngine.ABREngine.StateChangeDelegate.html": {
    "href": "api/IVLab.ABREngine.ABREngine.StateChangeDelegate.html",
    "title": "Delegate ABREngine.StateChangeDelegate | ABREngine",
    "keywords": "Delegate ABREngine.StateChangeDelegate Delegate callback that is called whenever the ABRState is updated. This is useful for applications that build on ABR and need to know when the state has been updated. OnStateChanged for usage. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public delegate void ABREngine.StateChangeDelegate(JObject state) Parameters Type Name Description JObject state"
  },
  "api/IVLab.ABREngine.ABREngine.html": {
    "href": "api/IVLab.ABREngine.ABREngine.html",
    "title": "Class ABREngine | ABREngine",
    "keywords": "Class ABREngine The ABREngine class is the main operational MonoBehaviour Singleton for the ABREngine-UnityPackage. It is in charge of kicking off all startup processes for ABR, including setting up connections with the server, the data listener, VisAssets and Data managers, etc. Inheritance object Object Component Behaviour MonoBehaviour Singleton<ABREngine> ABREngine Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ABREngine : Singleton<ABREngine> Examples Usage of ABREngine.Instance Most methods of the ABREngine can be accessed through its singleton Instance without needing to do a GetComponent: string mediaPath = ABREngine.Instance.MediaPath; Example: Getting Started with Unity C# and ABR This example shows how to create an ABR visualization in code using one data impression. Note You can also import this example using the Unity Package Manager. In Unity, go to Window > Package Manager, find the ABREngine package, and import the \"Documentation Examples\" sample project. The general process for making an ABR visualization in C# code is: Import data using LoadData(string) Import VisAssets using GetVisAsset<T>(Guid). Create a DataImpression to combine the data and visuals together (using Create<T>(string, Guid, bool)). Use RegisterDataImpression(DataImpression, DataImpressionGroup, bool) to add the impression to the engine. Render the data and visuals to the screen using Render(). using UnityEngine; using IVLab.ABREngine; // Look in the Resources folder of this example to see the data and VisAssets. // Before running this example, make sure the ABR Configuration is set to ABRExamplesConfig! public class ABREngineExample : MonoBehaviour { // Editable in Unity Editor [SerializeField, Tooltip(\"Animated spin rate for the data\"), Range(0.0f, 30.0f)] private float spinRate = 1.0f; // Store the data impression for use in Update() private SimpleGlyphDataImpression dataImpression; void Start() { // Load example VisAssets from resources // A white to orange colormap ColormapVisAsset orange = ABREngine.Instance.VisAssets.GetVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // A triangular glyph GlyphVisAsset triangular = ABREngine.Instance.VisAssets.GetVisAsset<GlyphVisAsset>(new System.Guid(\"1af02820-f1ed-11e9-a623-8c85900fd4af\")); // Load an example dataset from resources // This Key Data has multiple scalar variables defined at each point in // the dataset. We'll use the \"XAxis\" variable, this increases // monotonically from -10 to +10 along the X axis. KeyData pointsKd = ABREngine.Instance.Data.LoadData(\"Demo/Wavelet/KeyData/Points\"); ScalarDataVariable xAxisScalarVar = pointsKd.GetScalarVariable(\"XAxis\"); // Create a Glyph DataImpression and store it for later use dataImpression = DataImpression.Create<SimpleGlyphDataImpression>(\"Example Points\"); // Assign the key data to the Data Impression. This is the \"Geometry\" // with which the data impression will be drawn. dataImpression.keyData = pointsKd; // Tell ABR to map the Color visual channel of the Data Impression to // the \"XAxis\" variable. dataImpression.colorVariable = xAxisScalarVar; // Lastly, apply the colormap and glyph (visual style for this Data // Impresssion) dataImpression.colormap = orange; dataImpression.glyph = triangular; // Finally, add the Data Impression to the ABREngine, and re-render. // Note, this will automatically look for the DataImpression Group // \"Demo/Wavelet\" in the scene, and put this data impression as a child // of that group. ABREngine.Instance.RegisterDataImpression(dataImpression); ABREngine.Instance.Render(); } void Update() { // Access the individual data impression that was created earlier and // spin it around. // // Usually we want to do any manipulations like this at the \"Group\" // level rather than individual data impressions so that multiple data // impressions in the same dataset remain spatially registered with each // other. DataImpressionGroup pointsGroup = ABREngine.Instance.GetGroupFromImpression(dataImpression); pointsGroup.transform.rotation *= Quaternion.Euler(new Vector3(0, Time.deltaTime * spinRate, 0)); } } Example: Using Custom Data This example shows how to quickly get up and running with a custom-defined dataset and building your own data impressions. Before the steps in the previous example, you will also need to: Define your data in some `List`s. Use the RawDatasetAdapter to convert the `List` into an ABR RawDataset, or import an existing ABR RawDataset using LoadRawDataset(string). Import that RawDataset into ABR using ImportRawDataset(RawDataset) (optionally, giving the dataset a data path identifier for easier semantic access later). using System.Collections.Generic; using UnityEngine; using IVLab.ABREngine; /// <summary> /// Example for the main ABREngine class. /// </summary> public class CustomDataABRExample : MonoBehaviour { void Start() { // STEP 1: Define data // 9 points in 3D space List<Vector3> vertices = new List<Vector3> { new Vector3(0.0f, 0.5f, 0.0f), new Vector3(0.0f, 0.6f, 0.1f), new Vector3(0.0f, 0.4f, 0.2f), new Vector3(0.1f, 0.3f, 0.0f), new Vector3(0.1f, 0.2f, 0.1f), new Vector3(0.1f, 0.3f, 0.2f), new Vector3(0.2f, 0.0f, 0.0f), new Vector3(0.2f, 0.3f, 0.1f), new Vector3(0.2f, 0.1f, 0.2f), }; // Data values for those points List<float> data = new List<float>(); for (int i = 0; i < vertices.Count; i++) data.Add(i); // Named scalar variable Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> { { \"someData\", data } }; // Define some generous bounds Bounds b = new Bounds(Vector3.zero, Vector3.one); // STEP 2: Convert the point list into ABR Format RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(vertices, b, scalarVars, null); // STEP 3: Import the point data into ABR so we can use it KeyData pointsKD = ABREngine.Instance.Data.ImportRawDataset(abrPoints); // STEP 4: Import a colormap visasset ColormapVisAsset cmap = ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // STEP 5: Create a Data Impression (layer) for the points, and assign some key data and styling SimpleGlyphDataImpression di = DataImpression.Create<SimpleGlyphDataImpression>(\"Simple Points\"); di.keyData = pointsKD; // Assign key data (point geometry) di.colorVariable = pointsKD.GetScalarVariables()[0]; // Assign scalar variable \"someData\" di.colormap = cmap; // Apply colormap di.glyphSize = 0.002f; // Apply glyph size styling // STEP 6: Register impression with the engine ABREngine.Instance.RegisterDataImpression(di); // STEP 7: Render the visualization ABREngine.Instance.Render(); } } Fields | Improve this Doc View Source OnStateChanged Delegate that is called whenever ABRState is updated. Declaration public ABREngine.StateChangeDelegate OnStateChanged Field Value Type Description ABREngine.StateChangeDelegate Examples Developers may need to use this if they want to know when the state has been updated: using UnityEngine; using IVLab.ABREngine; public class ABRStateExample : MonoBehaviour { void Start() { ABREngine.Instance.OnStateChanged += ExampleOnStateChanged; } void ExampleOnStateChanged(JObject state) { Debug.Log(state[\"version\"]); } } | Improve this Doc View Source PackagePath The package path defined in package.json. Note With project builds, the PackagePath assumes that everything is located relative to the built executable. If the current working directory is something besides the directory ABR is located in, there may be problems. Warning If the package path changes for any reason, this will need to be updated! Declaration public const string PackagePath = \"Packages/edu.umn.cs.ivlab.abrengine/\" Field Value Type Description string | Improve this Doc View Source SchemasFolder Folder, relative to this package, where the ABR JSON schemas are located. Declaration public const string SchemasFolder = \"ABRSchemas~\" Field Value Type Description string Properties | Improve this Doc View Source ABRTransform Cached, readonly version of the ABREngine transform so it can be accessed in a non-main thread Declaration public Transform ABRTransform { get; } Property Value Type Description Transform | Improve this Doc View Source Config Provides access to all of the ABRConfig options that were loaded in at startup. You can safely change this config at runtime without messing up the ScriptableObject representing the underlying ABRConfig. Declaration public ABRConfig Config { get; } Property Value Type Description ABRConfig | Improve this Doc View Source ConfigPrototype Config \"Prototype\" to use for the current ABR configuration. This is set in edit-mode and should NOT be changed at runtime. Instead, use Config. Declaration public static ABRConfig ConfigPrototype { get; set; } Property Value Type Description ABRConfig | Improve this Doc View Source Data System-wide manager for Data (the geometry and variables that make up the visualization) Declaration public DataManager Data { get; } Property Value Type Description DataManager | Improve this Doc View Source DataListener A listener for data connections (e.g., Send2ABR from ParaView) Declaration public SocketDataListener DataListener { get; } Property Value Type Description SocketDataListener | Improve this Doc View Source IsInitialized True if the ABREngine is set up and completely ready to begin rendering. Only returns true once all setup has finished, including: Loading the ABRConfig Connecting to the server (if applicable) Loading any initial state specified by the programmer, or the remote state from the server Declaration public bool IsInitialized { get; } Property Value Type Description bool | Improve this Doc View Source MediaPath Media path where all datasets and visassets are located. If the media path is provided in the ABRConfig, use that media path. Otherwise, use Unity's Application.persistentDataPath. Declaration public string MediaPath { get; } Property Value Type Description string | Improve this Doc View Source SchemasPath Full path where the ABR JSON schemas are located. Declaration public static string SchemasPath { get; } Property Value Type Description string | Improve this Doc View Source State JSON representation of the state that has been previously loaded into ABR Declaration public JObject State { get; } Property Value Type Description JObject | Improve this Doc View Source VisAssets System-wide manager for VisAssets (visual elements used in the visualization) Declaration public VisAssetManager VisAssets { get; } Property Value Type Description VisAssetManager Methods | Improve this Doc View Source Awake() The ABREngine class is the main operational MonoBehaviour Singleton for the ABREngine-UnityPackage. It is in charge of kicking off all startup processes for ABR, including setting up connections with the server, the data listener, VisAssets and Data managers, etc. Declaration protected override void Awake() Overrides IVLab.Utilities.Singleton<IVLab.ABREngine.ABREngine>.Awake() | Improve this Doc View Source ClearState() Remove all data impression groups from the ABR scene (and in turn, remove all data impressions). Declaration public void ClearState() Remarks This method does remove all data impressions, but it does not clean up other state values like custom colormaps, lighting, and gradients. | Improve this Doc View Source CreateDataImpressionGroup(string) Add a new data impression group with a particular name Declaration public DataImpressionGroup CreateDataImpressionGroup(string name) Parameters Type Name Description string name Name of the new data impression group that will be created Returns Type Description DataImpressionGroup The group that has been added. | Improve this Doc View Source CreateDataImpressionGroup(string, Guid) Add a new data impression group with a particular UUID Declaration public DataImpressionGroup CreateDataImpressionGroup(string name, Guid uuid) Parameters Type Name Description string name Name of the new data impression group that will be created Guid uuid UUID to use for the new data impression group Returns Type Description DataImpressionGroup The group that has been added. | Improve this Doc View Source CreateDataImpressionGroup(string, Guid, Bounds?, Matrix4x4?) Add a new data impression group with a particular UUID, bounds, and transformation Declaration public DataImpressionGroup CreateDataImpressionGroup(string name, Guid uuid, Bounds? containerBounds, Matrix4x4? transformMatrix) Parameters Type Name Description string name Name of the new data impression group that will be created Guid uuid UUID to use for the new data impression group Bounds? containerBounds Default bounds to use for this data impression group. Data will be \"squished\" inside this bounding box. Matrix4x4? transformMatrix Default position/rotation/scale (in Unity coordinates) to use for the data impression group. Returns Type Description DataImpressionGroup The group that has been added. | Improve this Doc View Source DuplicateDataImpression(DataImpression) Create and return a duplicate copy of the given data impression. All inputs in the new data impression are identical to the one being copied. By default duplicate data impressions will be placed in their default groups (grouped by dataset). Declaration public DataImpression DuplicateDataImpression(DataImpression impression) Parameters Type Name Description DataImpression impression The data impression that should be duplicated. Returns Type Description DataImpression The new data impression. | Improve this Doc View Source DuplicateDataImpression(DataImpression, DataImpressionGroup) Create and return a duplicate copy of the given data impression. The data impression will be placed within the specified DataImpressionGroup group. If group is null, the default group will be used (either conforming to the input dataset that the data impression has, or the default empty group) Declaration public DataImpression DuplicateDataImpression(DataImpression dataImpression, DataImpressionGroup group) Parameters Type Name Description DataImpression dataImpression The data impression that should be duplicated. DataImpressionGroup group The DataImpressionGroup that the new data impression should be placed into. Returns Type Description DataImpression The new data impression. | Improve this Doc View Source DuplicateDataImpression(DataImpression, bool) Create and return a duplicate copy of the given data impression, but ensure that the copy is within the same data impression group as its source. Declaration public DataImpression DuplicateDataImpression(DataImpression dataImpression, bool retainGroup = true) Parameters Type Name Description DataImpression dataImpression The data impression that should be duplicated. bool retainGroup Ensure the copy of the data impression will exist within the same group as the original, regardless of whether different data have been applied. Returns Type Description DataImpression The new data impression. | Improve this Doc View Source DuplicateDataImpression(Guid) Create and return a duplicate copy of the data impression with a given UUID. All inputs in the new data impression are identical to the one being copied. By default duplicate data impressions will be placed in their default groups (grouped by dataset). Declaration public DataImpression DuplicateDataImpression(Guid uuid) Parameters Type Name Description Guid uuid UUID of the data impression that should be duplicated. Returns Type Description DataImpression The new data impression. | Improve this Doc View Source GetABRConfigs() Get all the configurations available to ABR Declaration public static List<ABRConfig> GetABRConfigs() Returns Type Description List<ABRConfig> | Improve this Doc View Source GetAllDataImpressions() Retrieve ALL data impressions that currently exist within the Engine, over ALL data impression groups. Declaration public List<DataImpression> GetAllDataImpressions() Returns Type Description List<DataImpression> All data impressions that exist in the ABREngine | Improve this Doc View Source GetDataImpression(Func<DataImpression, bool>) Retreive the first data impression found with a particular function crieteria (similar to a \"filter\" or Linq-esque \"where\" operation). Declaration public DataImpression GetDataImpression(Func<DataImpression, bool> criteria) Parameters Type Name Description Func<DataImpression, bool> criteria Function that takes each data impression of any type and returns a boolean. Returns Type Description DataImpression The first data impression of any type that matches criteria, null otherwise. | Improve this Doc View Source GetDataImpression(Guid) Retreive a particular data impression from the Engine Declaration public DataImpression GetDataImpression(Guid uuid) Parameters Type Name Description Guid uuid Unique identifier (UUID) of the data impression to be fetched from the engine Returns Type Description DataImpression A data impression if found, null otherwise. Remarks It is often more useful to use the GetDataImpression<T>(string) method since it returns an actual data impression instead of a DataImpression. | Improve this Doc View Source GetDataImpression(string) Returns the first data impression that is associated with the keyDataPath. Although it is often the case that there will be only one data impression per keyDataPath, this is not always the case. GetDataImpressions(string keyDataPath) can be used to get all of the data impressions with the same keyDataPath. Declaration public DataImpression GetDataImpression(string keyDataPath) Parameters Type Name Description string keyDataPath Returns Type Description DataImpression | Improve this Doc View Source GetDataImpressionGroup(Guid) Retrieve a particular data impression group from the scene Declaration public DataImpressionGroup GetDataImpressionGroup(Guid uuid) Parameters Type Name Description Guid uuid UUID of the data impression group that should be retrieved. Returns Type Description DataImpressionGroup A data impression with a given UUID | Improve this Doc View Source GetDataImpressionGroup(string) The ABREngine class is the main operational MonoBehaviour Singleton for the ABREngine-UnityPackage. It is in charge of kicking off all startup processes for ABR, including setting up connections with the server, the data listener, VisAssets and Data managers, etc. Declaration public DataImpressionGroup GetDataImpressionGroup(string name) Parameters Type Name Description string name Returns Type Description DataImpressionGroup Examples Usage of ABREngine.Instance Most methods of the ABREngine can be accessed through its singleton Instance without needing to do a GetComponent: string mediaPath = ABREngine.Instance.MediaPath; Example: Getting Started with Unity C# and ABR This example shows how to create an ABR visualization in code using one data impression. Note You can also import this example using the Unity Package Manager. In Unity, go to Window > Package Manager, find the ABREngine package, and import the \"Documentation Examples\" sample project. The general process for making an ABR visualization in C# code is: Import data using LoadData(string) Import VisAssets using GetVisAsset<T>(Guid). Create a DataImpression to combine the data and visuals together (using Create<T>(string, Guid, bool)). Use RegisterDataImpression(DataImpression, DataImpressionGroup, bool) to add the impression to the engine. Render the data and visuals to the screen using Render(). using UnityEngine; using IVLab.ABREngine; // Look in the Resources folder of this example to see the data and VisAssets. // Before running this example, make sure the ABR Configuration is set to ABRExamplesConfig! public class ABREngineExample : MonoBehaviour { // Editable in Unity Editor [SerializeField, Tooltip(\"Animated spin rate for the data\"), Range(0.0f, 30.0f)] private float spinRate = 1.0f; // Store the data impression for use in Update() private SimpleGlyphDataImpression dataImpression; void Start() { // Load example VisAssets from resources // A white to orange colormap ColormapVisAsset orange = ABREngine.Instance.VisAssets.GetVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // A triangular glyph GlyphVisAsset triangular = ABREngine.Instance.VisAssets.GetVisAsset<GlyphVisAsset>(new System.Guid(\"1af02820-f1ed-11e9-a623-8c85900fd4af\")); // Load an example dataset from resources // This Key Data has multiple scalar variables defined at each point in // the dataset. We'll use the \"XAxis\" variable, this increases // monotonically from -10 to +10 along the X axis. KeyData pointsKd = ABREngine.Instance.Data.LoadData(\"Demo/Wavelet/KeyData/Points\"); ScalarDataVariable xAxisScalarVar = pointsKd.GetScalarVariable(\"XAxis\"); // Create a Glyph DataImpression and store it for later use dataImpression = DataImpression.Create<SimpleGlyphDataImpression>(\"Example Points\"); // Assign the key data to the Data Impression. This is the \"Geometry\" // with which the data impression will be drawn. dataImpression.keyData = pointsKd; // Tell ABR to map the Color visual channel of the Data Impression to // the \"XAxis\" variable. dataImpression.colorVariable = xAxisScalarVar; // Lastly, apply the colormap and glyph (visual style for this Data // Impresssion) dataImpression.colormap = orange; dataImpression.glyph = triangular; // Finally, add the Data Impression to the ABREngine, and re-render. // Note, this will automatically look for the DataImpression Group // \"Demo/Wavelet\" in the scene, and put this data impression as a child // of that group. ABREngine.Instance.RegisterDataImpression(dataImpression); ABREngine.Instance.Render(); } void Update() { // Access the individual data impression that was created earlier and // spin it around. // // Usually we want to do any manipulations like this at the \"Group\" // level rather than individual data impressions so that multiple data // impressions in the same dataset remain spatially registered with each // other. DataImpressionGroup pointsGroup = ABREngine.Instance.GetGroupFromImpression(dataImpression); pointsGroup.transform.rotation *= Quaternion.Euler(new Vector3(0, Time.deltaTime * spinRate, 0)); } } Example: Using Custom Data This example shows how to quickly get up and running with a custom-defined dataset and building your own data impressions. Before the steps in the previous example, you will also need to: Define your data in some `List`s. Use the RawDatasetAdapter to convert the `List` into an ABR RawDataset, or import an existing ABR RawDataset using LoadRawDataset(string). Import that RawDataset into ABR using ImportRawDataset(RawDataset) (optionally, giving the dataset a data path identifier for easier semantic access later). using System.Collections.Generic; using UnityEngine; using IVLab.ABREngine; /// <summary> /// Example for the main ABREngine class. /// </summary> public class CustomDataABRExample : MonoBehaviour { void Start() { // STEP 1: Define data // 9 points in 3D space List<Vector3> vertices = new List<Vector3> { new Vector3(0.0f, 0.5f, 0.0f), new Vector3(0.0f, 0.6f, 0.1f), new Vector3(0.0f, 0.4f, 0.2f), new Vector3(0.1f, 0.3f, 0.0f), new Vector3(0.1f, 0.2f, 0.1f), new Vector3(0.1f, 0.3f, 0.2f), new Vector3(0.2f, 0.0f, 0.0f), new Vector3(0.2f, 0.3f, 0.1f), new Vector3(0.2f, 0.1f, 0.2f), }; // Data values for those points List<float> data = new List<float>(); for (int i = 0; i < vertices.Count; i++) data.Add(i); // Named scalar variable Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> { { \"someData\", data } }; // Define some generous bounds Bounds b = new Bounds(Vector3.zero, Vector3.one); // STEP 2: Convert the point list into ABR Format RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(vertices, b, scalarVars, null); // STEP 3: Import the point data into ABR so we can use it KeyData pointsKD = ABREngine.Instance.Data.ImportRawDataset(abrPoints); // STEP 4: Import a colormap visasset ColormapVisAsset cmap = ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // STEP 5: Create a Data Impression (layer) for the points, and assign some key data and styling SimpleGlyphDataImpression di = DataImpression.Create<SimpleGlyphDataImpression>(\"Simple Points\"); di.keyData = pointsKD; // Assign key data (point geometry) di.colorVariable = pointsKD.GetScalarVariables()[0]; // Assign scalar variable \"someData\" di.colormap = cmap; // Apply colormap di.glyphSize = 0.002f; // Apply glyph size styling // STEP 6: Register impression with the engine ABREngine.Instance.RegisterDataImpression(di); // STEP 7: Render the visualization ABREngine.Instance.Render(); } } | Improve this Doc View Source GetDataImpressionGroupByDataset(Dataset) Retrieve the first data impression group found that is associated with a particular Dataset. Declaration public DataImpressionGroup GetDataImpressionGroupByDataset(Dataset ds) Parameters Type Name Description Dataset ds Dataset that should be matched with Returns Type Description DataImpressionGroup A data impression with the given dataset. | Improve this Doc View Source GetDataImpressionGroups() Retrieve all data impression groups that currently exist in the Unity ABR scene. Declaration public Dictionary<Guid, DataImpressionGroup> GetDataImpressionGroups() Returns Type Description Dictionary<Guid, DataImpressionGroup> Dictionary mapping of (uuid => DataImpressionGroup) | Improve this Doc View Source GetDataImpression<T>() Retreive the first data impression found with a particular type Declaration public T GetDataImpression<T>() where T : DataImpression Returns Type Description T The first data impression of matching type T, null otherwise. Type Parameters Name Description T Any data impression type implementing DataImpression | Improve this Doc View Source GetDataImpression<T>(Func<T, bool>) Retreive the first data impression found with a particular type AND function crieteria (similar to a \"filter\" or Linq-esque \"where\" operation). Declaration public T GetDataImpression<T>(Func<T, bool> criteria) where T : DataImpression Parameters Type Name Description Func<T, bool> criteria Function that takes each data impression matching type T and returns a boolean. Returns Type Description T The first data impression of type T that matches criteria, null otherwise. Type Parameters Name Description T Any data impression type implementing DataImpression | Improve this Doc View Source GetDataImpression<T>(string) Returns the first data impression within the group that is associated with the keyDataPath. Although it is often the case that there will be only one data impression per keyDataPath, this is not always the case. GetDataImpressions(string keyDataPath) can be used to get all of the data impressions with the same keyDataPath. Declaration public T GetDataImpression<T>(string keyDataPath) where T : DataImpression Parameters Type Name Description string keyDataPath Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source GetDataImpressions(Func<DataImpression, bool>) Retreive the all data impressions found of any type matching function crieteria (similar to a \"filter\" or Linq-esque \"where\" operation). Declaration public List<DataImpression> GetDataImpressions(Func<DataImpression, bool> criteria) Parameters Type Name Description Func<DataImpression, bool> criteria Function that takes each data impression and returns a boolean. Returns Type Description List<DataImpression> All data impressions of any type that matches criteria, null otherwise. | Improve this Doc View Source GetDataImpressions(string) Returns all of the data impressions associated with the specified keyDataPath Declaration public List<DataImpression> GetDataImpressions(string keyDataPath) Parameters Type Name Description string keyDataPath Returns Type Description List<DataImpression> | Improve this Doc View Source GetDataImpressionsOfType<T>() Retrieve all data impressions in an ABR state of a given impression type (e.g., all SimpleSurfaceDataImpressions) Declaration [Obsolete(\"GetDataImpressionsOfType<T> is obsolete, use GetDataImpressions<T> instead\")] public List<T> GetDataImpressionsOfType<T>() where T : DataImpression Returns Type Description List<T> A list of data impressions that have a particular type Type Parameters Name Description T | Improve this Doc View Source GetDataImpressionsWithTag(string) Retrieve all data impressions in an ABR scene that have a particular tag. Note that the ABREngine does not do anything with tags; these exist solely for application developers. Declaration public List<DataImpression> GetDataImpressionsWithTag(string tag) Parameters Type Name Description string tag The tag to check for Returns Type Description List<DataImpression> A list of data impressions with a particular tag | Improve this Doc View Source GetDataImpressions<T>() Retreive the all data impressions found of a particular type Declaration public List<T> GetDataImpressions<T>() where T : DataImpression Returns Type Description List<T> All data impressions of type T. Type Parameters Name Description T Any data impression type implementing DataImpression | Improve this Doc View Source GetDataImpressions<T>(Func<T, bool>) Retreive the all data impressions found of a particular type matching function crieteria (similar to a \"filter\" or Linq-esque \"where\" operation). Declaration public List<T> GetDataImpressions<T>(Func<T, bool> criteria) where T : DataImpression Parameters Type Name Description Func<T, bool> criteria Function that takes each data impression of type T and returns a boolean. Returns Type Description List<T> All data impressions of type T that match the criteria. Type Parameters Name Description T Any data impression type implementing DataImpression | Improve this Doc View Source GetDataImpressions<T>(string) Returns all of the data impressions associated with the specified keyDataPath Declaration public List<T> GetDataImpressions<T>(string keyDataPath) where T : DataImpression Parameters Type Name Description string keyDataPath Returns Type Description List<T> Type Parameters Name Description T | Improve this Doc View Source GetGroupFromImpression(DataImpression) Get the data impression group a particular data impression Declaration public DataImpressionGroup GetGroupFromImpression(DataImpression dataImpression) Parameters Type Name Description DataImpression dataImpression Data impression to find out the group of Returns Type Description DataImpressionGroup The data impression group dataImpression belongs to, otherwise null. | Improve this Doc View Source GetKeyData(string) The ABREngine class is the main operational MonoBehaviour Singleton for the ABREngine-UnityPackage. It is in charge of kicking off all startup processes for ABR, including setting up connections with the server, the data listener, VisAssets and Data managers, etc. Declaration public KeyData GetKeyData(string keyDataPath) Parameters Type Name Description string keyDataPath Returns Type Description KeyData Examples Usage of ABREngine.Instance Most methods of the ABREngine can be accessed through its singleton Instance without needing to do a GetComponent: string mediaPath = ABREngine.Instance.MediaPath; Example: Getting Started with Unity C# and ABR This example shows how to create an ABR visualization in code using one data impression. Note You can also import this example using the Unity Package Manager. In Unity, go to Window > Package Manager, find the ABREngine package, and import the \"Documentation Examples\" sample project. The general process for making an ABR visualization in C# code is: Import data using LoadData(string) Import VisAssets using GetVisAsset<T>(Guid). Create a DataImpression to combine the data and visuals together (using Create<T>(string, Guid, bool)). Use RegisterDataImpression(DataImpression, DataImpressionGroup, bool) to add the impression to the engine. Render the data and visuals to the screen using Render(). using UnityEngine; using IVLab.ABREngine; // Look in the Resources folder of this example to see the data and VisAssets. // Before running this example, make sure the ABR Configuration is set to ABRExamplesConfig! public class ABREngineExample : MonoBehaviour { // Editable in Unity Editor [SerializeField, Tooltip(\"Animated spin rate for the data\"), Range(0.0f, 30.0f)] private float spinRate = 1.0f; // Store the data impression for use in Update() private SimpleGlyphDataImpression dataImpression; void Start() { // Load example VisAssets from resources // A white to orange colormap ColormapVisAsset orange = ABREngine.Instance.VisAssets.GetVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // A triangular glyph GlyphVisAsset triangular = ABREngine.Instance.VisAssets.GetVisAsset<GlyphVisAsset>(new System.Guid(\"1af02820-f1ed-11e9-a623-8c85900fd4af\")); // Load an example dataset from resources // This Key Data has multiple scalar variables defined at each point in // the dataset. We'll use the \"XAxis\" variable, this increases // monotonically from -10 to +10 along the X axis. KeyData pointsKd = ABREngine.Instance.Data.LoadData(\"Demo/Wavelet/KeyData/Points\"); ScalarDataVariable xAxisScalarVar = pointsKd.GetScalarVariable(\"XAxis\"); // Create a Glyph DataImpression and store it for later use dataImpression = DataImpression.Create<SimpleGlyphDataImpression>(\"Example Points\"); // Assign the key data to the Data Impression. This is the \"Geometry\" // with which the data impression will be drawn. dataImpression.keyData = pointsKd; // Tell ABR to map the Color visual channel of the Data Impression to // the \"XAxis\" variable. dataImpression.colorVariable = xAxisScalarVar; // Lastly, apply the colormap and glyph (visual style for this Data // Impresssion) dataImpression.colormap = orange; dataImpression.glyph = triangular; // Finally, add the Data Impression to the ABREngine, and re-render. // Note, this will automatically look for the DataImpression Group // \"Demo/Wavelet\" in the scene, and put this data impression as a child // of that group. ABREngine.Instance.RegisterDataImpression(dataImpression); ABREngine.Instance.Render(); } void Update() { // Access the individual data impression that was created earlier and // spin it around. // // Usually we want to do any manipulations like this at the \"Group\" // level rather than individual data impressions so that multiple data // impressions in the same dataset remain spatially registered with each // other. DataImpressionGroup pointsGroup = ABREngine.Instance.GetGroupFromImpression(dataImpression); pointsGroup.transform.rotation *= Quaternion.Euler(new Vector3(0, Time.deltaTime * spinRate, 0)); } } Example: Using Custom Data This example shows how to quickly get up and running with a custom-defined dataset and building your own data impressions. Before the steps in the previous example, you will also need to: Define your data in some `List`s. Use the RawDatasetAdapter to convert the `List` into an ABR RawDataset, or import an existing ABR RawDataset using LoadRawDataset(string). Import that RawDataset into ABR using ImportRawDataset(RawDataset) (optionally, giving the dataset a data path identifier for easier semantic access later). using System.Collections.Generic; using UnityEngine; using IVLab.ABREngine; /// <summary> /// Example for the main ABREngine class. /// </summary> public class CustomDataABRExample : MonoBehaviour { void Start() { // STEP 1: Define data // 9 points in 3D space List<Vector3> vertices = new List<Vector3> { new Vector3(0.0f, 0.5f, 0.0f), new Vector3(0.0f, 0.6f, 0.1f), new Vector3(0.0f, 0.4f, 0.2f), new Vector3(0.1f, 0.3f, 0.0f), new Vector3(0.1f, 0.2f, 0.1f), new Vector3(0.1f, 0.3f, 0.2f), new Vector3(0.2f, 0.0f, 0.0f), new Vector3(0.2f, 0.3f, 0.1f), new Vector3(0.2f, 0.1f, 0.2f), }; // Data values for those points List<float> data = new List<float>(); for (int i = 0; i < vertices.Count; i++) data.Add(i); // Named scalar variable Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> { { \"someData\", data } }; // Define some generous bounds Bounds b = new Bounds(Vector3.zero, Vector3.one); // STEP 2: Convert the point list into ABR Format RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(vertices, b, scalarVars, null); // STEP 3: Import the point data into ABR so we can use it KeyData pointsKD = ABREngine.Instance.Data.ImportRawDataset(abrPoints); // STEP 4: Import a colormap visasset ColormapVisAsset cmap = ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // STEP 5: Create a Data Impression (layer) for the points, and assign some key data and styling SimpleGlyphDataImpression di = DataImpression.Create<SimpleGlyphDataImpression>(\"Simple Points\"); di.keyData = pointsKD; // Assign key data (point geometry) di.colorVariable = pointsKD.GetScalarVariables()[0]; // Assign scalar variable \"someData\" di.colormap = cmap; // Apply colormap di.glyphSize = 0.002f; // Apply glyph size styling // STEP 6: Register impression with the engine ABREngine.Instance.RegisterDataImpression(di); // STEP 7: Render the visualization ABREngine.Instance.Render(); } } | Improve this Doc View Source GetKeyDataStartsWith(string) The ABREngine class is the main operational MonoBehaviour Singleton for the ABREngine-UnityPackage. It is in charge of kicking off all startup processes for ABR, including setting up connections with the server, the data listener, VisAssets and Data managers, etc. Declaration public Dictionary<string, KeyData> GetKeyDataStartsWith(string keyDataPathStartsWith) Parameters Type Name Description string keyDataPathStartsWith Returns Type Description Dictionary<string, KeyData> Examples Usage of ABREngine.Instance Most methods of the ABREngine can be accessed through its singleton Instance without needing to do a GetComponent: string mediaPath = ABREngine.Instance.MediaPath; Example: Getting Started with Unity C# and ABR This example shows how to create an ABR visualization in code using one data impression. Note You can also import this example using the Unity Package Manager. In Unity, go to Window > Package Manager, find the ABREngine package, and import the \"Documentation Examples\" sample project. The general process for making an ABR visualization in C# code is: Import data using LoadData(string) Import VisAssets using GetVisAsset<T>(Guid). Create a DataImpression to combine the data and visuals together (using Create<T>(string, Guid, bool)). Use RegisterDataImpression(DataImpression, DataImpressionGroup, bool) to add the impression to the engine. Render the data and visuals to the screen using Render(). using UnityEngine; using IVLab.ABREngine; // Look in the Resources folder of this example to see the data and VisAssets. // Before running this example, make sure the ABR Configuration is set to ABRExamplesConfig! public class ABREngineExample : MonoBehaviour { // Editable in Unity Editor [SerializeField, Tooltip(\"Animated spin rate for the data\"), Range(0.0f, 30.0f)] private float spinRate = 1.0f; // Store the data impression for use in Update() private SimpleGlyphDataImpression dataImpression; void Start() { // Load example VisAssets from resources // A white to orange colormap ColormapVisAsset orange = ABREngine.Instance.VisAssets.GetVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // A triangular glyph GlyphVisAsset triangular = ABREngine.Instance.VisAssets.GetVisAsset<GlyphVisAsset>(new System.Guid(\"1af02820-f1ed-11e9-a623-8c85900fd4af\")); // Load an example dataset from resources // This Key Data has multiple scalar variables defined at each point in // the dataset. We'll use the \"XAxis\" variable, this increases // monotonically from -10 to +10 along the X axis. KeyData pointsKd = ABREngine.Instance.Data.LoadData(\"Demo/Wavelet/KeyData/Points\"); ScalarDataVariable xAxisScalarVar = pointsKd.GetScalarVariable(\"XAxis\"); // Create a Glyph DataImpression and store it for later use dataImpression = DataImpression.Create<SimpleGlyphDataImpression>(\"Example Points\"); // Assign the key data to the Data Impression. This is the \"Geometry\" // with which the data impression will be drawn. dataImpression.keyData = pointsKd; // Tell ABR to map the Color visual channel of the Data Impression to // the \"XAxis\" variable. dataImpression.colorVariable = xAxisScalarVar; // Lastly, apply the colormap and glyph (visual style for this Data // Impresssion) dataImpression.colormap = orange; dataImpression.glyph = triangular; // Finally, add the Data Impression to the ABREngine, and re-render. // Note, this will automatically look for the DataImpression Group // \"Demo/Wavelet\" in the scene, and put this data impression as a child // of that group. ABREngine.Instance.RegisterDataImpression(dataImpression); ABREngine.Instance.Render(); } void Update() { // Access the individual data impression that was created earlier and // spin it around. // // Usually we want to do any manipulations like this at the \"Group\" // level rather than individual data impressions so that multiple data // impressions in the same dataset remain spatially registered with each // other. DataImpressionGroup pointsGroup = ABREngine.Instance.GetGroupFromImpression(dataImpression); pointsGroup.transform.rotation *= Quaternion.Euler(new Vector3(0, Time.deltaTime * spinRate, 0)); } } Example: Using Custom Data This example shows how to quickly get up and running with a custom-defined dataset and building your own data impressions. Before the steps in the previous example, you will also need to: Define your data in some `List`s. Use the RawDatasetAdapter to convert the `List` into an ABR RawDataset, or import an existing ABR RawDataset using LoadRawDataset(string). Import that RawDataset into ABR using ImportRawDataset(RawDataset) (optionally, giving the dataset a data path identifier for easier semantic access later). using System.Collections.Generic; using UnityEngine; using IVLab.ABREngine; /// <summary> /// Example for the main ABREngine class. /// </summary> public class CustomDataABRExample : MonoBehaviour { void Start() { // STEP 1: Define data // 9 points in 3D space List<Vector3> vertices = new List<Vector3> { new Vector3(0.0f, 0.5f, 0.0f), new Vector3(0.0f, 0.6f, 0.1f), new Vector3(0.0f, 0.4f, 0.2f), new Vector3(0.1f, 0.3f, 0.0f), new Vector3(0.1f, 0.2f, 0.1f), new Vector3(0.1f, 0.3f, 0.2f), new Vector3(0.2f, 0.0f, 0.0f), new Vector3(0.2f, 0.3f, 0.1f), new Vector3(0.2f, 0.1f, 0.2f), }; // Data values for those points List<float> data = new List<float>(); for (int i = 0; i < vertices.Count; i++) data.Add(i); // Named scalar variable Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> { { \"someData\", data } }; // Define some generous bounds Bounds b = new Bounds(Vector3.zero, Vector3.one); // STEP 2: Convert the point list into ABR Format RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(vertices, b, scalarVars, null); // STEP 3: Import the point data into ABR so we can use it KeyData pointsKD = ABREngine.Instance.Data.ImportRawDataset(abrPoints); // STEP 4: Import a colormap visasset ColormapVisAsset cmap = ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); // STEP 5: Create a Data Impression (layer) for the points, and assign some key data and styling SimpleGlyphDataImpression di = DataImpression.Create<SimpleGlyphDataImpression>(\"Simple Points\"); di.keyData = pointsKD; // Assign key data (point geometry) di.colorVariable = pointsKD.GetScalarVariables()[0]; // Assign scalar variable \"someData\" di.colormap = cmap; // Apply colormap di.glyphSize = 0.002f; // Apply glyph size styling // STEP 6: Register impression with the engine ABREngine.Instance.RegisterDataImpression(di); // STEP 7: Render the visualization ABREngine.Instance.Render(); } } | Improve this Doc View Source HasDataImpression(Guid) Check to see if the data impression with a given uuid exists Declaration public bool HasDataImpression(Guid uuid) Parameters Type Name Description Guid uuid Unique identifier (UUID) of the requisite data impression Returns Type Description bool A boolean whether or not this data impression is present in this ABR state | Improve this Doc View Source HasDataImpressionGroup(Guid) Check if a particular data impression group exists. Declaration public bool HasDataImpressionGroup(Guid uuid) Parameters Type Name Description Guid uuid UUID to check existence of Returns Type Description bool Boolean - true if the given group exists in the current ABR state, false otherwise. | Improve this Doc View Source LoadState<T>(string) Load a state into ABR. This includes the following steps: All Data and VisAssets from the state have been loaded. The ABR scene has been rendered with all updates (including data impressions, lighting, etc.). The OnStateChanged callback has been fired. Declaration public void LoadState<T>(string stateName) where T : IABRStateLoader, new() Parameters Type Name Description string stateName Type Parameters Name Description T Remarks Data impressions that have not changed will not be re-rendered. Examples A state may be loaded from any of the following places: // A Resources folder (in Assets or in a Package) ABREngine.Instance.LoadState<ResourceStateFileLoader>(\"exampleState.json\"); // A local file ABREngine.Instance.LoadState<PathStateFileLoader>(\"C:/Users/VRDemo/Desktop/test.json\"); // A JSON string ABREngine.Instance.LoadState<TextStateFileLoader>(\"{\\\"version\\\": \\\"0.2.0\\\", \\\"name\\\": \\\"test\\\"}\"); // A web resource ABREngine.Instance.LoadState<HttpStateFileLoader>(\"http://localhost:8000/api/state\"); | Improve this Doc View Source MoveImpressionToGroup(DataImpression, DataImpressionGroup, bool) Move a data impression from its current group to a new group. Declaration public void MoveImpressionToGroup(DataImpression dataImpression, DataImpressionGroup newGroup, bool allowOverwrite = true) Parameters Type Name Description DataImpression dataImpression The data impression that should be moved. DataImpressionGroup newGroup The group to place the data impression into. bool allowOverwrite Should we destroy any existing data impressions with this UUID within the newGroup? | Improve this Doc View Source RegisterDataImpression(DataImpression, DataImpressionGroup, bool) Register a new data impression with the ABREngine and add it to a specific DataImpressionGroup. Declaration public void RegisterDataImpression(DataImpression dataImpression, DataImpressionGroup newGroup, bool allowOverwrite = true) Parameters Type Name Description DataImpression dataImpression The data impression to register with the engine DataImpressionGroup newGroup Group to add this data impression to bool allowOverwrite Should we destroy any existing data impressions that have this UUID already? | Improve this Doc View Source RegisterDataImpression(DataImpression, bool) Register a new data impression, or replace an existing one. If the data impression has a dataset, defaults to placing it inside the existing group with the same dataset, or creating a new DataImpressionGroup with that dataset if no group exists yet. Declaration public void RegisterDataImpression(DataImpression dataImpression, bool allowOverwrite = true) Parameters Type Name Description DataImpression dataImpression The data impression to register with the engine bool allowOverwrite Should we destroy any existing data impressions that have this UUID already? | Improve this Doc View Source RemoveDataImpressionGroup(Guid) Remove a given data impression group from the scene, destroying all of the data impressions within the group. Declaration public void RemoveDataImpressionGroup(Guid uuid) Parameters Type Name Description Guid uuid UUID of the data impression group that should be removed. | Improve this Doc View Source Render() Go through every data impression group's impressions and render them. Each impression intelligently decides if the entire geometry needs to be recomputed (slow), or if only the style has changed (fast). Declaration public void Render() | Improve this Doc View Source SaveState<T>(string) Save a state from the ABR Unity scene back to a particular JSON destination. Declaration public void SaveState<T>(string overrideStateName = null) where T : IABRStateLoader, new() Parameters Type Name Description string overrideStateName Type Parameters Name Description T Remarks The SaveState functionality is only implemented in a few IABRStateLoader classes, namely PathStateFileLoader and HttpStateFileLoader. This method generally takes a long time so should not be called frequently. Also, since this method manually looks through GameObjects in the scene to reverse-engineer a JSON state, so the resulting JSON state may not always be complete. Examples ABR states can be saved like this: // Save the current state to a file on your computer ABREngine.Instance.SaveState<PathStateFileLoader>(\"C:/Users/VRDemo/Desktop/exampleState.json\"); // Save the current state to a web resource ABREngine.Instance.SaveState<HttpStateFileLoader>(\"http://localhost:8000/api/state\"); | Improve this Doc View Source UnregisterDataImpression(Guid) Remove a data impression from the ABR state. Declaration public void UnregisterDataImpression(Guid uuid) Parameters Type Name Description Guid uuid The UUID data impression to remove (unregister) from the ABREngine | Improve this Doc View Source WaitUntilInitialized() Wait until the Engine is fully initialized before proceeding to use it. Declaration public Task WaitUntilInitialized() Returns Type Description Task Examples For example, if we want to do some ABREngine-dependant tasks in a MonoBehaviour Start(): using UnityEngine; using IVLab.ABREngine; public class ABRInitializerExample : MonoBehaviour { void Start() { // Wait for the engine to initialize... while (!ABREngine.Instance.IsInitialized); // ... then print out some very important information that // depends on ABR being initialized Debug.Log(ABREngine.Instance.Config.defaultBounds); } }"
  },
  "api/IVLab.ABREngine.ABRInputAttribute.html": {
    "href": "api/IVLab.ABREngine.ABRInputAttribute.html",
    "title": "Class ABRInputAttribute | ABREngine",
    "keywords": "Class ABRInputAttribute Input attribute used for annotating an ABR input to a data impression (VisAsset, DataVariable, etc.) Inheritance object Attribute ABRInputAttribute Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Field)] public class ABRInputAttribute : Attribute Constructors | Improve this Doc View Source ABRInputAttribute(string, UpdateLevel) Input attribute used for annotating an ABR input to a data impression (VisAsset, DataVariable, etc.) Declaration public ABRInputAttribute(string inputName, UpdateLevel updateLevel) Parameters Type Name Description string inputName UpdateLevel updateLevel Fields | Improve this Doc View Source inputName Name of the input - should match the name in the ABR Schema (see @abr-schema.md). Declaration public string inputName Field Value Type Description string | Improve this Doc View Source updateLevel What UpdateLevel does this input necessitate when changed? Declaration public UpdateLevel updateLevel Field Value Type Description UpdateLevel"
  },
  "api/IVLab.ABREngine.ABRInputGenre.html": {
    "href": "api/IVLab.ABREngine.ABRInputGenre.html",
    "title": "Enum ABRInputGenre | ABREngine",
    "keywords": "Enum ABRInputGenre Possible genres of a visualization input Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public enum ABRInputGenre Fields Name Description KeyData Possible genres of a visualization input Primitive Possible genres of a visualization input PrimitiveGradient Possible genres of a visualization input Variable Possible genres of a visualization input VisAsset Possible genres of a visualization input"
  },
  "api/IVLab.ABREngine.ABRInputIndexerModule.html": {
    "href": "api/IVLab.ABREngine.ABRInputIndexerModule.html",
    "title": "Class ABRInputIndexerModule | ABREngine",
    "keywords": "Class ABRInputIndexerModule Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Inheritance object ABRInputIndexerModule Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ABRInputIndexerModule Constructors | Improve this Doc View Source ABRInputIndexerModule(DataImpression) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public ABRInputIndexerModule(DataImpression target) Parameters Type Name Description DataImpression target Properties | Improve this Doc View Source ABRInputFields Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration protected FieldInfo[] ABRInputFields { get; } Property Value Type Description FieldInfo[] | Improve this Doc View Source ABRInputIndicesByName Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration protected Dictionary<string, int> ABRInputIndicesByName { get; } Property Value Type Description Dictionary<string, int> | Improve this Doc View Source InputCount Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public int InputCount { get; } Property Value Type Description int | Improve this Doc View Source InputNames Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public string[] InputNames { get; } Property Value Type Description string[] Methods | Improve this Doc View Source AssignInput(int, IABRInput) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public void AssignInput(int inputIndex, IABRInput value) Parameters Type Name Description int inputIndex IABRInput value | Improve this Doc View Source AssignInput(FieldInfo, IABRInput) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration protected void AssignInput(FieldInfo inputField, IABRInput value) Parameters Type Name Description FieldInfo inputField IABRInput value | Improve this Doc View Source AssignInput(string, IABRInput) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public void AssignInput(string inputName, IABRInput value) Parameters Type Name Description string inputName IABRInput value | Improve this Doc View Source CanAssignInput(int, IABRInput) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public bool CanAssignInput(int inputIndex, IABRInput value) Parameters Type Name Description int inputIndex IABRInput value Returns Type Description bool | Improve this Doc View Source CanAssignInput(string, IABRInput) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public bool CanAssignInput(string inputName, IABRInput value) Parameters Type Name Description string inputName IABRInput value Returns Type Description bool | Improve this Doc View Source CatalogABRInputNames(FieldInfo[]) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration protected static string[] CatalogABRInputNames(FieldInfo[] abrInputs) Parameters Type Name Description FieldInfo[] abrInputs Returns Type Description string[] | Improve this Doc View Source GetABRInputFields(object) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration protected static FieldInfo[] GetABRInputFields(object target) Parameters Type Name Description object target Returns Type Description FieldInfo[] | Improve this Doc View Source GetInputField(int) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public FieldInfo GetInputField(int inputIndex) Parameters Type Name Description int inputIndex Returns Type Description FieldInfo | Improve this Doc View Source GetInputField(string) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public FieldInfo GetInputField(string inputName) Parameters Type Name Description string inputName Returns Type Description FieldInfo | Improve this Doc View Source GetInputIndex(string) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public int GetInputIndex(string inputName) Parameters Type Name Description string inputName Returns Type Description int | Improve this Doc View Source GetInputName(int) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public string GetInputName(int inputIndex) Parameters Type Name Description int inputIndex Returns Type Description string | Improve this Doc View Source GetInputType(int) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public Type GetInputType(int inputIndex) Parameters Type Name Description int inputIndex Returns Type Description Type | Improve this Doc View Source GetInputType(string) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public Type GetInputType(string inputName) Parameters Type Name Description string inputName Returns Type Description Type | Improve this Doc View Source GetInputValue(int) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public IABRInput GetInputValue(int inputIndex) Parameters Type Name Description int inputIndex Returns Type Description IABRInput | Improve this Doc View Source GetInputValue(string) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration public IABRInput GetInputValue(string inputName) Parameters Type Name Description string inputName Returns Type Description IABRInput | Improve this Doc View Source IndexABRInputsByName(FieldInfo[]) Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. Declaration protected static Dictionary<string, int> IndexABRInputsByName(FieldInfo[] abrInputs) Parameters Type Name Description FieldInfo[] abrInputs Returns Type Description Dictionary<string, int>"
  },
  "api/IVLab.ABREngine.ABRLight.html": {
    "href": "api/IVLab.ABREngine.ABRLight.html",
    "title": "Class ABRLight | ABREngine",
    "keywords": "Class ABRLight Inheritance object Object Component Behaviour MonoBehaviour ABRLight Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [AddComponentMenu(\"ABR/ABR Light\")] [RequireComponent(typeof(Light))] public class ABRLight : MonoBehaviour"
  },
  "api/IVLab.ABREngine.ABRLightManager.html": {
    "href": "api/IVLab.ABREngine.ABRLightManager.html",
    "title": "Class ABRLightManager | ABREngine",
    "keywords": "Class ABRLightManager Transfer any lights in the ABR scene to variables in the volume rendering shader. Inheritance object Object Component Behaviour MonoBehaviour ABRLightManager Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ABRLightManager : MonoBehaviour"
  },
  "api/IVLab.ABREngine.ABRPlateType.html": {
    "href": "api/IVLab.ABREngine.ABRPlateType.html",
    "title": "Class ABRPlateType | ABREngine",
    "keywords": "Class ABRPlateType Attribute to match up this class with the string plate name from the ABR Schema Inheritance object Attribute ABRPlateType Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [AttributeUsage(AttributeTargets.Class)] public class ABRPlateType : Attribute Constructors | Improve this Doc View Source ABRPlateType(string) Attribute to match up this class with the string plate name from the ABR Schema Declaration public ABRPlateType(string plateType) Parameters Type Name Description string plateType Fields | Improve this Doc View Source plateType Attribute to match up this class with the string plate name from the ABR Schema Declaration public string plateType Field Value Type Description string"
  },
  "api/IVLab.ABREngine.ABRServer.html": {
    "href": "api/IVLab.ABREngine.ABRServer.html",
    "title": "Class ABRServer | ABREngine",
    "keywords": "Class ABRServer The ABRServer class functions as a passthrough to the Python server. It defines several helpful constants and functions for working with the server (e.g., starting, stopping, etc.) Inheritance object ABRServer Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ABRServer Fields | Improve this Doc View Source ServerFolder Folder, relative to this package, where the ABR server is located. Declaration public const string ServerFolder = \"ABRServer~\" Field Value Type Description string Properties | Improve this Doc View Source ServerPath Path to the server executable on this platform Declaration public static string ServerPath { get; } Property Value Type Description string | Improve this Doc View Source ServerRootFullPath Full path to where the ABR server is located. Declaration public static string ServerRootFullPath { get; } Property Value Type Description string | Improve this Doc View Source ServerRootPath Relative path to where the ABR server is located. Declaration public static string ServerRootPath { get; } Property Value Type Description string Methods | Improve this Doc View Source OpenServerFolder() Convenience function to open a file explorer in the ABRServer~ folder so users can easily get to the server. Declaration public static void OpenServerFolder()"
  },
  "api/IVLab.ABREngine.ABRStateParser.html": {
    "href": "api/IVLab.ABREngine.ABRStateParser.html",
    "title": "Class ABRStateParser | ABREngine",
    "keywords": "Class ABRStateParser The ABRStateParser takes a (text) ABR state from JSON and loads its components into Unity, or takes the current state of objects in the Unity scene and translates it back into text. Inheritance object ABRStateParser Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ABRStateParser Methods | Improve this Doc View Source LoadState<T>(string, JObject) The LoadState method, the workhorse of this class, has side effects that range from populating new GameObjects for data impressions, to loading new data, to loading in VisAssets. By the end of LoadState, the visualization should be complete in the Unity scene. Declaration public JObject LoadState<T>(string stateText, JObject previousState) where T : IABRStateLoader, new() Parameters Type Name Description string stateText JObject previousState Returns Type Description JObject Type Parameters Name Description T | Improve this Doc View Source SerializeState(JObject) The SerializeState method takes the current state of the ABR unity scene and attempts to put it back into JSON form. There are several fields that aren't stored anywhere in the ABREngine, and must thus rely on the JSON version of the previous state. Declaration public string SerializeState(JObject previousState) Parameters Type Name Description JObject previousState Returns Type Description string"
  },
  "api/IVLab.ABREngine.AnglePrimitive.html": {
    "href": "api/IVLab.ABREngine.AnglePrimitive.html",
    "title": "Class AnglePrimitive | ABREngine",
    "keywords": "Class AnglePrimitive Inheritance object FloatPrimitive AnglePrimitive Implements IFloatPrimitive IPrimitive IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class AnglePrimitive : FloatPrimitive, IFloatPrimitive, IPrimitive, IABRInput Constructors | Improve this Doc View Source AnglePrimitive(float) Declaration public AnglePrimitive(float value) Parameters Type Name Description float value | Improve this Doc View Source AnglePrimitive(string) Declaration public AnglePrimitive(string value) Parameters Type Name Description string value Properties | Improve this Doc View Source ParsingRegex The regex to use to convert this from a string. Group named \"value\" should be the floating point number, group named \"units\" should be the units, if any. Declaration public override Regex ParsingRegex { get; } Property Value Type Description Regex Overrides FloatPrimitive.ParsingRegex | Improve this Doc View Source Units Declaration public override string Units { get; } Property Value Type Description string Overrides FloatPrimitive.Units Methods | Improve this Doc View Source SetFromString(string) Set the value of the primitive from a string (similar to using the string constructor) Declaration public override void SetFromString(string value) Parameters Type Name Description string value Overrides FloatPrimitive.SetFromString(string) Operators | Improve this Doc View Source implicit operator AnglePrimitive(float) Declaration public static implicit operator AnglePrimitive(float f) Parameters Type Name Description float f Returns Type Description AnglePrimitive Implements IFloatPrimitive IPrimitive IABRInput"
  },
  "api/IVLab.ABREngine.BooleanPrimitive.html": {
    "href": "api/IVLab.ABREngine.BooleanPrimitive.html",
    "title": "Class BooleanPrimitive | ABREngine",
    "keywords": "Class BooleanPrimitive Inheritance object BooleanPrimitive Implements IPrimitive IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class BooleanPrimitive : IPrimitive, IABRInput Constructors | Improve this Doc View Source BooleanPrimitive() Declaration public BooleanPrimitive() | Improve this Doc View Source BooleanPrimitive(bool) Declaration public BooleanPrimitive(bool value) Parameters Type Name Description bool value | Improve this Doc View Source BooleanPrimitive(string) Declaration public BooleanPrimitive(string value) Parameters Type Name Description string value Properties | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre | Improve this Doc View Source ParsingRegex The regex to use to convert this from a string. Group named \"value\" should be the floating point number, group named \"units\" should be the units, if any. Declaration public Regex ParsingRegex { get; } Property Value Type Description Regex | Improve this Doc View Source Value Declaration public bool Value { get; protected set; } Property Value Type Description bool Methods | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput | Improve this Doc View Source SetFromString(string) Set the value of the primitive from a string (similar to using the string constructor) Declaration public void SetFromString(string value) Parameters Type Name Description string value | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Operators | Improve this Doc View Source implicit operator BooleanPrimitive(bool) Declaration public static implicit operator BooleanPrimitive(bool b) Parameters Type Name Description bool b Returns Type Description BooleanPrimitive Implements IPrimitive IABRInput"
  },
  "api/IVLab.ABREngine.ColormapVisAsset.html": {
    "href": "api/IVLab.ABREngine.ColormapVisAsset.html",
    "title": "Class ColormapVisAsset | ABREngine",
    "keywords": "Class ColormapVisAsset Inheritance object VisAsset ColormapVisAsset Implements IColormapVisAsset IVisAsset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ColormapVisAsset : VisAsset, IColormapVisAsset, IVisAsset, IABRInput Constructors | Improve this Doc View Source ColormapVisAsset() Declaration public ColormapVisAsset() | Improve this Doc View Source ColormapVisAsset(Colormap) Declaration public ColormapVisAsset(Colormap colormap) Parameters Type Name Description Colormap colormap | Improve this Doc View Source ColormapVisAsset(Guid, Colormap) Declaration public ColormapVisAsset(Guid uuid, Colormap colormap) Parameters Type Name Description Guid uuid Colormap colormap | Improve this Doc View Source ColormapVisAsset(Guid, Texture2D) Declaration [Obsolete(\"Constructing a ColormapVisAsset from Texture2D is no longer recommended; instead use an IVLab.Utilities.Colormap like `new ColormapVisAsset(..., Colormap)`.\")] public ColormapVisAsset(Guid uuid, Texture2D colormap) Parameters Type Name Description Guid uuid Texture2D colormap | Improve this Doc View Source ColormapVisAsset(Texture2D) Declaration [Obsolete(\"Constructing a ColormapVisAsset from Texture2D is no longer recommended; instead use an IVLab.Utilities.Colormap like `new ColormapVisAsset(..., Colormap)`.\")] public ColormapVisAsset(Texture2D colormap) Parameters Type Name Description Texture2D colormap Properties | Improve this Doc View Source Colormap Declaration public Colormap Colormap { get; } Property Value Type Description Colormap | Improve this Doc View Source ColormapTexture Declaration public Texture2D ColormapTexture { get; } Property Value Type Description Texture2D | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration public int VisAssetCount { get; } Property Value Type Description int Methods | Improve this Doc View Source GetColorGradient() Declaration public Texture2D GetColorGradient() Returns Type Description Texture2D | Improve this Doc View Source GetColorInterp(float) Declaration public Color GetColorInterp(float interpAmount) Parameters Type Name Description float interpAmount Returns Type Description Color | Improve this Doc View Source SolidColor(Color) Declaration public static ColormapVisAsset SolidColor(Color fillColor) Parameters Type Name Description Color fillColor Returns Type Description ColormapVisAsset Implements IColormapVisAsset IVisAsset IABRInput"
  },
  "api/IVLab.ABREngine.DataImpression.html": {
    "href": "api/IVLab.ABREngine.DataImpression.html",
    "title": "Class DataImpression | ABREngine",
    "keywords": "Class DataImpression Main class for Data Impressions (layers) in an ABR visualization. Every Data Impression is a GameObject in the scene. Inheritance object Object Component Behaviour MonoBehaviour DataImpression InstancedSurfaceDataImpression SimpleGlyphDataImpression SimpleLineDataImpression SimpleSurfaceDataImpression SimpleVolumeDataImpression Implements IHasDataset IHasKeyData ICoordSpaceConverter Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public abstract class DataImpression : MonoBehaviour, IHasDataset, IHasKeyData, ICoordSpaceConverter Constructors | Improve this Doc View Source DataImpression() Main class for Data Impressions (layers) in an ABR visualization. Every Data Impression is a GameObject in the scene. Declaration protected DataImpression() Properties | Improve this Doc View Source BoundsInDataSpace Returns the spatial bounding box of the data in the original coordinate system of the data. Data Space coordinates are typically based upon real world units, like meters. Declaration public Bounds BoundsInDataSpace { get; } Property Value Type Description Bounds | Improve this Doc View Source BoundsInWorldSpace Returns the spatial bounding box of the data in Unity's world space. Declaration public Bounds BoundsInWorldSpace { get; } Property Value Type Description Bounds | Improve this Doc View Source DataToWorldMatrix Transformation matrix from data space to world space. Declaration public Matrix4x4 DataToWorldMatrix { get; } Property Value Type Description Matrix4x4 | Improve this Doc View Source ImpressionMaterials Slot to load the material into at runtime Declaration protected virtual Material[] ImpressionMaterials { get; set; } Property Value Type Description Material[] | Improve this Doc View Source InputIndexer Used for getting/setting ABRInputs on this DataImpression Declaration public ABRInputIndexerModule InputIndexer { get; set; } Property Value Type Description ABRInputIndexerModule | Improve this Doc View Source KeyDataRenderInfo Cache of current KeyData rendering information Declaration protected virtual IKeyDataRenderInfo KeyDataRenderInfo { get; set; } Property Value Type Description IKeyDataRenderInfo | Improve this Doc View Source MatPropBlock Storage for the rendering data to be sent to the shader Declaration protected virtual MaterialPropertyBlock MatPropBlock { get; set; } Property Value Type Description MaterialPropertyBlock | Improve this Doc View Source MaterialNames Name of the material to use to render this DataImpression Declaration protected virtual string[] MaterialNames { get; } Property Value Type Description string[] | Improve this Doc View Source RenderHints Any hints to provide the rendering engine, such as if the impression should be hidden Declaration public RenderHints RenderHints { get; set; } Property Value Type Description RenderHints | Improve this Doc View Source RenderInfo Cache of current rendering information Declaration public virtual IDataImpressionRenderInfo RenderInfo { get; set; } Property Value Type Description IDataImpressionRenderInfo | Improve this Doc View Source SaveToState Save this DataImpression to state. Sometimes, it's desireable to create data impressions that only exist in the Unity Editor and DON'T get saved to state. By default, this is false. For data impressions created in ABRStateParser, it is true. Declaration public bool SaveToState { get; set; } Property Value Type Description bool | Improve this Doc View Source Tags A list of tags that this data impression has - solely used for external purposes (the engine does nothing with them) Declaration public List<string> Tags { get; set; } Property Value Type Description List<string> | Improve this Doc View Source Uuid Unique identifier for this Data Impression Assigned on object creation Declaration public Guid Uuid { get; set; } Property Value Type Description Guid | Improve this Doc View Source WorldToDataMatrix Transformation matrix from world space to data space. Declaration public Matrix4x4 WorldToDataMatrix { get; } Property Value Type Description Matrix4x4 Methods | Improve this Doc View Source Cleanup() When this data impression is done being used, clean up after itself if necessary. This method may need access to the GameObject the data impression is applied to. Declaration public virtual void Cleanup() | Improve this Doc View Source Clone() Create and return a copy of this data impression (with a new UUID) Declaration public DataImpression Clone() Returns Type Description DataImpression | Improve this Doc View Source CloneStyle() Create a copy of this data impression, but only its \"style\" inputs. Declaration public DataImpression CloneStyle() Returns Type Description DataImpression | Improve this Doc View Source CloneStyleLinked() Clone a data impression's style and link Declaration public DataImpression CloneStyleLinked() Returns Type Description DataImpression | Improve this Doc View Source ComputeGeometry() RENDERING STEP 1. Populate rendering information (Geometry) for the DataImpression. This is triggered by the DataImpressionGroup when an Geometry happens. This step is generally expensive. Declaration public abstract void ComputeGeometry() | Improve this Doc View Source ContainsDataSpacePoint(Vector3) Returns true if the point in data coordinates lies within the volume. Data coordinates are typically defined in real-world units, like meters. Declaration public bool ContainsDataSpacePoint(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description bool | Improve this Doc View Source ContainsWorldSpacePoint(Vector3) Returns true if the point in Unity World coordinates lies within the bounds of the data. Declaration public bool ContainsWorldSpacePoint(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description bool | Improve this Doc View Source CopyFrom(DataImpression) Update this data impression's fields from an existing data impression. Declaration public void CopyFrom(DataImpression other) Parameters Type Name Description DataImpression other | Improve this Doc View Source CopyStyleFrom(DataImpression) Update the style of this data impression from another data impression's style Declaration public void CopyStyleFrom(DataImpression other) Parameters Type Name Description DataImpression other | Improve this Doc View Source Create<T>(string, Guid, bool) Construct a data impession with a given UUID and name. Warning This method will be called from ABRStateParser and MUST have the given arguments. If you override this method, bad things might happen. Declaration public static T Create<T>(string name, Guid uuid = default, bool saveToState = false) where T : DataImpression Parameters Type Name Description string name Non-unique, human-readable identifier for this data impression Guid uuid Unique identifier for this data impression. If left empty, will create a new UUID. bool saveToState Should this data impression be saved when SaveState<T>(string) is called? Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source DataSpacePointToWorldSpace(Vector3) Converts a point in the original data coordinate space, which is typically defined in real-world units, like meters, to its current position in Unity's World coordinate system, which might include a scale or translation or other transformation based on how the visualization is designed. Declaration public Vector3 DataSpacePointToWorldSpace(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description Vector3 | Improve this Doc View Source DataSpaceVectorToWorldSpace(Vector3) Converts a Vector in the original data coordinate space, which is typically defined in real-world units, like meters, to its current position in Unity's World coordinate system, which might include a scale or translation or other transformation based on how the visualization is designed. Declaration public Vector3 DataSpaceVectorToWorldSpace(Vector3 dataSpaceVector) Parameters Type Name Description Vector3 dataSpaceVector Returns Type Description Vector3 | Improve this Doc View Source GetDataImpressionGroup() Get the group that this DataImpression is a part of. Declaration public DataImpressionGroup GetDataImpressionGroup() Returns Type Description DataImpressionGroup | Improve this Doc View Source GetDataset() By default, there's no dataset. DataImpressions should only have one dataset, and it's up to them individually to enforce that they correctly implement this. Declaration public abstract Dataset GetDataset() Returns Type Description Dataset | Improve this Doc View Source GetKeyData() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public abstract KeyData GetKeyData() Returns Type Description KeyData | Improve this Doc View Source GetKeyDataTopology() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public abstract DataTopology GetKeyDataTopology() Returns Type Description DataTopology | Improve this Doc View Source HasTag(string) Check if the DataImpression has a particular tag Declaration public bool HasTag(string tag) Parameters Type Name Description string tag The tag Returns Type Description bool Returns true if the data impression's tag list contains the specified tag | Improve this Doc View Source LinkStyleFrom(DataImpression) Copy the style from another data impression and link their styles so this data impression updates all its style dependencies when it is changed Declaration public void LinkStyleFrom(DataImpression other) Parameters Type Name Description DataImpression other | Improve this Doc View Source SetKeyData(KeyData) By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public abstract void SetKeyData(KeyData kd) Parameters Type Name Description KeyData kd | Improve this Doc View Source SetupGameObject() RENDERING STEP 2. Take geometric rendering information computed in ComputeGeometry() and sets up proper game object(s) and components for this Data Impression. Transfers geometry into Unity format (e.g. a Mesh). No geometric computations should happen in this method, and it should generally be lightweight. Declaration public abstract void SetupGameObject() | Improve this Doc View Source UpdateStyleDependencies() Update all the style dependencies for this data impression - ensure they have the same styling and render hints. Declaration public void UpdateStyleDependencies() | Improve this Doc View Source UpdateStyling() RENDERING STEP 3. Update the \"styling\" of an impression by sending each styling parameter to the shader. Occasionally will need to set per-vertex items like transforms. This method should generally be lightweight. Declaration public abstract void UpdateStyling() | Improve this Doc View Source UpdateVisibility() RENDERING STEP 4. Update the visibility of an impression (hidden or shown) Declaration public abstract void UpdateVisibility() | Improve this Doc View Source WorldSpacePointToDataSpace(Vector3) Converts a point in Unity world coordinates to a point within the original data coordinate space. The data coordinate space is typically defined in real-world units, like cm or meters. Those coordinates are often scaled or repositioned within Unity World space as we zoom into the data or place multiple datasets side-by-side or do other visualization tasks. Declaration public Vector3 WorldSpacePointToDataSpace(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description Vector3 | Improve this Doc View Source WorldSpaceVectorToDataSpace(Vector3) Converts a vector in Unity world coordinates to a vector within the original data coordinate space. The data coordinate space is typically defined in real-world units, like cm or meters. Those coordinates are often scaled or repositioned within Unity World space as we zoom into the data or place multiple datasets side-by-side or do other visualization tasks. Declaration public Vector3 WorldSpaceVectorToDataSpace(Vector3 worldSpaceVector) Parameters Type Name Description Vector3 worldSpaceVector Returns Type Description Vector3 Implements IHasDataset IHasKeyData ICoordSpaceConverter"
  },
  "api/IVLab.ABREngine.DataImpressionGroup.html": {
    "href": "api/IVLab.ABREngine.DataImpressionGroup.html",
    "title": "Class DataImpressionGroup | ABREngine",
    "keywords": "Class DataImpressionGroup A DataImpressionGroup is a group of data impressions within ABR. DataImpressionGroups can be constrained within a defined bounding box (see ABRDataContainer), and can automatically rescale all of their data to stay within this container. Each time a new KeyData object is loaded into a data impression in this group, the GroupToDataMatrix and GroupBounds are updated. Inheritance object Object Component Behaviour MonoBehaviour DataImpressionGroup Implements IHasDataset ICoordSpaceConverter Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [AddComponentMenu(\"ABR/Data Impression Group\")] public class DataImpressionGroup : MonoBehaviour, IHasDataset, ICoordSpaceConverter Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. Fields | Improve this Doc View Source GroupBounds The actual bounds (contained within DataContainer) of the group-scale dataset Declaration public Bounds GroupBounds Field Value Type Description Bounds Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GroupToDataMatrix Transformation from the original data space into the room-scale bounds. Multiply by a vector to go from group-space into data-space. Declaration public Matrix4x4 GroupToDataMatrix Field Value Type Description Matrix4x4 Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. Properties | Improve this Doc View Source BoundsInDataSpace Returns the spatial bounding box of the data in the original coordinate system of the data. Data Space coordinates are typically based upon real world units, like meters. Declaration public Bounds BoundsInDataSpace { get; } Property Value Type Description Bounds Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source BoundsInWorldSpace Get the bounds of this data impression group in Unity world space. Declaration public Bounds BoundsInWorldSpace { get; } Property Value Type Description Bounds Remarks [!INFO] If the data impression group has a transform applied, this returns different bounds than those specified by the GroupBounds. | Improve this Doc View Source DataToWorldMatrix Transforms from data space (Data Impression Group's data space) to world space Data Space ==(DataToGroupMatrix)=> Group local space ==(transform.localToWorldMatrix)==> World space Declaration public Matrix4x4 DataToWorldMatrix { get; } Property Value Type Description Matrix4x4 Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source Uuid Unique identifier for this group Declaration public Guid Uuid { get; } Property Value Type Description Guid Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source WorldToDataMatrix Transforms from world space to data space (the Data Impression Group's dataset space) World Space ==(transform.worldToLocalMatrix)=> Group local space ==(GroupToDataMatrix)==> Data space Declaration public Matrix4x4 WorldToDataMatrix { get; } Property Value Type Description Matrix4x4 Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. Methods | Improve this Doc View Source AddDataImpression(DataImpression, bool) Add a data impression to this group. All data impressions in the same group NEED to have the same dataset, error will be displayed otherwise. Declaration public void AddDataImpression(DataImpression impression, bool allowOverwrite = true) Parameters Type Name Description DataImpression impression bool allowOverwrite Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source Clear() Remove all data impressions from this DataImpressionGroup Declaration public void Clear() Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source ContainsDataSpacePoint(Vector3) Returns true if the point in data coordinates lies within the volume. Data coordinates are typically defined in real-world units, like meters. Declaration public bool ContainsDataSpacePoint(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description bool Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source ContainsWorldSpacePoint(Vector3) Returns true if the point in Unity World coordinates lies within the bounds of the data. Declaration public bool ContainsWorldSpacePoint(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description bool Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source DataSpacePointToWorldSpace(Vector3) Converts a point in the original data coordinate space, which is typically defined in real-world units, like meters, to its current position in Unity's World coordinate system, which might include a scale or translation or other transformation based on how the visualization is designed. Declaration public Vector3 DataSpacePointToWorldSpace(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description Vector3 Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source DataSpaceVectorToWorldSpace(Vector3) Converts a Vector in the original data coordinate space, which is typically defined in real-world units, like meters, to its current position in Unity's World coordinate system, which might include a scale or translation or other transformation based on how the visualization is designed. Declaration public Vector3 DataSpaceVectorToWorldSpace(Vector3 dataSpaceVector) Parameters Type Name Description Vector3 dataSpaceVector Returns Type Description Vector3 Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpression(Func<DataImpression, bool>) Get a data impression matching a particular criteria Declaration public DataImpression GetDataImpression(Func<DataImpression, bool> criteria) Parameters Type Name Description Func<DataImpression, bool> criteria Returns Type Description DataImpression The data impression, if found, otherwise null Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. Examples This method can be used to access data impressions in a functional manner, for example checking if the impression has a particular colormap assigned. DataImpressionGroup group; group.GetDataImpression((di) => { try { SimpleSurfaceDataImpression sdi = di as SimpleSurfaceDataImpression; return sdi.colormap.Uuid == new Guid(\"5a761a72-8bcb-11ea-9265-005056bae6d8\"); } catch { return null; } }); | Improve this Doc View Source GetDataImpression(Guid) Get a data impression by its UUID Declaration public DataImpression GetDataImpression(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description DataImpression The data impression, if found, otherwise null Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpression<T>() Get a data impression matching a type Declaration public T GetDataImpression<T>() where T : DataImpression Returns Type Description T Type Parameters Name Description T Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpression<T>(Func<T, bool>) Get a data impression matching a type AND a particular criteria Declaration public T GetDataImpression<T>(Func<T, bool> criteria) where T : DataImpression Parameters Type Name Description Func<T, bool> criteria Returns Type Description T Type Parameters Name Description T Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. Examples This method can be used as a more elegant way to access individual types of data impressions. DataImpressionGroup group; group.GetDataImpression<SimpleSurfaceDataImpression>((di) => { // di is already a SimpleSurfaceDataImpression return sdi.colormap.Uuid == new Guid(\"5a761a72-8bcb-11ea-9265-005056bae6d8\"); }); | Improve this Doc View Source GetDataImpressions() Return all data impressions inside this data impression group Declaration public Dictionary<Guid, DataImpression> GetDataImpressions() Returns Type Description Dictionary<Guid, DataImpression> Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpressions(Func<DataImpression, bool>) Return all data impressions that match a particular criteria Declaration public List<DataImpression> GetDataImpressions(Func<DataImpression, bool> criteria) Parameters Type Name Description Func<DataImpression, bool> criteria Returns Type Description List<DataImpression> Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpressionsOfType<T>() Get all data impressions in this group that match a particular type (e.g. get all SimpleSurfaceDataImpressions). Declaration [Obsolete(\"GetDataImpressionsOfType<T> is obsolete, use GetDataImpressions<T> instead\")] public List<T> GetDataImpressionsOfType<T>() where T : DataImpression Returns Type Description List<T> Type Parameters Name Description T Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpressionsWithTag(string) Get all data impressions that have a particular tag. Tags can be any string value. They are not used internally to the engine but can be useful for keeping track of data impressions in applications that use ABR. Declaration public List<DataImpression> GetDataImpressionsWithTag(string tag) Parameters Type Name Description string tag Returns Type Description List<DataImpression> Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpressions<T>() Return all data impressions that have a particular type Declaration public List<T> GetDataImpressions<T>() where T : DataImpression Returns Type Description List<T> Type Parameters Name Description T Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataImpressions<T>(Func<T, bool>) Return all data impressions that match a particular criteria AND have a particular type Declaration public List<T> GetDataImpressions<T>(Func<T, bool> criteria) where T : DataImpression Parameters Type Name Description Func<T, bool> criteria Returns Type Description List<T> Type Parameters Name Description T Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source GetDataset() Get the dataset that all impressions in this DataImpressionGroup are associated with. All DataImpressionGroups MUST have only one dataset. Declaration public Dataset GetDataset() Returns Type Description Dataset Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source HasDataImpression(Guid) Return whether or not the data impression with a given UUID is present in this DataImpressionGroup Declaration public bool HasDataImpression(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description bool Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source HasEncodedGameObject(Guid) Check to see if a data impression with a particular UUID has a GameObject yet Declaration public bool HasEncodedGameObject(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description bool Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source RecalculateBounds() From scratch, recalculate the bounds of this DataImpressionGroup. Start with a zero-size bounding box and expand until it encapsulates all datasets. Declaration public bool RecalculateBounds() Returns Type Description bool Returns a boolean whether or not the bounds have changed since last recalculation Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source RemoveDataImpression(Guid) Remove data impression, returning true if this data impression group is empty after the removal of such impression. Declaration public bool RemoveDataImpression(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description bool Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source RenderImpressions() Render every data impression inside this data impression group. Three levels of \"update\" are provided for each data impression (see RenderHints for more information): Recompute everything if the data source has changed (geometry, style, visibility) Only recompute style if only the style (variables, visassets, etc.) has changed Only toggle visibility if only that has changed Declaration public void RenderImpressions() Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source TryGetContainerBoundsInGroupSpace(out Bounds) Get the bounds of the container containing all the data in this DataImpressionGroup Declaration public bool TryGetContainerBoundsInGroupSpace(out Bounds container) Parameters Type Name Description Bounds container Returns Type Description bool Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source TryGetContainerBoundsInWorldSpace(out Bounds) A DataImpressionGroup is a group of data impressions within ABR. DataImpressionGroups can be constrained within a defined bounding box (see ABRDataContainer), and can automatically rescale all of their data to stay within this container. Each time a new KeyData object is loaded into a data impression in this group, the GroupToDataMatrix and GroupBounds are updated. Declaration public bool TryGetContainerBoundsInWorldSpace(out Bounds container) Parameters Type Name Description Bounds container Returns Type Description bool Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source WorldSpacePointToDataSpace(Vector3) Converts a point in Unity world coordinates to a point within the original data coordinate space. The data coordinate space is typically defined in real-world units, like cm or meters. Those coordinates are often scaled or repositioned within Unity World space as we zoom into the data or place multiple datasets side-by-side or do other visualization tasks. Declaration public Vector3 WorldSpacePointToDataSpace(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description Vector3 Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. | Improve this Doc View Source WorldSpaceVectorToDataSpace(Vector3) Converts a vector in Unity world coordinates to a vector within the original data coordinate space. The data coordinate space is typically defined in real-world units, like cm or meters. Those coordinates are often scaled or repositioned within Unity World space as we zoom into the data or place multiple datasets side-by-side or do other visualization tasks. Declaration public Vector3 WorldSpaceVectorToDataSpace(Vector3 worldSpaceVector) Parameters Type Name Description Vector3 worldSpaceVector Returns Type Description Vector3 Remarks DataImpressionGroups cannot be constructed directly, you MUST use the a variation of the CreateDataImpressionGroup(string) method. Implements IHasDataset ICoordSpaceConverter"
  },
  "api/IVLab.ABREngine.DataManager.html": {
    "href": "api/IVLab.ABREngine.DataManager.html",
    "title": "Class DataManager | ABREngine",
    "keywords": "Class DataManager Manager where all datasets, key data, and variables live. This class makes the connection between Datasets and RawDatasets. This class is useful for obtaining any KeyData and Variables needed to apply to Data Impressions. Inheritance object DataManager Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class DataManager Examples When constructing a custom dataset, you can load it directly into the engine and access its imported contents via the KeyData object returned by ImportRawDataset(RawDataset). public class DataManagerExample : MonoBehaviour { void Start() { // Generate 100 random points with \"data\" values List<Vector3> points = new List<Vector3>(); List<float> dataValues = new List<float>(); for (int i = 0; i < 100; i++) { points.Add(Random.insideUnitSphere); dataValues.Add(i); } // Create some bounds Bounds b = new Bounds(Vector3.zero, Vector3.one); // Create a dictionary to name the scalar values Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> {{ \"someData\", dataValues }}; // Create an ABR-formatted dataset RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(points, b, scalarVars, null); // AND, import these data to ABR KeyData pointsKD = ABREngine.Instance.Data.ImportRawDataset(abrPoints); // From here, we can access the keyData, scalarVariables, and vectorVariables Debug.Log(pointsKD); // the key data (point geometry) we just imported Debug.Log(pointsKD.GetScalarVariables().Length); // length of 1 Debug.Log(pointsKD.GetScalarVariables()[0]); // the 'someData' variable we declared above Debug.Log(pointsKD.GetVectorVariables().Length); // length of 0 -- we didn't declare any vector vars here. } } Additionally, the actual raw data can be loaded from the data manager. Generally this is not necessary, simply using the high-level variables above in conjunction with Data Impressions is usually sufficient. RawDataset rds = null; if (ABREngine.Instance.Data.TryGetRawDataset(\"Test/Test/KeyData/Example\", out rds)) { float[] var = rds.GetScalarArray(\"ExampleVar\"); } Constructors | Improve this Doc View Source DataManager(string) Manager where all datasets, key data, and variables live. This class makes the connection between Datasets and RawDatasets. This class is useful for obtaining any KeyData and Variables needed to apply to Data Impressions. Declaration public DataManager(string datasetPath) Parameters Type Name Description string datasetPath Examples When constructing a custom dataset, you can load it directly into the engine and access its imported contents via the KeyData object returned by ImportRawDataset(RawDataset). public class DataManagerExample : MonoBehaviour { void Start() { // Generate 100 random points with \"data\" values List<Vector3> points = new List<Vector3>(); List<float> dataValues = new List<float>(); for (int i = 0; i < 100; i++) { points.Add(Random.insideUnitSphere); dataValues.Add(i); } // Create some bounds Bounds b = new Bounds(Vector3.zero, Vector3.one); // Create a dictionary to name the scalar values Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> {{ \"someData\", dataValues }}; // Create an ABR-formatted dataset RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(points, b, scalarVars, null); // AND, import these data to ABR KeyData pointsKD = ABREngine.Instance.Data.ImportRawDataset(abrPoints); // From here, we can access the keyData, scalarVariables, and vectorVariables Debug.Log(pointsKD); // the key data (point geometry) we just imported Debug.Log(pointsKD.GetScalarVariables().Length); // length of 1 Debug.Log(pointsKD.GetScalarVariables()[0]); // the 'someData' variable we declared above Debug.Log(pointsKD.GetVectorVariables().Length); // length of 0 -- we didn't declare any vector vars here. } } Additionally, the actual raw data can be loaded from the data manager. Generally this is not necessary, simply using the high-level variables above in conjunction with Data Impressions is usually sufficient. RawDataset rds = null; if (ABREngine.Instance.Data.TryGetRawDataset(\"Test/Test/KeyData/Example\", out rds)) { float[] var = rds.GetScalarArray(\"ExampleVar\"); } Methods | Improve this Doc View Source CacheRawDataset(string, RawDataset) Save a copy of a RawDataset into the media folder. Declaration public void CacheRawDataset(string dataPath, RawDataset rds) Parameters Type Name Description string dataPath RawDataset rds | Improve this Doc View Source CacheRawDataset(string, in string, in byte[]) Save a copy of the RawDataset described by json and data to the media folder. Declaration public void CacheRawDataset(string dataPath, in string json, in byte[] data) Parameters Type Name Description string dataPath string json byte[] data | Improve this Doc View Source GetAllKeyData() Gets ALL the key data that have been loaded into the ABREngine, regardless of dataset. Declaration public List<KeyData> GetAllKeyData() Returns Type Description List<KeyData> List of currently loaded KeyData | Improve this Doc View Source GetDatasets() Retrieve all datasets that are currently loaded into the ABR Engine Declaration public List<Dataset> GetDatasets() Returns Type Description List<Dataset> List of currently loaded Datasets | Improve this Doc View Source GetKeyData(string) Gets key data with a particular path Declaration public KeyData GetKeyData(string keyDataPath) Parameters Type Name Description string keyDataPath Returns Type Description KeyData | Improve this Doc View Source ImportRawDataset(RawDataset) Import a raw dataset into ABR. This method makes the dataset available as a key data object and makes all of its scalar and vector variables available across ABR. Declaration public KeyData ImportRawDataset(RawDataset importing) Parameters Type Name Description RawDataset importing Returns Type Description KeyData Returns the Key Data and variables that were just imported to this data path. | Improve this Doc View Source ImportRawDataset(string, RawDataset) Import a raw dataset into ABR. This method makes the dataset available as a key data object and makes all of its scalar and vector variables available across ABR. Declaration public KeyData ImportRawDataset(string dataPath, RawDataset importing) Parameters Type Name Description string dataPath RawDataset importing Returns Type Description KeyData Returns the Key Data and variables that were just imported to this data path. | Improve this Doc View Source LoadData(string) Attempt to load the data described in dataPath from any available resource, including a Resources folder, the The Media Folder, or a HTTP web resource. Declaration public KeyData LoadData(string dataPath) Parameters Type Name Description string dataPath Data path to load. If loading from the media directory, you can use the relative path inside that folder (but exclude the .bin/.json extension) Returns Type Description KeyData Returns the KeyData object if the dataset was found, null if not found. | Improve this Doc View Source LoadRawDataset(string) Load a raw dataset into a RawDataset object by its data path and return the rawdataset after it has been successfully imported. Declaration public RawDataset LoadRawDataset(string dataPath) Parameters Type Name Description string dataPath Data path to load. If loading from the media directory, you can use the relative path inside that folder (but exclude the .bin/.json extension) Returns Type Description RawDataset Returns the actual RawDataset if the dataset was found, null if not found. Examples If you're working with a pre-existing dataset (i.e., one that already exists in ABR raw data format in your media folder), you can use LoadRawDataset(string) to obtain a RawDataset. // Load from a .bin/.json file pair in the datasets folder in the // media directory. Most of the time when you're fetching an existing // dataset, this is what you'll want to do. Just make sure the // dataset actually exists in the media folder! // Or, load from a Resources directory in Unity. // You can also load an ABR raw dataset from a web resource. This requires setting up an ABR data server. RawDataset ds1 = ABREngine.Instance.Data.LoadRawDataset(\"Test/Test/KeyData/Example\"); | Improve this Doc View Source LoadRawDataset<T>(string) Load a raw dataset into a RawDataset object by its data path and return the rawdataset after it has been successfully imported. Declaration [Obsolete(\"It is recommended to use `LoadData` or `LoadRawDataset` instead of this method.\")] public RawDataset LoadRawDataset<T>(string dataPath) where T : IDataLoader, new() Parameters Type Name Description string dataPath Data path to load. If loading from the media directory, you can use the relative path inside that folder (but exclude the .bin/.json extension) Returns Type Description RawDataset Returns the actual RawDataset if the dataset was found, null if not found. Type Parameters Name Description T Any IDataLoader type Examples If you're working with a pre-existing dataset (i.e., one that already exists in ABR raw data format in your media folder), you can use LoadRawDataset(string) to obtain a RawDataset. // Load from a .bin/.json file pair in the datasets folder in the // media directory. Most of the time when you're fetching an existing // dataset, this is what you'll want to do. Just make sure the // dataset actually exists in the media folder! RawDataset ds1 = ABREngine.Instance.Data.LoadRawDataset<MediaDataLoader>(\"Test/Test/KeyData/Example\"); // You can also load an ABR raw dataset from a web resource. This requires setting up an ABR data server. RawDataset ds2 = ABREngine.Instance.Data.LoadRawDataset<HttpDataLoader>(\"Test/Test/KeyData/Example\"); | Improve this Doc View Source TryGetDataset(string, out Dataset) Attempt to get a lightweight dataset by its data path. Declaration public bool TryGetDataset(string dataPath, out Dataset dataset) Parameters Type Name Description string dataPath Dataset dataset Returns Type Description bool Returns true if the dataset was found, and populates the out Dataset dataset accordingly. | Improve this Doc View Source TryGetRawDataset(string, out RawDataset) Attempt to get a RawDataset at a particular data path. Declaration public bool TryGetRawDataset(string dataPath, out RawDataset dataset) Parameters Type Name Description string dataPath RawDataset dataset Returns Type Description bool Returns true if the raw dataset was found, false if not, and populates the out RawDataset dataset accordingly. | Improve this Doc View Source UnloadRawDataset(string) Entirely remove a RawDataset from ABR memory. Declaration public void UnloadRawDataset(string dataPath) Parameters Type Name Description string dataPath The data path / key data to be unloaded Remarks This method does not check if the dataset is currently in use, so utilize this method with care!"
  },
  "api/IVLab.ABREngine.DataPath.DataPathType.html": {
    "href": "api/IVLab.ABREngine.DataPath.DataPathType.html",
    "title": "Enum DataPath.DataPathType | ABREngine",
    "keywords": "Enum DataPath.DataPathType Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public enum DataPath.DataPathType Fields Name Description Dataset KeyData ScalarVar VectorVar"
  },
  "api/IVLab.ABREngine.DataPath.html": {
    "href": "api/IVLab.ABREngine.DataPath.html",
    "title": "Class DataPath | ABREngine",
    "keywords": "Class DataPath A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Inheritance object DataPath Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public static class DataPath Methods | Improve this Doc View Source FollowsConvention(string, DataPathType) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static bool FollowsConvention(string label, DataPath.DataPathType pathType = DataPathType.KeyData) Parameters Type Name Description string label DataPath.DataPathType pathType Returns Type Description bool | Improve this Doc View Source GetConvention(DataPathType) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetConvention(DataPath.DataPathType pathType) Parameters Type Name Description DataPath.DataPathType pathType Returns Type Description string | Improve this Doc View Source GetDataset(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetDataset(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source GetDatasetPath(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetDatasetPath(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source GetName(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetName(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source GetNamePath(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetNamePath(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source GetOrganization(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetOrganization(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source GetOrganizationPath(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetOrganizationPath(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source GetPathType(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetPathType(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source GetPathTypePath(string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string GetPathTypePath(string dataPath) Parameters Type Name Description string dataPath Returns Type Description string | Improve this Doc View Source Join(string, DataPathType) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string Join(string path1, DataPath.DataPathType pathType) Parameters Type Name Description string path1 DataPath.DataPathType pathType Returns Type Description string | Improve this Doc View Source Join(string, DataPathType, string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string Join(string datasetPath, DataPath.DataPathType pathType3, string path4) Parameters Type Name Description string datasetPath DataPath.DataPathType pathType3 string path4 Returns Type Description string | Improve this Doc View Source Join(string, string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string Join(string path1, string path2) Parameters Type Name Description string path1 string path2 Returns Type Description string | Improve this Doc View Source Join(string, string, DataPathType, string) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static string Join(string path1, string path2, DataPath.DataPathType pathType3, string path4) Parameters Type Name Description string path1 string path2 DataPath.DataPathType pathType3 string path4 Returns Type Description string | Improve this Doc View Source WarnOnDataPathFormat(string, DataPathType) A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature Declaration public static void WarnOnDataPathFormat(string dataPath, DataPath.DataPathType dataPathType) Parameters Type Name Description string dataPath DataPath.DataPathType dataPathType"
  },
  "api/IVLab.ABREngine.DataPoint.html": {
    "href": "api/IVLab.ABREngine.DataPoint.html",
    "title": "Class DataPoint | ABREngine",
    "keywords": "Class DataPoint A DataPoint describes a point in a dataset. Often, this is useful when querying a dataset, for example, to find the closest data point to a given point in world space. Inheritance object DataPoint Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class DataPoint Fields | Improve this Doc View Source cellIndex \"Cell\" index that this point belongs to. \"Cells\" are implemented differently for different types of data. See the table below to see what cells represent in each data type / DataImpression type: DataImpression Type DataTopology Type Cell Description SimpleSurfaceDataImpression Triangles or Quads Cells are the indices of triangles or quads SimpleLineDataImpression LineStrip Cells represent individual lines SimpleGlyphDataImpression Points Cells are unused, will always be 0 InstancedSurfaceDataImpression Points Cells are unused, will always be 0 Declaration public int cellIndex Field Value Type Description int | Improve this Doc View Source dataSpacePoint The coordinates of the point, in data space Declaration public Vector3 dataSpacePoint Field Value Type Description Vector3 | Improve this Doc View Source keyData Key data that the data point belongs to. Declaration public KeyData keyData Field Value Type Description KeyData | Improve this Doc View Source vertexIndex \"Vertex\" index that this point belongs to. Declaration public int vertexIndex Field Value Type Description int | Improve this Doc View Source worldSpacePoint The coordinates of the point, in Unity world space Declaration public Vector3 worldSpacePoint Field Value Type Description Vector3"
  },
  "api/IVLab.ABREngine.DataRange-1.html": {
    "href": "api/IVLab.ABREngine.DataRange-1.html",
    "title": "Class DataRange<T> | ABREngine",
    "keywords": "Class DataRange<T> Range descriptor for a variable, including a min and max. Inheritance object DataRange<T> Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class DataRange<T> Type Parameters Name Description T Fields | Improve this Doc View Source max Range descriptor for a variable, including a min and max. Declaration public T max Field Value Type Description T | Improve this Doc View Source min Range descriptor for a variable, including a min and max. Declaration public T min Field Value Type Description T Methods | Improve this Doc View Source Equals(DataRange<T>) Range descriptor for a variable, including a min and max. Declaration public bool Equals(DataRange<T> other) Parameters Type Name Description DataRange<T> other Returns Type Description bool | Improve this Doc View Source Equals(object) Range descriptor for a variable, including a min and max. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides object.Equals(object) | Improve this Doc View Source GetHashCode() Range descriptor for a variable, including a min and max. Declaration public override int GetHashCode() Returns Type Description int Overrides object.GetHashCode() | Improve this Doc View Source ToString() Range descriptor for a variable, including a min and max. Declaration public override string ToString() Returns Type Description string Overrides object.ToString()"
  },
  "api/IVLab.ABREngine.DataTopology.html": {
    "href": "api/IVLab.ABREngine.DataTopology.html",
    "title": "Enum DataTopology | ABREngine",
    "keywords": "Enum DataTopology Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public enum DataTopology Fields Name Description LineStrip Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels. Lines Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels. Points Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels. Quads Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels. Triangles Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels. Voxels Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels."
  },
  "api/IVLab.ABREngine.Dataset.html": {
    "href": "api/IVLab.ABREngine.Dataset.html",
    "title": "Class Dataset | ABREngine",
    "keywords": "Class Dataset Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Inheritance object Dataset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class Dataset Constructors | Improve this Doc View Source Dataset(string, Bounds, Transform) Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public Dataset(string dataPath, Bounds bounds, Transform parent) Parameters Type Name Description string dataPath Bounds bounds Transform parent Fields | Improve this Doc View Source DataSpaceBounds The bounds of the original, data-scale dataset, which grow as we add more datasets Declaration public Bounds DataSpaceBounds Field Value Type Description Bounds Properties | Improve this Doc View Source Path Path of this dataset (should conform to DataPath) Declaration public string Path { get; } Property Value Type Description string Methods | Improve this Doc View Source AddKeyData(KeyData) Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public void AddKeyData(KeyData keyData) Parameters Type Name Description KeyData keyData | Improve this Doc View Source AddScalarVariable(ScalarDataVariable) Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public void AddScalarVariable(ScalarDataVariable scalarVar) Parameters Type Name Description ScalarDataVariable scalarVar | Improve this Doc View Source AddVectorVariable(VectorDataVariable) Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public void AddVectorVariable(VectorDataVariable vectorVar) Parameters Type Name Description VectorDataVariable vectorVar | Improve this Doc View Source GetAllKeyData() Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public Dictionary<string, KeyData> GetAllKeyData() Returns Type Description Dictionary<string, KeyData> | Improve this Doc View Source GetAllScalarVars() Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public Dictionary<string, ScalarDataVariable> GetAllScalarVars() Returns Type Description Dictionary<string, ScalarDataVariable> | Improve this Doc View Source GetAllVectorVars() Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public Dictionary<string, VectorDataVariable> GetAllVectorVars() Returns Type Description Dictionary<string, VectorDataVariable> | Improve this Doc View Source GetKeyData() All KeyData objects within this dataset Declaration public KeyData[] GetKeyData() Returns Type Description KeyData[] | Improve this Doc View Source GetScalarVariables() Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public ScalarDataVariable[] GetScalarVariables() Returns Type Description ScalarDataVariable[] | Improve this Doc View Source GetScalarVariables(KeyData) All ScalarDataVariable objects within this dataset. NOTE: Not every ScalarDataVariable applies to every KeyData object! Declaration public ScalarDataVariable[] GetScalarVariables(KeyData associatedWith) Parameters Type Name Description KeyData associatedWith Returns Type Description ScalarDataVariable[] | Improve this Doc View Source GetVectorVariables() Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public VectorDataVariable[] GetVectorVariables() Returns Type Description VectorDataVariable[] | Improve this Doc View Source GetVectorVariables(KeyData) All VectorDataVariable objects within this dataset. NOTE: Not every VectorDataVariable applies to every KeyData object! Declaration public VectorDataVariable[] GetVectorVariables(KeyData associatedWith) Parameters Type Name Description KeyData associatedWith Returns Type Description VectorDataVariable[] | Improve this Doc View Source TryGetKeyData(string, out KeyData) Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public bool TryGetKeyData(string dataPath, out KeyData keyData) Parameters Type Name Description string dataPath KeyData keyData Returns Type Description bool | Improve this Doc View Source TryGetScalarVar(string, out ScalarDataVariable) Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public bool TryGetScalarVar(string dataPath, out ScalarDataVariable scalarVar) Parameters Type Name Description string dataPath ScalarDataVariable scalarVar Returns Type Description bool | Improve this Doc View Source TryGetVectorVar(string, out VectorDataVariable) Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. Declaration public bool TryGetVectorVar(string dataPath, out VectorDataVariable vectorVar) Parameters Type Name Description string dataPath VectorDataVariable vectorVar Returns Type Description bool"
  },
  "api/IVLab.ABREngine.Examples.CSVToPoints.html": {
    "href": "api/IVLab.ABREngine.Examples.CSVToPoints.html",
    "title": "Class CSVToPoints | ABREngine",
    "keywords": "Class CSVToPoints Inheritance object CSVToPoints Namespace: IVLab.ABREngine.Examples Assembly: Assembly-CSharp.dll Syntax public static class CSVToPoints Methods LoadFromCSV(string, CoordSystem) Import a series of 3D points from a CSV file. This method assumes that you have an \"x\", a \"y\", and a \"z\" as the header/first row of the CSV. Declaration public static List<Vector3> LoadFromCSV(string csvFilePath, CoordConversion.CoordSystem coordSystem) Parameters Type Name Description string csvFilePath CoordConversion.CoordSystem coordSystem Returns Type Description List<Vector3>"
  },
  "api/IVLab.ABREngine.Examples.CreateDataset.html": {
    "href": "api/IVLab.ABREngine.Examples.CreateDataset.html",
    "title": "Class CreateDataset | ABREngine",
    "keywords": "Class CreateDataset This example creates a simple cube dataset with one variable, loads it into ABR, and displays a single data impression with the cube. Attach this component to a GameObject to load the example dataset. This example assumes a blank ABR configuration. Inheritance object Object Component Behaviour MonoBehaviour CreateDataset Namespace: IVLab.ABREngine.Examples Assembly: Assembly-CSharp.dll Syntax public class CreateDataset : MonoBehaviour"
  },
  "api/IVLab.ABREngine.Examples.InteractiveState.html": {
    "href": "api/IVLab.ABREngine.Examples.InteractiveState.html",
    "title": "Class InteractiveState | ABREngine",
    "keywords": "Class InteractiveState In this example, we construct an ABR state from an example JSON file. Then, we interactively make modifications to the state, such as switching between colormaps and shrinking/growing the glyph size. This example assumes a blank ABR Configuration. This state assumes that the following VisAssets are available (which they should be, in Runtime/Resources/media/visassets): (colormap): 66b3cde4-034d-11eb-a7e6-005056bae6d8 (colormap): 5a761a72-8bcb-11ea-9265-005056bae6d8 (glyph): 1af025aa-f1ed-11e9-a623-8c85900fd4af Additionally, this will load a sample dataset from the ABREngine Resources folder: Demo/Wavelet/KeyData/Contour Demo/Wavelet/KeyData/Points Demo/Wavelet/ScalarVar/XAxis Demo/Wavelet/ScalarVar/YAxis Inheritance object Object Component Behaviour MonoBehaviour InteractiveState Namespace: IVLab.ABREngine.Examples Assembly: Assembly-CSharp.dll Syntax public class InteractiveState : MonoBehaviour"
  },
  "api/IVLab.ABREngine.Examples.MtStHelensData.html": {
    "href": "api/IVLab.ABREngine.Examples.MtStHelensData.html",
    "title": "Class MtStHelensData | ABREngine",
    "keywords": "Class MtStHelensData Inheritance object Object Component Behaviour MonoBehaviour MtStHelensData Namespace: IVLab.ABREngine.Examples Assembly: Assembly-CSharp.dll Syntax public class MtStHelensData : MonoBehaviour Fields afterFileName Declaration public string afterFileName Field Value Type Description string afterPointList Declaration [HideInInspector] public List<Vector3> afterPointList Field Value Type Description List<Vector3> beforeFileName Declaration public string beforeFileName Field Value Type Description string beforePointList Declaration [HideInInspector] public List<Vector3> beforePointList Field Value Type Description List<Vector3> differences Declaration [HideInInspector] public List<float> differences Field Value Type Description List<float> gridX Declaration public const int gridX = 240 Field Value Type Description int gridY Declaration public const int gridY = 346 Field Value Type Description int pointsBounds Declaration [HideInInspector] public Bounds pointsBounds Field Value Type Description Bounds Properties Loaded Declaration public bool Loaded { get; } Property Value Type Description bool"
  },
  "api/IVLab.ABREngine.Examples.MtStHelensVisDriver.html": {
    "href": "api/IVLab.ABREngine.Examples.MtStHelensVisDriver.html",
    "title": "Class MtStHelensVisDriver | ABREngine",
    "keywords": "Class MtStHelensVisDriver This sample contains examples of using more advanced parts of ABR, including: Using the RawDatasetAdapter to create ABR-compatible data from C# data structures Using DataImpressionGroups to control individual positioning of data in the scene Use of the PerIndexVisibility bit array Using VisAssetGradients in multivariate visualizations Data are sourced from the USGS. Inheritance object Object Component Behaviour MonoBehaviour MtStHelensVisDriver Namespace: IVLab.ABREngine.Examples Assembly: Assembly-CSharp.dll Syntax public class MtStHelensVisDriver : MonoBehaviour"
  },
  "api/IVLab.ABREngine.Examples.html": {
    "href": "api/IVLab.ABREngine.Examples.html",
    "title": "Namespace IVLab.ABREngine.Examples | ABREngine",
    "keywords": "Namespace IVLab.ABREngine.Examples Classes CSVToPoints CreateDataset This example creates a simple cube dataset with one variable, loads it into ABR, and displays a single data impression with the cube. Attach this component to a GameObject to load the example dataset. This example assumes a blank ABR configuration. InteractiveState In this example, we construct an ABR state from an example JSON file. Then, we interactively make modifications to the state, such as switching between colormaps and shrinking/growing the glyph size. This example assumes a blank ABR Configuration. This state assumes that the following VisAssets are available (which they should be, in Runtime/Resources/media/visassets): (colormap): 66b3cde4-034d-11eb-a7e6-005056bae6d8 (colormap): 5a761a72-8bcb-11ea-9265-005056bae6d8 (glyph): 1af025aa-f1ed-11e9-a623-8c85900fd4af Additionally, this will load a sample dataset from the ABREngine Resources folder: Demo/Wavelet/KeyData/Contour Demo/Wavelet/KeyData/Points Demo/Wavelet/ScalarVar/XAxis Demo/Wavelet/ScalarVar/YAxis MtStHelensData MtStHelensVisDriver This sample contains examples of using more advanced parts of ABR, including: Using the RawDatasetAdapter to create ABR-compatible data from C# data structures Using DataImpressionGroups to control individual positioning of data in the scene Use of the PerIndexVisibility bit array Using VisAssetGradients in multivariate visualizations Data are sourced from the USGS."
  },
  "api/IVLab.ABREngine.ExtensionMethods.DirectoryInfoExtensions.html": {
    "href": "api/IVLab.ABREngine.ExtensionMethods.DirectoryInfoExtensions.html",
    "title": "Class DirectoryInfoExtensions | ABREngine",
    "keywords": "Class DirectoryInfoExtensions Inheritance object DirectoryInfoExtensions Namespace: IVLab.ABREngine.ExtensionMethods Assembly: IVLab.ABREngine.Runtime.dll Syntax public static class DirectoryInfoExtensions Methods | Improve this Doc View Source CopyAll(DirectoryInfo, DirectoryInfo) Declaration public static void CopyAll(this DirectoryInfo source, DirectoryInfo target) Parameters Type Name Description DirectoryInfo source DirectoryInfo target"
  },
  "api/IVLab.ABREngine.ExtensionMethods.ScriptableObjectExtensions.html": {
    "href": "api/IVLab.ABREngine.ExtensionMethods.ScriptableObjectExtensions.html",
    "title": "Class ScriptableObjectExtensions | ABREngine",
    "keywords": "Class ScriptableObjectExtensions Inheritance object ScriptableObjectExtensions Namespace: IVLab.ABREngine.ExtensionMethods Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ScriptableObjectExtensions Methods | Improve this Doc View Source GetAllInstances<T>() Get all instances of scriptable objects with given type. Declaration public static List<T> GetAllInstances<T>() where T : ScriptableObject Returns Type Description List<T> Type Parameters Name Description T"
  },
  "api/IVLab.ABREngine.ExtensionMethods.html": {
    "href": "api/IVLab.ABREngine.ExtensionMethods.html",
    "title": "Namespace IVLab.ABREngine.ExtensionMethods | ABREngine",
    "keywords": "Namespace IVLab.ABREngine.ExtensionMethods Classes DirectoryInfoExtensions ScriptableObjectExtensions"
  },
  "api/IVLab.ABREngine.FilePathVisAssetFetcher.html": {
    "href": "api/IVLab.ABREngine.FilePathVisAssetFetcher.html",
    "title": "Class FilePathVisAssetFetcher | ABREngine",
    "keywords": "Class FilePathVisAssetFetcher Fetch VisAsset from somewhere on local disk Inheritance object FilePathVisAssetFetcher Implements IVisAssetFetcher Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class FilePathVisAssetFetcher : IVisAssetFetcher Constructors | Improve this Doc View Source FilePathVisAssetFetcher(string) Fetch VisAsset from somewhere on local disk Declaration public FilePathVisAssetFetcher(string appDataPath) Parameters Type Name Description string appDataPath Properties | Improve this Doc View Source VisAssetJson Fetch VisAsset from somewhere on local disk Declaration public string VisAssetJson { get; } Property Value Type Description string Methods | Improve this Doc View Source GetArtifactJson(Guid) Fetch VisAsset from somewhere on local disk Declaration public JObject GetArtifactJson(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description JObject | Improve this Doc View Source GetArtifactJsonPath(Guid) Fetch VisAsset from somewhere on local disk Declaration public string GetArtifactJsonPath(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description string | Improve this Doc View Source GetColormap(Guid) Fetch VisAsset from somewhere on local disk Declaration public Colormap GetColormap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Colormap | Improve this Doc View Source GetColormapTexture(Guid) Fetch VisAsset from somewhere on local disk Declaration public Texture2D GetColormapTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetGlyphGameObject(Guid, JObject) Fetch VisAsset from somewhere on local disk Declaration public GameObject GetGlyphGameObject(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description GameObject | Improve this Doc View Source GetGlyphNormalMapTexture(Guid, JObject) Fetch VisAsset from somewhere on local disk Declaration public Texture2D GetGlyphNormalMapTexture(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description Texture2D | Improve this Doc View Source GetGlyphPreview(Guid) Fetch VisAsset from somewhere on local disk Declaration public Texture2D GetGlyphPreview(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetLineTexture(Guid) Fetch VisAsset from somewhere on local disk Declaration public Texture2D GetLineTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceNormalMap(Guid) Fetch VisAsset from somewhere on local disk Declaration public Texture2D GetSurfaceNormalMap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceTexture(Guid) Fetch VisAsset from somewhere on local disk Declaration public Texture2D GetSurfaceTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D Implements IVisAssetFetcher"
  },
  "api/IVLab.ABREngine.FloatPrimitive.html": {
    "href": "api/IVLab.ABREngine.FloatPrimitive.html",
    "title": "Class FloatPrimitive | ABREngine",
    "keywords": "Class FloatPrimitive Inheritance object FloatPrimitive AnglePrimitive LengthPrimitive PercentPrimitive Implements IFloatPrimitive IPrimitive IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class FloatPrimitive : IFloatPrimitive, IPrimitive, IABRInput Constructors | Improve this Doc View Source FloatPrimitive() Declaration public FloatPrimitive() | Improve this Doc View Source FloatPrimitive(float) Declaration public FloatPrimitive(float value) Parameters Type Name Description float value | Improve this Doc View Source FloatPrimitive(string) Declaration public FloatPrimitive(string value) Parameters Type Name Description string value Properties | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre | Improve this Doc View Source ParsingRegex The regex to use to convert this from a string. Group named \"value\" should be the floating point number, group named \"units\" should be the units, if any. Declaration public virtual Regex ParsingRegex { get; } Property Value Type Description Regex | Improve this Doc View Source Units Declaration public virtual string Units { get; } Property Value Type Description string | Improve this Doc View Source Value Declaration public float Value { get; protected set; } Property Value Type Description float Methods | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput | Improve this Doc View Source SetFromString(string) Set the value of the primitive from a string (similar to using the string constructor) Declaration public virtual void SetFromString(string value) Parameters Type Name Description string value | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Implements IFloatPrimitive IPrimitive IABRInput"
  },
  "api/IVLab.ABREngine.GlyphGradient.html": {
    "href": "api/IVLab.ABREngine.GlyphGradient.html",
    "title": "Class GlyphGradient | ABREngine",
    "keywords": "Class GlyphGradient Inheritance object VisAsset VisAssetGradient GlyphGradient Implements IGlyphVisAsset IVisAssetGradient<GlyphVisAsset> IVisAsset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class GlyphGradient : VisAssetGradient, IGlyphVisAsset, IVisAssetGradient<GlyphVisAsset>, IVisAsset, IABRInput Properties | Improve this Doc View Source Stops List of gradient stops (length of VisAssets - 1) Declaration public List<float> Stops { get; } Property Value Type Description List<float> | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration public int VisAssetCount { get; } Property Value Type Description int | Improve this Doc View Source VisAssets List of all VisAssets inside this gradient Declaration public List<GlyphVisAsset> VisAssets { get; } Property Value Type Description List<GlyphVisAsset> Methods | Improve this Doc View Source GetMesh(int) Get the mesh at an LOD for a single glyph visasset Declaration public Mesh GetMesh(int lod) Parameters Type Name Description int lod Returns Type Description Mesh | Improve this Doc View Source GetMesh(int, int) Get the mesh at a particular index of the gradient Declaration public Mesh GetMesh(int gradientIndex, int lod) Parameters Type Name Description int gradientIndex int lod Returns Type Description Mesh | Improve this Doc View Source GetMesh(float, int) Get the mesh at a particular percentage (t-value) through the gradient Declaration public Mesh GetMesh(float gradientT, int lod) Parameters Type Name Description float gradientT int lod Returns Type Description Mesh | Improve this Doc View Source GetNormalMap(int) Get the normal map at an LOD for a single glyph visasset Declaration public Texture2D GetNormalMap(int lod) Parameters Type Name Description int lod Returns Type Description Texture2D | Improve this Doc View Source GetNormalMap(int, int) Get the normal map at a particular index of the gradient Declaration public Texture2D GetNormalMap(int gradientIndex, int lod) Parameters Type Name Description int gradientIndex int lod Returns Type Description Texture2D | Improve this Doc View Source GetNormalMap(float, int) Get the normal map at a particular percentage (t-value) through the gradient Declaration public Texture2D GetNormalMap(float gradientT, int lod) Parameters Type Name Description float gradientT int lod Returns Type Description Texture2D | Improve this Doc View Source GetPreview() Get a preview of the glyph as a Texture2D, if any Declaration public Texture2D GetPreview() Returns Type Description Texture2D | Improve this Doc View Source Initialize(Guid, List<GlyphVisAsset>, List<float>) Initialize this gradient with a UUID, some VisAssets, and some Stops. This is used instead of a constructor because it is much more flexible. Declaration public void Initialize(Guid uuid, List<GlyphVisAsset> visAssets, List<float> stops) Parameters Type Name Description Guid uuid List<GlyphVisAsset> visAssets List<float> stops Implements IGlyphVisAsset IVisAssetGradient<T> IVisAsset IABRInput"
  },
  "api/IVLab.ABREngine.GlyphVisAsset.html": {
    "href": "api/IVLab.ABREngine.GlyphVisAsset.html",
    "title": "Class GlyphVisAsset | ABREngine",
    "keywords": "Class GlyphVisAsset Inheritance object VisAsset GlyphVisAsset Implements IGlyphVisAsset IVisAsset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class GlyphVisAsset : VisAsset, IGlyphVisAsset, IVisAsset, IABRInput Constructors | Improve this Doc View Source GlyphVisAsset() Declaration public GlyphVisAsset() | Improve this Doc View Source GlyphVisAsset(List<Mesh>, List<Texture2D>) Declaration public GlyphVisAsset(List<Mesh> meshLods, List<Texture2D> normalMapLods) Parameters Type Name Description List<Mesh> meshLods List<Texture2D> normalMapLods | Improve this Doc View Source GlyphVisAsset(List<Mesh>, List<Texture2D>, Texture2D) Declaration public GlyphVisAsset(List<Mesh> meshLods, List<Texture2D> normalMapLods, Texture2D preview) Parameters Type Name Description List<Mesh> meshLods List<Texture2D> normalMapLods Texture2D preview | Improve this Doc View Source GlyphVisAsset(Guid, List<Mesh>, List<Texture2D>, Texture2D) Declaration public GlyphVisAsset(Guid uuid, List<Mesh> meshLods, List<Texture2D> normalMapLods, Texture2D preview) Parameters Type Name Description Guid uuid List<Mesh> meshLods List<Texture2D> normalMapLods Texture2D preview Properties | Improve this Doc View Source MeshLods Declaration public List<Mesh> MeshLods { get; } Property Value Type Description List<Mesh> | Improve this Doc View Source NormalMapLods Declaration public List<Texture2D> NormalMapLods { get; } Property Value Type Description List<Texture2D> | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration public int VisAssetCount { get; } Property Value Type Description int Methods | Improve this Doc View Source GetMesh(int) Get the mesh at an LOD for a single glyph visasset Declaration public Mesh GetMesh(int lod) Parameters Type Name Description int lod Returns Type Description Mesh | Improve this Doc View Source GetMesh(int, int) Get the mesh at a particular index of the gradient Declaration public Mesh GetMesh(int gradientIndex, int lod) Parameters Type Name Description int gradientIndex int lod Returns Type Description Mesh | Improve this Doc View Source GetMesh(float, int) Get the mesh at a particular percentage (t-value) through the gradient Declaration public Mesh GetMesh(float gradientT, int lod) Parameters Type Name Description float gradientT int lod Returns Type Description Mesh | Improve this Doc View Source GetNormalMap(int) Get the normal map at an LOD for a single glyph visasset Declaration public Texture2D GetNormalMap(int lod) Parameters Type Name Description int lod Returns Type Description Texture2D | Improve this Doc View Source GetNormalMap(int, int) Get the normal map at a particular index of the gradient Declaration public Texture2D GetNormalMap(int gradientIndex, int lod) Parameters Type Name Description int gradientIndex int lod Returns Type Description Texture2D | Improve this Doc View Source GetNormalMap(float, int) Get the normal map at a particular percentage (t-value) through the gradient Declaration public Texture2D GetNormalMap(float gradientT, int lod) Parameters Type Name Description float gradientT int lod Returns Type Description Texture2D | Improve this Doc View Source GetPreview() Get a preview of the glyph as a Texture2D, if any Declaration public Texture2D GetPreview() Returns Type Description Texture2D Implements IGlyphVisAsset IVisAsset IABRInput"
  },
  "api/IVLab.ABREngine.GradientBlendMap.html": {
    "href": "api/IVLab.ABREngine.GradientBlendMap.html",
    "title": "Class GradientBlendMap | ABREngine",
    "keywords": "Class GradientBlendMap Collection of essential textures for making texture-based VisAsset gradients happen. The blend maps are controlled via the BlendMaps and StopMaps texture arrays. Inheritance object GradientBlendMap Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class GradientBlendMap Constructors | Improve this Doc View Source GradientBlendMap(List<Texture2D>, List<float>, List<float>) Collection of essential textures for making texture-based VisAsset gradients happen. The blend maps are controlled via the BlendMaps and StopMaps texture arrays. Declaration public GradientBlendMap(List<Texture2D> textures, List<float> stops, List<float> blendWidths) Parameters Type Name Description List<Texture2D> textures List<float> stops List<float> blendWidths | Improve this Doc View Source GradientBlendMap(List<Texture2D>, List<float>, float) Collection of essential textures for making texture-based VisAsset gradients happen. The blend maps are controlled via the BlendMaps and StopMaps texture arrays. Declaration public GradientBlendMap(List<Texture2D> textures, List<float> stops, float blendWidth) Parameters Type Name Description List<Texture2D> textures List<float> stops float blendWidth | Improve this Doc View Source GradientBlendMap(Texture2D) Collection of essential textures for making texture-based VisAsset gradients happen. The blend maps are controlled via the BlendMaps and StopMaps texture arrays. Declaration public GradientBlendMap(Texture2D texture) Parameters Type Name Description Texture2D texture Fields | Improve this Doc View Source MaxSupportedTextures Maximum number of supported textures in a texture gradient Declaration public const int MaxSupportedTextures = 16 Field Value Type Description int Properties | Improve this Doc View Source AspectRatios Array of aspect ratios (width / height) of each texture Declaration public float[] AspectRatios { get; } Property Value Type Description float[] | Improve this Doc View Source BlendMaps Red/Green/Blue/Alpha texture that describes the blending between Stops. For a gradient with 3 elements, this texture will look red on the left, green in the middle, and blue on the right. For a gradient with 12 elements, this texture will have 3 rows with red, green, blue, and alpha. The transition blend is defined by blendWidth. For a gradient with 5 elements, the BlendMap looks something like this: Declaration public Texture2D BlendMaps { get; } Property Value Type Description Texture2D | Improve this Doc View Source HeightWidthAspectRatios Array of aspect ratios (height / width) of each texture Declaration public float[] HeightWidthAspectRatios { get; } Property Value Type Description float[] | Improve this Doc View Source StopMaps Red/green/blue/alpha texture that describes how far along in the current stop we are, matching up with BlendMap. For a gradient with 3 elements, this texture will look like 3 black-to-white colormaps smooshed together. For a gradient with 5 elements, the StopMap looks something like this: Declaration public Texture2D StopMaps { get; } Property Value Type Description Texture2D | Improve this Doc View Source Textures The actual combined texture that contains all visassets, stacked together vertically. For a gradient with 5 line texture elements, it might look something like this: Declaration public Texture2D Textures { get; } Property Value Type Description Texture2D"
  },
  "api/IVLab.ABREngine.HttpDataLoader.html": {
    "href": "api/IVLab.ABREngine.HttpDataLoader.html",
    "title": "Class HttpDataLoader | ABREngine",
    "keywords": "Class HttpDataLoader Load data from a remote source Inheritance object HttpDataLoader Implements IDataLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class HttpDataLoader : IDataLoader Methods | Improve this Doc View Source LoadData(string) Load data specified by dataPath from a particular source Declaration public RawDataset LoadData(string dataPath) Parameters Type Name Description string dataPath Returns Type Description RawDataset Implements IDataLoader"
  },
  "api/IVLab.ABREngine.HttpStateFileLoader.html": {
    "href": "api/IVLab.ABREngine.HttpStateFileLoader.html",
    "title": "Class HttpStateFileLoader | ABREngine",
    "keywords": "Class HttpStateFileLoader Save/Load a state from a web URL Inheritance object HttpStateFileLoader Implements IABRStateLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class HttpStateFileLoader : IABRStateLoader Constructors | Improve this Doc View Source HttpStateFileLoader() Save/Load a state from a web URL Declaration public HttpStateFileLoader() Methods | Improve this Doc View Source GetState(string) Load a state based on some text (perhaps a JSON string, a file path, or URL) Declaration public JObject GetState(string url) Parameters Type Name Description string url Returns Type Description JObject | Improve this Doc View Source SaveState(string, string) Save a serialized JSON state with a particular name Declaration public void SaveState(string name, string serializedState) Parameters Type Name Description string name string serializedState Implements IABRStateLoader"
  },
  "api/IVLab.ABREngine.HttpVisAssetFetcher.html": {
    "href": "api/IVLab.ABREngine.HttpVisAssetFetcher.html",
    "title": "Class HttpVisAssetFetcher | ABREngine",
    "keywords": "Class HttpVisAssetFetcher Fetch VisAssets from a URL via HTTP Inheritance object HttpVisAssetFetcher Implements IVisAssetFetcher Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class HttpVisAssetFetcher : IVisAssetFetcher Constructors | Improve this Doc View Source HttpVisAssetFetcher(string, string) Fetch VisAssets from a URL via HTTP Declaration public HttpVisAssetFetcher(string serverUrl, string appDataPath) Parameters Type Name Description string serverUrl string appDataPath Properties | Improve this Doc View Source VisAssetJson Fetch VisAssets from a URL via HTTP Declaration public string VisAssetJson { get; } Property Value Type Description string Methods | Improve this Doc View Source GetArtifactJson(Guid) Fetch VisAssets from a URL via HTTP Declaration public JObject GetArtifactJson(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description JObject | Improve this Doc View Source GetArtifactJsonPath(Guid) Fetch VisAssets from a URL via HTTP Declaration public string GetArtifactJsonPath(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description string | Improve this Doc View Source GetArtifactPath(Guid) Fetch VisAssets from a URL via HTTP Declaration public string GetArtifactPath(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description string | Improve this Doc View Source GetColormap(Guid) Fetch VisAssets from a URL via HTTP Declaration public Colormap GetColormap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Colormap | Improve this Doc View Source GetColormapTexture(Guid) Fetch VisAssets from a URL via HTTP Declaration public Texture2D GetColormapTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetGlyphGameObject(Guid, JObject) Fetch VisAssets from a URL via HTTP Declaration public GameObject GetGlyphGameObject(Guid uuid, JObject lodInfo) Parameters Type Name Description Guid uuid JObject lodInfo Returns Type Description GameObject | Improve this Doc View Source GetGlyphNormalMapTexture(Guid, JObject) Fetch VisAssets from a URL via HTTP Declaration public Texture2D GetGlyphNormalMapTexture(Guid uuid, JObject lodInfo) Parameters Type Name Description Guid uuid JObject lodInfo Returns Type Description Texture2D | Improve this Doc View Source GetGlyphPreview(Guid) Fetch VisAssets from a URL via HTTP Declaration public Texture2D GetGlyphPreview(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetLineTexture(Guid) Fetch VisAssets from a URL via HTTP Declaration public Texture2D GetLineTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetLocalArtifactJsonPath(Guid) Fetch VisAssets from a URL via HTTP Declaration public string GetLocalArtifactJsonPath(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description string | Improve this Doc View Source GetSurfaceNormalMap(Guid) Fetch VisAssets from a URL via HTTP Declaration public Texture2D GetSurfaceNormalMap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceTexture(Guid) Fetch VisAssets from a URL via HTTP Declaration public Texture2D GetSurfaceTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D Implements IVisAssetFetcher"
  },
  "api/IVLab.ABREngine.IABRInput.html": {
    "href": "api/IVLab.ABREngine.IABRInput.html",
    "title": "Interface IABRInput | ABREngine",
    "keywords": "Interface IABRInput Interface that includes every input to a data impression. Every type of ABR input should fit into a specific ABRInputGenre. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IABRInput Properties | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre Methods | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration RawABRInput GetRawABRInput() Returns Type Description RawABRInput"
  },
  "api/IVLab.ABREngine.IABRStateLoader.html": {
    "href": "api/IVLab.ABREngine.IABRStateLoader.html",
    "title": "Interface IABRStateLoader | ABREngine",
    "keywords": "Interface IABRStateLoader Generic state loader for ABR. Implementations should allow both retrieving a state (GetState) and saving a state (SaveState). Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IABRStateLoader Methods | Improve this Doc View Source GetState(string) Load a state based on some text (perhaps a JSON string, a file path, or URL) Declaration JObject GetState(string stateText) Parameters Type Name Description string stateText Returns Type Description JObject | Improve this Doc View Source SaveState(string, string) Save a serialized JSON state with a particular name Declaration void SaveState(string name, string serializedState) Parameters Type Name Description string name string serializedState"
  },
  "api/IVLab.ABREngine.IColormapVisAsset.html": {
    "href": "api/IVLab.ABREngine.IColormapVisAsset.html",
    "title": "Interface IColormapVisAsset | ABREngine",
    "keywords": "Interface IColormapVisAsset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IColormapVisAsset : IVisAsset, IABRInput Methods | Improve this Doc View Source GetColorGradient() Declaration Texture2D GetColorGradient() Returns Type Description Texture2D"
  },
  "api/IVLab.ABREngine.ICoordSpaceConverter.html": {
    "href": "api/IVLab.ABREngine.ICoordSpaceConverter.html",
    "title": "Interface ICoordSpaceConverter | ABREngine",
    "keywords": "Interface ICoordSpaceConverter Interface to implement for helpers to convert between Data Space and Unity's World Space. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface ICoordSpaceConverter Properties | Improve this Doc View Source BoundsInDataSpace Returns the spatial bounding box of the data in the original coordinate system of the data. Data Space coordinates are typically based upon real world units, like meters. Declaration Bounds BoundsInDataSpace { get; } Property Value Type Description Bounds | Improve this Doc View Source BoundsInWorldSpace Returns the spatial bounding box of the data in Unity's world space. Declaration Bounds BoundsInWorldSpace { get; } Property Value Type Description Bounds | Improve this Doc View Source DataToWorldMatrix Transformation matrix from data space to world space. Declaration Matrix4x4 DataToWorldMatrix { get; } Property Value Type Description Matrix4x4 | Improve this Doc View Source WorldToDataMatrix Transformation matrix from world space to data space. Declaration Matrix4x4 WorldToDataMatrix { get; } Property Value Type Description Matrix4x4 Methods | Improve this Doc View Source ContainsDataSpacePoint(Vector3) Returns true if the point in data coordinates lies within the volume. Data coordinates are typically defined in real-world units, like meters. Declaration bool ContainsDataSpacePoint(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description bool | Improve this Doc View Source ContainsWorldSpacePoint(Vector3) Returns true if the point in Unity World coordinates lies within the bounds of the data. Declaration bool ContainsWorldSpacePoint(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description bool | Improve this Doc View Source DataSpacePointToWorldSpace(Vector3) Converts a point in the original data coordinate space, which is typically defined in real-world units, like meters, to its current position in Unity's World coordinate system, which might include a scale or translation or other transformation based on how the visualization is designed. Declaration Vector3 DataSpacePointToWorldSpace(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description Vector3 | Improve this Doc View Source DataSpaceVectorToWorldSpace(Vector3) Converts a Vector in the original data coordinate space, which is typically defined in real-world units, like meters, to its current position in Unity's World coordinate system, which might include a scale or translation or other transformation based on how the visualization is designed. Declaration Vector3 DataSpaceVectorToWorldSpace(Vector3 dataSpaceVector) Parameters Type Name Description Vector3 dataSpaceVector Returns Type Description Vector3 | Improve this Doc View Source WorldSpacePointToDataSpace(Vector3) Converts a point in Unity world coordinates to a point within the original data coordinate space. The data coordinate space is typically defined in real-world units, like cm or meters. Those coordinates are often scaled or repositioned within Unity World space as we zoom into the data or place multiple datasets side-by-side or do other visualization tasks. Declaration Vector3 WorldSpacePointToDataSpace(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description Vector3 | Improve this Doc View Source WorldSpaceVectorToDataSpace(Vector3) Converts a vector in Unity world coordinates to a vector within the original data coordinate space. The data coordinate space is typically defined in real-world units, like cm or meters. Those coordinates are often scaled or repositioned within Unity World space as we zoom into the data or place multiple datasets side-by-side or do other visualization tasks. Declaration Vector3 WorldSpaceVectorToDataSpace(Vector3 worldSpaceVector) Parameters Type Name Description Vector3 worldSpaceVector Returns Type Description Vector3"
  },
  "api/IVLab.ABREngine.IDataAccessor.html": {
    "href": "api/IVLab.ABREngine.IDataAccessor.html",
    "title": "Interface IDataAccessor | ABREngine",
    "keywords": "Interface IDataAccessor Interface to implement to share easier access to data within ABR. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IDataAccessor Methods | Improve this Doc View Source GetClosestDataInDataSpace(Vector3) Finds the closest data to the given point, in data space. Declaration DataPoint GetClosestDataInDataSpace(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description DataPoint A DataPoint with the closest data to a given point | Improve this Doc View Source GetClosestDataInWorldSpace(Vector3) Finds the closest data to the given point, in world space. Declaration DataPoint GetClosestDataInWorldSpace(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description DataPoint A DataPoint with the closest data to a given point | Improve this Doc View Source GetNearbyDataInDataSpace(Vector3, float) Finds the data within a certain radius of the given point, in data space. Declaration List<DataPoint> GetNearbyDataInDataSpace(Vector3 dataSpacePoint, float radiusInDataSpace) Parameters Type Name Description Vector3 dataSpacePoint float radiusInDataSpace Returns Type Description List<DataPoint> A list of DataPoint within a given radius of a given point | Improve this Doc View Source GetNearbyDataInWorldSpace(Vector3, float) Finds the data within a certain radius of the given point, in world space. Declaration List<DataPoint> GetNearbyDataInWorldSpace(Vector3 worldSpacePoint, float radiusInWorldSpace) Parameters Type Name Description Vector3 worldSpacePoint float radiusInWorldSpace Returns Type Description List<DataPoint> A list of DataPoint within a given radius of a given point | Improve this Doc View Source GetScalarValueAtClosestDataSpacePoint(Vector3, ScalarDataVariable, KeyData) Get a scalar value from a particular data variable at the closest point in data space. If keyData is null, this method will look at every key data object that has the given variable. Declaration float GetScalarValueAtClosestDataSpacePoint(Vector3 point, ScalarDataVariable variable, KeyData keyData = null) Parameters Type Name Description Vector3 point ScalarDataVariable variable KeyData keyData Returns Type Description float | Improve this Doc View Source GetScalarValueAtClosestDataSpacePoint(Vector3, string, KeyData) Interface to implement to share easier access to data within ABR. Declaration float GetScalarValueAtClosestDataSpacePoint(Vector3 point, string variableName, KeyData keyData = null) Parameters Type Name Description Vector3 point string variableName KeyData keyData Returns Type Description float | Improve this Doc View Source GetScalarValueAtClosestWorldSpacePoint(Vector3, ScalarDataVariable, KeyData) Get a scalar value from a particular data variable at the closest point in world space. If keyData is null, this method will look at every key data object that has the given variable. Declaration float GetScalarValueAtClosestWorldSpacePoint(Vector3 point, ScalarDataVariable variable, KeyData keyData = null) Parameters Type Name Description Vector3 point ScalarDataVariable variable KeyData keyData Returns Type Description float | Improve this Doc View Source GetScalarValueAtClosestWorldSpacePoint(Vector3, string, KeyData) Interface to implement to share easier access to data within ABR. Declaration float GetScalarValueAtClosestWorldSpacePoint(Vector3 point, string variableName, KeyData keyData = null) Parameters Type Name Description Vector3 point string variableName KeyData keyData Returns Type Description float | Improve this Doc View Source GetVectorValueAtClosestDataSpacePoint(Vector3, VectorDataVariable, KeyData) Get a vector value from a particular data variable at the closest point in data space. If keyData is null, this method will look at every key data object that has the given variable. Declaration Vector3 GetVectorValueAtClosestDataSpacePoint(Vector3 point, VectorDataVariable variable, KeyData keyData = null) Parameters Type Name Description Vector3 point VectorDataVariable variable KeyData keyData Returns Type Description Vector3 | Improve this Doc View Source GetVectorValueAtClosestDataSpacePoint(Vector3, string, KeyData) Interface to implement to share easier access to data within ABR. Declaration Vector3 GetVectorValueAtClosestDataSpacePoint(Vector3 point, string variableName, KeyData keyData = null) Parameters Type Name Description Vector3 point string variableName KeyData keyData Returns Type Description Vector3 | Improve this Doc View Source GetVectorValueAtClosestWorldSpacePoint(Vector3, VectorDataVariable, KeyData) Get a vector value from a particular data variable at the closest point in data space. If keyData is null, this method will look at every key data object that has the given variable. Declaration Vector3 GetVectorValueAtClosestWorldSpacePoint(Vector3 point, VectorDataVariable variable, KeyData keyData = null) Parameters Type Name Description Vector3 point VectorDataVariable variable KeyData keyData Returns Type Description Vector3 | Improve this Doc View Source GetVectorValueAtClosestWorldSpacePoint(Vector3, string, KeyData) Interface to implement to share easier access to data within ABR. Declaration Vector3 GetVectorValueAtClosestWorldSpacePoint(Vector3 point, string variableName, KeyData keyData = null) Parameters Type Name Description Vector3 point string variableName KeyData keyData Returns Type Description Vector3 | Improve this Doc View Source NormalizeScalarValue(float, KeyData, ScalarDataVariable) Normalize a data value from 0 to 1 based on the given key data with a scalar data variable Declaration float NormalizeScalarValue(float value, KeyData keyData, ScalarDataVariable variable) Parameters Type Name Description float value KeyData keyData ScalarDataVariable variable Returns Type Description float"
  },
  "api/IVLab.ABREngine.IDataImpressionRenderInfo.html": {
    "href": "api/IVLab.ABREngine.IDataImpressionRenderInfo.html",
    "title": "Interface IDataImpressionRenderInfo | ABREngine",
    "keywords": "Interface IDataImpressionRenderInfo Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IDataImpressionRenderInfo"
  },
  "api/IVLab.ABREngine.IDataLoader.html": {
    "href": "api/IVLab.ABREngine.IDataLoader.html",
    "title": "Interface IDataLoader | ABREngine",
    "keywords": "Interface IDataLoader Generic interface to fetch a RawDataset from somewhere Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IDataLoader Methods | Improve this Doc View Source LoadData(string) Load data specified by dataPath from a particular source Declaration RawDataset LoadData(string dataPath) Parameters Type Name Description string dataPath Returns Type Description RawDataset"
  },
  "api/IVLab.ABREngine.IDataVariable-1.html": {
    "href": "api/IVLab.ABREngine.IDataVariable-1.html",
    "title": "Interface IDataVariable<T> | ABREngine",
    "keywords": "Interface IDataVariable<T> Lightweight / high level container for a data variable. Variables keep track of their ranges and path, but the actual Data Arrays are preserved within the original RawDataset. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IDataVariable<T> : IHasDataset, IABRInput Type Parameters Name Description T Properties | Improve this Doc View Source CustomizedRange Have this var's ranges been customized? Declaration bool CustomizedRange { get; set; } Property Value Type Description bool | Improve this Doc View Source OriginalRange Save the original range in case the user wants to reset it later. Declaration DataRange<T> OriginalRange { get; set; } Property Value Type Description DataRange<T> | Improve this Doc View Source Path The DataPath that represents this variable Declaration string Path { get; } Property Value Type Description string | Improve this Doc View Source Range Range is calculated by the DataManager when it imports a new dataset. Range is calculated from the smallest/largest values encountered across every instance of this variable, across all datasets. Declaration DataRange<T> Range { get; set; } Property Value Type Description DataRange<T> | Improve this Doc View Source SpecificRanges Dictionary of keyData paths that have specific ranges for this variable Declaration Dictionary<string, DataRange<T>> SpecificRanges { get; set; } Property Value Type Description Dictionary<string, DataRange<T>> Methods | Improve this Doc View Source GetArray(KeyData) Get the actual data values in the context of this particular Key Data object Declaration T[] GetArray(KeyData keyData) Parameters Type Name Description KeyData keyData Returns Type Description T[] | Improve this Doc View Source IsPartOf(KeyData) Determine if this variable is a part of the key data Declaration bool IsPartOf(KeyData keyData) Parameters Type Name Description KeyData keyData Returns Type Description bool"
  },
  "api/IVLab.ABREngine.IFloatPrimitive.html": {
    "href": "api/IVLab.ABREngine.IFloatPrimitive.html",
    "title": "Interface IFloatPrimitive | ABREngine",
    "keywords": "Interface IFloatPrimitive Represents a numeric primitive value (e.g. 10deg, 96cm, or 4.6) Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IFloatPrimitive : IPrimitive, IABRInput Properties | Improve this Doc View Source Units Represents a numeric primitive value (e.g. 10deg, 96cm, or 4.6) Declaration string Units { get; } Property Value Type Description string | Improve this Doc View Source Value Represents a numeric primitive value (e.g. 10deg, 96cm, or 4.6) Declaration float Value { get; } Property Value Type Description float"
  },
  "api/IVLab.ABREngine.IGlyphVisAsset.html": {
    "href": "api/IVLab.ABREngine.IGlyphVisAsset.html",
    "title": "Interface IGlyphVisAsset | ABREngine",
    "keywords": "Interface IGlyphVisAsset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IGlyphVisAsset : IVisAsset, IABRInput Methods | Improve this Doc View Source GetMesh(int) Get the mesh at an LOD for a single glyph visasset Declaration Mesh GetMesh(int lod) Parameters Type Name Description int lod Returns Type Description Mesh | Improve this Doc View Source GetMesh(int, int) Get the mesh at a particular index of the gradient Declaration Mesh GetMesh(int gradientIndex, int lod) Parameters Type Name Description int gradientIndex int lod Returns Type Description Mesh | Improve this Doc View Source GetMesh(float, int) Get the mesh at a particular percentage (t-value) through the gradient Declaration Mesh GetMesh(float gradientT, int lod) Parameters Type Name Description float gradientT int lod Returns Type Description Mesh | Improve this Doc View Source GetNormalMap(int) Get the normal map at an LOD for a single glyph visasset Declaration Texture2D GetNormalMap(int lod) Parameters Type Name Description int lod Returns Type Description Texture2D | Improve this Doc View Source GetNormalMap(int, int) Get the normal map at a particular index of the gradient Declaration Texture2D GetNormalMap(int gradientIndex, int lod) Parameters Type Name Description int gradientIndex int lod Returns Type Description Texture2D | Improve this Doc View Source GetNormalMap(float, int) Get the normal map at a particular percentage (t-value) through the gradient Declaration Texture2D GetNormalMap(float gradientT, int lod) Parameters Type Name Description float gradientT int lod Returns Type Description Texture2D | Improve this Doc View Source GetPreview() Get a preview of the glyph as a Texture2D, if any Declaration Texture2D GetPreview() Returns Type Description Texture2D"
  },
  "api/IVLab.ABREngine.IHasDataset.html": {
    "href": "api/IVLab.ABREngine.IHasDataset.html",
    "title": "Interface IHasDataset | ABREngine",
    "keywords": "Interface IHasDataset Should be assigned to anything that is associated with a dataset (e.g. KeyData, Variables, and even DataImpressions once they have valid KeyData) Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IHasDataset Methods | Improve this Doc View Source GetDataset() Should be assigned to anything that is associated with a dataset (e.g. KeyData, Variables, and even DataImpressions once they have valid KeyData) Declaration Dataset GetDataset() Returns Type Description Dataset"
  },
  "api/IVLab.ABREngine.IHasKeyData.html": {
    "href": "api/IVLab.ABREngine.IHasKeyData.html",
    "title": "Interface IHasKeyData | ABREngine",
    "keywords": "Interface IHasKeyData Indicator that a particular object has some key data attached to it - useful for most DataImpressions. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IHasKeyData Methods | Improve this Doc View Source GetKeyData() Get any key data object associated with this object Declaration KeyData GetKeyData() Returns Type Description KeyData | Improve this Doc View Source GetKeyDataTopology() Get the KeyData's expected topology Declaration DataTopology GetKeyDataTopology() Returns Type Description DataTopology | Improve this Doc View Source SetKeyData(KeyData) Set the Key Data for this object Declaration void SetKeyData(KeyData kd) Parameters Type Name Description KeyData kd"
  },
  "api/IVLab.ABREngine.IIntegerPrimitive.html": {
    "href": "api/IVLab.ABREngine.IIntegerPrimitive.html",
    "title": "Interface IIntegerPrimitive | ABREngine",
    "keywords": "Interface IIntegerPrimitive Represents an integer primitive value Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IIntegerPrimitive : IPrimitive, IABRInput Properties | Improve this Doc View Source Units Represents an integer primitive value Declaration string Units { get; } Property Value Type Description string | Improve this Doc View Source Value Represents an integer primitive value Declaration int Value { get; } Property Value Type Description int"
  },
  "api/IVLab.ABREngine.IKeyDataRenderInfo.html": {
    "href": "api/IVLab.ABREngine.IKeyDataRenderInfo.html",
    "title": "Interface IKeyDataRenderInfo | ABREngine",
    "keywords": "Interface IKeyDataRenderInfo Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IKeyDataRenderInfo"
  },
  "api/IVLab.ABREngine.ILineTextureVisAsset.html": {
    "href": "api/IVLab.ABREngine.ILineTextureVisAsset.html",
    "title": "Interface ILineTextureVisAsset | ABREngine",
    "keywords": "Interface ILineTextureVisAsset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface ILineTextureVisAsset : IVisAsset, IABRInput, ITextureGradient Methods | Improve this Doc View Source GetTexture() Obtain the first (or, only) texture in a multi-visasset gradient Declaration Texture2D GetTexture() Returns Type Description Texture2D | Improve this Doc View Source GetTexture(int) Obtain the texture at a specific index within a multi-visasset gradient Declaration Texture2D GetTexture(int gradientIndex) Parameters Type Name Description int gradientIndex Returns Type Description Texture2D | Improve this Doc View Source GetTexture(float) Obtain the texture at a specific t-value (percentage) within a multi-visasset gradient Declaration Texture2D GetTexture(float gradientT) Parameters Type Name Description float gradientT Returns Type Description Texture2D"
  },
  "api/IVLab.ABREngine.IPrimitive.html": {
    "href": "api/IVLab.ABREngine.IPrimitive.html",
    "title": "Interface IPrimitive | ABREngine",
    "keywords": "Interface IPrimitive Representative of a primitive element (usually used in ABR Inputs). These should match the primitive input types in the schema. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IPrimitive : IABRInput Properties | Improve this Doc View Source ParsingRegex The regex to use to convert this from a string. Group named \"value\" should be the floating point number, group named \"units\" should be the units, if any. Declaration Regex ParsingRegex { get; } Property Value Type Description Regex Methods | Improve this Doc View Source SetFromString(string) Set the value of the primitive from a string (similar to using the string constructor) Declaration void SetFromString(string value) Parameters Type Name Description string value | Improve this Doc View Source ToString() Convert the primitive to a string so it can be sent along with the state Declaration string ToString() Returns Type Description string"
  },
  "api/IVLab.ABREngine.IPrimitiveGradient.html": {
    "href": "api/IVLab.ABREngine.IPrimitiveGradient.html",
    "title": "Interface IPrimitiveGradient | ABREngine",
    "keywords": "Interface IPrimitiveGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IPrimitiveGradient : IABRInput Properties | Improve this Doc View Source InputValue Declaration Guid InputValue { get; } Property Value Type Description Guid | Improve this Doc View Source Points Declaration float[] Points { get; } Property Value Type Description float[] | Improve this Doc View Source Values Declaration string[] Values { get; } Property Value Type Description string[]"
  },
  "api/IVLab.ABREngine.ISurfaceTextureVisAsset.html": {
    "href": "api/IVLab.ABREngine.ISurfaceTextureVisAsset.html",
    "title": "Interface ISurfaceTextureVisAsset | ABREngine",
    "keywords": "Interface ISurfaceTextureVisAsset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface ISurfaceTextureVisAsset : IVisAsset, IABRInput, ITextureGradient Methods | Improve this Doc View Source GetTexture() Obtain the first (or, only) texture in a multi-visasset gradient Declaration Texture2D GetTexture() Returns Type Description Texture2D | Improve this Doc View Source GetTexture(int) Obtain the texture at a specific index within a multi-visasset gradient Declaration Texture2D GetTexture(int gradientIndex) Parameters Type Name Description int gradientIndex Returns Type Description Texture2D | Improve this Doc View Source GetTexture(float) Obtain the texture at a specific t-value (percentage) within a multi-visasset gradient Declaration Texture2D GetTexture(float gradientT) Parameters Type Name Description float gradientT Returns Type Description Texture2D"
  },
  "api/IVLab.ABREngine.ITextureGradient.html": {
    "href": "api/IVLab.ABREngine.ITextureGradient.html",
    "title": "Interface ITextureGradient | ABREngine",
    "keywords": "Interface ITextureGradient A VisAsset gradient described by a texture (or, series of textures) Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface ITextureGradient Properties | Improve this Doc View Source BlendMaps Internal calculations for blend maps used for rendering Declaration GradientBlendMap BlendMaps { get; } Property Value Type Description GradientBlendMap"
  },
  "api/IVLab.ABREngine.IVisAsset.html": {
    "href": "api/IVLab.ABREngine.IVisAsset.html",
    "title": "Interface IVisAsset | ABREngine",
    "keywords": "Interface IVisAsset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IVisAsset : IABRInput Properties | Improve this Doc View Source ImportTime (currently unused) The time that this VisAsset was imported into ABR Declaration DateTime ImportTime { get; set; } Property Value Type Description DateTime | Improve this Doc View Source Uuid Globally-unique identifier for this VisAsset Declaration Guid Uuid { get; set; } Property Value Type Description Guid | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration int VisAssetCount { get; } Property Value Type Description int"
  },
  "api/IVLab.ABREngine.IVisAssetFetcher.html": {
    "href": "api/IVLab.ABREngine.IVisAssetFetcher.html",
    "title": "Interface IVisAssetFetcher | ABREngine",
    "keywords": "Interface IVisAssetFetcher Generic fetcher that supports fetching all types of VisAssets from a particular source. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IVisAssetFetcher Methods | Improve this Doc View Source GetArtifactJson(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration JObject GetArtifactJson(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description JObject | Improve this Doc View Source GetArtifactJsonPath(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration string GetArtifactJsonPath(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description string | Improve this Doc View Source GetColormap(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration Colormap GetColormap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Colormap | Improve this Doc View Source GetColormapTexture(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration [Obsolete(\"GetColormapTexture() is obsolete; use GetColormap() instead\")] Texture2D GetColormapTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetGlyphGameObject(Guid, JObject) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration GameObject GetGlyphGameObject(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description GameObject | Improve this Doc View Source GetGlyphNormalMapTexture(Guid, JObject) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration Texture2D GetGlyphNormalMapTexture(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description Texture2D | Improve this Doc View Source GetGlyphPreview(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration Texture2D GetGlyphPreview(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetLineTexture(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration Texture2D GetLineTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceNormalMap(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration Texture2D GetSurfaceNormalMap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceTexture(Guid) Generic fetcher that supports fetching all types of VisAssets from a particular source. Declaration Texture2D GetSurfaceTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D"
  },
  "api/IVLab.ABREngine.IVisAssetGradient-1.html": {
    "href": "api/IVLab.ABREngine.IVisAssetGradient-1.html",
    "title": "Interface IVisAssetGradient<T> | ABREngine",
    "keywords": "Interface IVisAssetGradient<T> A gradient consisting of VisAssets of any type. NOTE: Texture-based gradients (Surface/Line textures and colormaps) must have 4 or fewer elements. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IVisAssetGradient<T> : IVisAsset, IABRInput where T : IVisAsset Type Parameters Name Description T Properties | Improve this Doc View Source Stops List of gradient stops (length of VisAssets - 1) Declaration List<float> Stops { get; } Property Value Type Description List<float> | Improve this Doc View Source VisAssets List of all VisAssets inside this gradient Declaration List<T> VisAssets { get; } Property Value Type Description List<T> Methods | Improve this Doc View Source Initialize(Guid, List<T>, List<float>) Initialize this gradient with a UUID, some VisAssets, and some Stops. This is used instead of a constructor because it is much more flexible. Declaration void Initialize(Guid uuid, List<T> visAssets, List<float> stops) Parameters Type Name Description Guid uuid List<T> visAssets List<float> stops"
  },
  "api/IVLab.ABREngine.IVolumeCoordSpaceConverter.html": {
    "href": "api/IVLab.ABREngine.IVolumeCoordSpaceConverter.html",
    "title": "Interface IVolumeCoordSpaceConverter | ABREngine",
    "keywords": "Interface IVolumeCoordSpaceConverter Interface to implement for helpers to convert between Data Space and Unity's World Space. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IVolumeCoordSpaceConverter Properties | Improve this Doc View Source VolumeDimensions The x,y,z dimensions of the raw voxel data (i.e., the number of voxels in each direction) -- read only. Declaration Vector3Int VolumeDimensions { get; } Property Value Type Description Vector3Int Methods | Improve this Doc View Source ContainsVoxelSpacePoint(Vector3) Returns true if the point in voxel space lies within the volume. Since voxel space is defined in units of voxels, this simply checks to see if the point lies within the dimensions of the volume. Declaration bool ContainsVoxelSpacePoint(Vector3 voxelSpacePoint) Parameters Type Name Description Vector3 voxelSpacePoint Returns Type Description bool | Improve this Doc View Source DataSpacePointToVoxelSpace(Vector3) Converts a point in the original data coordinate space, which is typically defined in real-world units, like meters, to a point within the voxel coordinate space. The voxel space is defined in units of voxels, but the coordinates can be fractional so we can represent a point within a voxel, not just at the center of each voxel. Declaration Vector3 DataSpacePointToVoxelSpace(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description Vector3 | Improve this Doc View Source VoxelSpacePointToDataSpace(Vector3) Converts a point in voxel space to the data coordinate space. Typically this transforms the voxels, which are like pixels in an image, into a real-world coordinate space like meters. Declaration Vector3 VoxelSpacePointToDataSpace(Vector3 voxelSpacePoint) Parameters Type Name Description Vector3 voxelSpacePoint Returns Type Description Vector3 | Improve this Doc View Source VoxelSpacePointToWorldSpace(Vector3) Converts a point in voxel space (can include fractions) to the point's current position in Unity's World coordinate system. Declaration Vector3 VoxelSpacePointToWorldSpace(Vector3 voxelSpacePoint) Parameters Type Name Description Vector3 voxelSpacePoint Returns Type Description Vector3 | Improve this Doc View Source WorldSpacePointToVoxelSpace(Vector3) Converts a point in Unity world coordinates to a point within the data coordinate space and then to a corresponding point in voxel coordinate space. The voxel space is defined in units of voxels, but the coordinates can be fractional so we can represent a point within a voxel, not just at the center of each voxel. Declaration Vector3 WorldSpacePointToVoxelSpace(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description Vector3"
  },
  "api/IVLab.ABREngine.IVolumeDataAccessor.html": {
    "href": "api/IVLab.ABREngine.IVolumeDataAccessor.html",
    "title": "Interface IVolumeDataAccessor | ABREngine",
    "keywords": "Interface IVolumeDataAccessor Interface to implement to share easier access to volume data within ABR. Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public interface IVolumeDataAccessor Methods | Improve this Doc View Source GetScalarValueAtDataSpacePoint(Vector3) Looks up the value in the original voxel data based upon a position specified in data space coordinates (i.e., real-world units). Declaration float GetScalarValueAtDataSpacePoint(Vector3 dataSpacePoint) Parameters Type Name Description Vector3 dataSpacePoint Returns Type Description float | Improve this Doc View Source GetScalarValueAtNearestVoxel(Vector3Int) Looks up the value in the original voxel data based upon a point in voxel space. This function does not use interpolation. It simply returns that data value stored for the center point of the closest voxel. Declaration float GetScalarValueAtNearestVoxel(Vector3Int voxelCoords) Parameters Type Name Description Vector3Int voxelCoords Returns Type Description float | Improve this Doc View Source GetScalarValueAtVoxelSpacePoint(Vector3) Looks up the value in the original voxel data based upon a point in voxel space. In the raw volume data each voxel contains one data value. If we think of those being the values of the data at a point right in the center of each voxel, then the point we are querying will rarely align perfectly with those center points; rather, it will fall somewhere between them. That is why the pointInVoxelSpace is allowed to include a fractional component. This function uses the fractional portion to perform a tri-linear interpolation of the data from the eight surrounding voxels to estimate the data value at the exact 3D location requested. See also GetValueAtNearestVoxel(), which is faster but less precise because it does not use interpolation. Or, GetValueAtVoxel(), which is even faster but does not support fractional voxel coordinates. Declaration float GetScalarValueAtVoxelSpacePoint(Vector3 voxelSpacePoint) Parameters Type Name Description Vector3 voxelSpacePoint Returns Type Description float | Improve this Doc View Source GetScalarValueAtWorldSpacePoint(Vector3) Looks up the value in the original voxel data based upon a position specified in Unity World coordinates. Declaration float GetScalarValueAtWorldSpacePoint(Vector3 worldSpacePoint) Parameters Type Name Description Vector3 worldSpacePoint Returns Type Description float | Improve this Doc View Source NormalizeScalarValue(float, KeyData) Uses the min and max values in the volume data to remap a data value to a normalized range between 0 and 1. Declaration float NormalizeScalarValue(float value, KeyData keyData) Parameters Type Name Description float value KeyData keyData Returns Type Description float"
  },
  "api/IVLab.ABREngine.InstancedMeshRenderer.html": {
    "href": "api/IVLab.ABREngine.InstancedMeshRenderer.html",
    "title": "Class InstancedMeshRenderer | ABREngine",
    "keywords": "Class InstancedMeshRenderer Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Inheritance object Object Component Behaviour MonoBehaviour InstancedMeshRenderer Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class InstancedMeshRenderer : MonoBehaviour Fields | Improve this Doc View Source block Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public MaterialPropertyBlock block Field Value Type Description MaterialPropertyBlock | Improve this Doc View Source bounds Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public Bounds bounds Field Value Type Description Bounds | Improve this Doc View Source cachedInstanceCount Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public int cachedInstanceCount Field Value Type Description int | Improve this Doc View Source instanceCount Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public int instanceCount Field Value Type Description int | Improve this Doc View Source instanceDensity Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public float instanceDensity Field Value Type Description float | Improve this Doc View Source instanceLocalTransforms Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public Matrix4x4[] instanceLocalTransforms Field Value Type Description Matrix4x4[] | Improve this Doc View Source instanceMaterial Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public Material instanceMaterial Field Value Type Description Material | Improve this Doc View Source instanceMesh Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public Mesh instanceMesh Field Value Type Description Mesh | Improve this Doc View Source renderInfo Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public Vector4[] renderInfo Field Value Type Description Vector4[] | Improve this Doc View Source subMeshIndex Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public int subMeshIndex Field Value Type Description int | Improve this Doc View Source useInstanced Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. Declaration public bool useInstanced Field Value Type Description bool"
  },
  "api/IVLab.ABREngine.InstancedSurfaceDataImpression.html": {
    "href": "api/IVLab.ABREngine.InstancedSurfaceDataImpression.html",
    "title": "Class InstancedSurfaceDataImpression | ABREngine",
    "keywords": "Class InstancedSurfaceDataImpression An Instanced Surface data impression (very similar to glyphs, except geometries are specified from data rather than VisAssets) Note This data impression type is not supported by the ABR design interface, hence the lack of ABRInputAttribute annotations for its instance variables. Inheritance object Object Component Behaviour MonoBehaviour DataImpression InstancedSurfaceDataImpression Implements IHasDataset IHasKeyData ICoordSpaceConverter Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [ABRPlateType(\"Instanced Surface\")] public class InstancedSurfaceDataImpression : DataImpression, IHasDataset, IHasKeyData, ICoordSpaceConverter Constructors | Improve this Doc View Source InstancedSurfaceDataImpression() An Instanced Surface data impression (very similar to glyphs, except geometries are specified from data rather than VisAssets) Note This data impression type is not supported by the ABR design interface, hence the lack of ABRInputAttribute annotations for its instance variables. Declaration protected InstancedSurfaceDataImpression() Fields | Improve this Doc View Source LayerName Define the layer name for this Data Impression Declaration protected const string LayerName = \"ABR_Glyph\" Field Value Type Description string Remarks Warning New Data Impressions should define a const string \"LayerName\" which corresponds to a Layer in Unity's Layer manager. | Improve this Doc View Source colorVariable Scalar color variable applied to each point of this data impression. This example switches between X-axis monotonically increasing and Y-axis monotonically increasing. Declaration [ABRInput(\"Color Variable\", UpdateLevel.Style)] public ScalarDataVariable colorVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source colormap Colormap applied to the colorVariable. This example switches between a linear white-to-green colormap and a linear black-to-white colormap. Declaration [ABRInput(\"Colormap\", UpdateLevel.Style)] public IColormapVisAsset colormap Field Value Type Description IColormapVisAsset | Improve this Doc View Source forceOutlineColor Force the use of outlineColor even if there's a colormap applied to the data. This example alternates between a white-to-green linear colormap (false) and a solid purple-blue (true) Declaration [ABRInput(\"Force Outline Color\", UpdateLevel.Geometry)] public BooleanPrimitive forceOutlineColor Field Value Type Description BooleanPrimitive | Improve this Doc View Source instanceMesh The mesh to populate across all \"instanced transforms\" supplied by key data. Declaration [ABRInput(\"Instance Mesh\", UpdateLevel.Geometry)] public Mesh instanceMesh Field Value Type Description Mesh | Improve this Doc View Source keyData KeyData for InstancedSurfaceDataImpression is an \"unofficial\" 5th type of Key Data - instanced matrices. These key data have no geometry, only a single variable that is a series of 4x4 matrices. Key data can be changed by modifying a RawDataset's matrixArrays and matrixArrayNames. The key data transforms (like every other key data in ABR) can be updated frame-by-frame so long as <xref href=\"IVLab.ABREngine.RenderHints.GeometryChanged\" data-throw-if-not-resolved=\"false\"></xref>= true is specified. For example, here we are spinning the transforms along the y axis. Declaration [ABRInput(\"Key Data\", UpdateLevel.Geometry)] public KeyData keyData Field Value Type Description KeyData | Improve this Doc View Source nanColor Override the color used for NaN values in this data impression. If not supplied, will use the defaultNanColor. Declaration [ABRInput(\"NaN Color\", UpdateLevel.Style)] public IColormapVisAsset nanColor Field Value Type Description IColormapVisAsset | Improve this Doc View Source outlineColor Color of the outline (when forceOutlineColor is true or there's no colormap/colorVariable) Declaration [ABRInput(\"Outline Color\", UpdateLevel.Geometry)] public Color outlineColor Field Value Type Description Color | Improve this Doc View Source outlineWidth Width (in Unity world coords) of the outline Declaration [ABRInput(\"Outline Width\", UpdateLevel.Geometry)] public LengthPrimitive outlineWidth Field Value Type Description LengthPrimitive | Improve this Doc View Source showOutline Show/hide outline on this data impression Declaration [ABRInput(\"Show Outline\", UpdateLevel.Style)] public BooleanPrimitive showOutline Field Value Type Description BooleanPrimitive Properties | Improve this Doc View Source MaterialNames Name of the material to use to render this DataImpression Declaration protected override string[] MaterialNames { get; } Property Value Type Description string[] Overrides DataImpression.MaterialNames Methods | Improve this Doc View Source Cleanup() When this data impression is done being used, clean up after itself if necessary. This method may need access to the GameObject the data impression is applied to. Declaration public override void Cleanup() Overrides DataImpression.Cleanup() | Improve this Doc View Source ComputeGeometry() RENDERING STEP 1. Populate rendering information (Geometry) for the DataImpression. This is triggered by the DataImpressionGroup when an Geometry happens. This step is generally expensive. Declaration public override void ComputeGeometry() Overrides DataImpression.ComputeGeometry() | Improve this Doc View Source GetDataset() By default, there's no dataset. DataImpressions should only have one dataset, and it's up to them individually to enforce that they correctly implement this. Declaration public override Dataset GetDataset() Returns Type Description Dataset Overrides DataImpression.GetDataset() | Improve this Doc View Source GetKeyData() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override KeyData GetKeyData() Returns Type Description KeyData Overrides DataImpression.GetKeyData() | Improve this Doc View Source GetKeyDataTopology() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override DataTopology GetKeyDataTopology() Returns Type Description DataTopology Overrides DataImpression.GetKeyDataTopology() | Improve this Doc View Source SetKeyData(KeyData) By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override void SetKeyData(KeyData kd) Parameters Type Name Description KeyData kd Overrides DataImpression.SetKeyData(KeyData) | Improve this Doc View Source SetupGameObject() RENDERING STEP 2. Take geometric rendering information computed in ComputeGeometry() and sets up proper game object(s) and components for this Data Impression. Transfers geometry into Unity format (e.g. a Mesh). No geometric computations should happen in this method, and it should generally be lightweight. Declaration public override void SetupGameObject() Overrides DataImpression.SetupGameObject() | Improve this Doc View Source UpdateStyling() RENDERING STEP 3. Update the \"styling\" of an impression by sending each styling parameter to the shader. Occasionally will need to set per-vertex items like transforms. This method should generally be lightweight. Declaration public override void UpdateStyling() Overrides DataImpression.UpdateStyling() | Improve this Doc View Source UpdateVisibility() RENDERING STEP 4. Update the visibility of an impression (hidden or shown) Declaration public override void UpdateVisibility() Overrides DataImpression.UpdateVisibility() Implements IHasDataset IHasKeyData ICoordSpaceConverter"
  },
  "api/IVLab.ABREngine.IntegerPrimitive.html": {
    "href": "api/IVLab.ABREngine.IntegerPrimitive.html",
    "title": "Class IntegerPrimitive | ABREngine",
    "keywords": "Class IntegerPrimitive Inheritance object IntegerPrimitive Implements IIntegerPrimitive IPrimitive IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class IntegerPrimitive : IIntegerPrimitive, IPrimitive, IABRInput Constructors | Improve this Doc View Source IntegerPrimitive() Declaration public IntegerPrimitive() | Improve this Doc View Source IntegerPrimitive(int) Declaration public IntegerPrimitive(int value) Parameters Type Name Description int value | Improve this Doc View Source IntegerPrimitive(string) Declaration public IntegerPrimitive(string value) Parameters Type Name Description string value Properties | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre | Improve this Doc View Source ParsingRegex The regex to use to convert this from a string. Group named \"value\" should be the floating point number, group named \"units\" should be the units, if any. Declaration public virtual Regex ParsingRegex { get; } Property Value Type Description Regex | Improve this Doc View Source Units Declaration public virtual string Units { get; } Property Value Type Description string | Improve this Doc View Source Value Declaration public int Value { get; protected set; } Property Value Type Description int Methods | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput | Improve this Doc View Source SetFromString(string) Set the value of the primitive from a string (similar to using the string constructor) Declaration public void SetFromString(string value) Parameters Type Name Description string value | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides object.ToString() Operators | Improve this Doc View Source implicit operator IntegerPrimitive(int) Declaration public static implicit operator IntegerPrimitive(int i) Parameters Type Name Description int i Returns Type Description IntegerPrimitive Implements IIntegerPrimitive IPrimitive IABRInput"
  },
  "api/IVLab.ABREngine.KeyData.html": {
    "href": "api/IVLab.ABREngine.KeyData.html",
    "title": "Class KeyData | ABREngine",
    "keywords": "Class KeyData Lightweight container for a data object. From Key Data objects, scalar and vector variables can be obtained (see the example below). Inheritance object KeyData LineKeyData PointKeyData SurfaceKeyData VolumeKeyData Implements IHasDataset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class KeyData : IHasDataset, IABRInput Examples KeyData can be used to easily get ScalarDataVariables and VectorDataVariables from a dataset. public class KeyDataExample : MonoBehaviour { void Start() { // Load some point data string dataPath = \"Demo/Wavelet/KeyData/Points\"; KeyData kd = ABREngine.Instance.Data.LoadData(dataPath); // Then, we can fetch variables: // ALL the variables kd.GetScalarVariables(); kd.GetVectorVariables(); // Only the names of the variables kd.GetScalarVariableNames(); kd.GetVectorVariableNames(); // Fetch a specific scalar or vector variable by its name kd.GetScalarVariable(\"XAxis\"); kd.GetVectorVariable(\"Inward\"); } } Constructors | Improve this Doc View Source KeyData(string, DataTopology) Lightweight container for a data object. From Key Data objects, scalar and vector variables can be obtained (see the example below). Declaration public KeyData(string path, DataTopology topology) Parameters Type Name Description string path DataTopology topology Examples KeyData can be used to easily get ScalarDataVariables and VectorDataVariables from a dataset. public class KeyDataExample : MonoBehaviour { void Start() { // Load some point data string dataPath = \"Demo/Wavelet/KeyData/Points\"; KeyData kd = ABREngine.Instance.Data.LoadData(dataPath); // Then, we can fetch variables: // ALL the variables kd.GetScalarVariables(); kd.GetVectorVariables(); // Only the names of the variables kd.GetScalarVariableNames(); kd.GetVectorVariableNames(); // Fetch a specific scalar or vector variable by its name kd.GetScalarVariable(\"XAxis\"); kd.GetVectorVariable(\"Inward\"); } } Properties | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre | Improve this Doc View Source Path Lightweight container for a data object. From Key Data objects, scalar and vector variables can be obtained (see the example below). Declaration public string Path { get; } Property Value Type Description string Examples KeyData can be used to easily get ScalarDataVariables and VectorDataVariables from a dataset. public class KeyDataExample : MonoBehaviour { void Start() { // Load some point data string dataPath = \"Demo/Wavelet/KeyData/Points\"; KeyData kd = ABREngine.Instance.Data.LoadData(dataPath); // Then, we can fetch variables: // ALL the variables kd.GetScalarVariables(); kd.GetVectorVariables(); // Only the names of the variables kd.GetScalarVariableNames(); kd.GetVectorVariableNames(); // Fetch a specific scalar or vector variable by its name kd.GetScalarVariable(\"XAxis\"); kd.GetVectorVariable(\"Inward\"); } } | Improve this Doc View Source Topology Lightweight container for a data object. From Key Data objects, scalar and vector variables can be obtained (see the example below). Declaration public DataTopology Topology { get; } Property Value Type Description DataTopology Examples KeyData can be used to easily get ScalarDataVariables and VectorDataVariables from a dataset. public class KeyDataExample : MonoBehaviour { void Start() { // Load some point data string dataPath = \"Demo/Wavelet/KeyData/Points\"; KeyData kd = ABREngine.Instance.Data.LoadData(dataPath); // Then, we can fetch variables: // ALL the variables kd.GetScalarVariables(); kd.GetVectorVariables(); // Only the names of the variables kd.GetScalarVariableNames(); kd.GetVectorVariableNames(); // Fetch a specific scalar or vector variable by its name kd.GetScalarVariable(\"XAxis\"); kd.GetVectorVariable(\"Inward\"); } } Methods | Improve this Doc View Source GetDataset() Lightweight container for a data object. From Key Data objects, scalar and vector variables can be obtained (see the example below). Declaration public Dataset GetDataset() Returns Type Description Dataset | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput | Improve this Doc View Source GetRawDataset() Lightweight container for a data object. From Key Data objects, scalar and vector variables can be obtained (see the example below). Declaration public RawDataset GetRawDataset() Returns Type Description RawDataset Examples KeyData can be used to easily get ScalarDataVariables and VectorDataVariables from a dataset. public class KeyDataExample : MonoBehaviour { void Start() { // Load some point data string dataPath = \"Demo/Wavelet/KeyData/Points\"; KeyData kd = ABREngine.Instance.Data.LoadData(dataPath); // Then, we can fetch variables: // ALL the variables kd.GetScalarVariables(); kd.GetVectorVariables(); // Only the names of the variables kd.GetScalarVariableNames(); kd.GetVectorVariableNames(); // Fetch a specific scalar or vector variable by its name kd.GetScalarVariable(\"XAxis\"); kd.GetVectorVariable(\"Inward\"); } } | Improve this Doc View Source GetScalarVariable(string) Get a specific scalar variable that exists within this key data object Declaration public ScalarDataVariable GetScalarVariable(string varName) Parameters Type Name Description string varName Returns Type Description ScalarDataVariable | Improve this Doc View Source GetScalarVariableNames() Get the names of every scalar variable associated with this key data object Declaration public string[] GetScalarVariableNames() Returns Type Description string[] | Improve this Doc View Source GetScalarVariables() Get all of the scalar data variables associated with this key data object Declaration public ScalarDataVariable[] GetScalarVariables() Returns Type Description ScalarDataVariable[] | Improve this Doc View Source GetVectorVariable(string) Get a specific vector variable that exists within this key data object Declaration public VectorDataVariable GetVectorVariable(string varName) Parameters Type Name Description string varName Returns Type Description VectorDataVariable | Improve this Doc View Source GetVectorVariableNames() Get the names of every vector variable associated with this key data object Declaration public string[] GetVectorVariableNames() Returns Type Description string[] | Improve this Doc View Source GetVectorVariables() Get all of the vector data variables associated with this key data object Declaration public VectorDataVariable[] GetVectorVariables() Returns Type Description VectorDataVariable[] Implements IHasDataset IABRInput"
  },
  "api/IVLab.ABREngine.Legends.ABRLegend.html": {
    "href": "api/IVLab.ABREngine.Legends.ABRLegend.html",
    "title": "Class ABRLegend | ABREngine",
    "keywords": "Class ABRLegend Generate geometry, encodings, and legend images/GameObjects for ABR states Inheritance object Object Component Behaviour MonoBehaviour ABRLegend Namespace: IVLab.ABREngine.Legends Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ABRLegend : MonoBehaviour Fields | Improve this Doc View Source entryOffset Generate geometry, encodings, and legend images/GameObjects for ABR states Declaration [Tooltip(\"Offset for each entry of the legend\")] public Vector3 entryOffset Field Value Type Description Vector3 | Improve this Doc View Source legendEntry2DPrefab Generate geometry, encodings, and legend images/GameObjects for ABR states Declaration [Tooltip(\"Prefab for 2D (2 variable) legend entries\")] public GameObject legendEntry2DPrefab Field Value Type Description GameObject | Improve this Doc View Source updateOnABRStateChange Generate geometry, encodings, and legend images/GameObjects for ABR states Declaration [Tooltip(\"Should the legend be updated whenever the ABR state is updated?\")] public bool updateOnABRStateChange Field Value Type Description bool Methods | Improve this Doc View Source CreateGlyphLegendEntry(SimpleGlyphDataImpression) Construct a glyph data impression for a glyph legend entry Declaration public static SimpleGlyphDataImpression CreateGlyphLegendEntry(SimpleGlyphDataImpression i) Parameters Type Name Description SimpleGlyphDataImpression i Returns Type Description SimpleGlyphDataImpression | Improve this Doc View Source CreateRibbonLegendEntry(SimpleLineDataImpression) Construct a ribbon data impression for a line legend entry Declaration public static SimpleLineDataImpression CreateRibbonLegendEntry(SimpleLineDataImpression i) Parameters Type Name Description SimpleLineDataImpression i Returns Type Description SimpleLineDataImpression | Improve this Doc View Source CreateSurfaceLegendEntry(SimpleSurfaceDataImpression) Construct a surface data impression for legend entry Declaration public static SimpleSurfaceDataImpression CreateSurfaceLegendEntry(SimpleSurfaceDataImpression i) Parameters Type Name Description SimpleSurfaceDataImpression i Returns Type Description SimpleSurfaceDataImpression | Improve this Doc View Source CreateVolumeLegendEntry(SimpleVolumeDataImpression) Construct a volume data impression for legend entry Declaration public static SimpleVolumeDataImpression CreateVolumeLegendEntry(SimpleVolumeDataImpression i) Parameters Type Name Description SimpleVolumeDataImpression i Returns Type Description SimpleVolumeDataImpression | Improve this Doc View Source UpdateLegend(JObject) Update the legend display in Unity from the current ABR state Declaration public void UpdateLegend(JObject state) Parameters Type Name Description JObject state"
  },
  "api/IVLab.ABREngine.Legends.ABRLegendEntry.Label.html": {
    "href": "api/IVLab.ABREngine.Legends.ABRLegendEntry.Label.html",
    "title": "Enum ABRLegendEntry.Label | ABREngine",
    "keywords": "Enum ABRLegendEntry.Label Namespace: IVLab.ABREngine.Legends Assembly: IVLab.ABREngine.Runtime.dll Syntax public enum ABRLegendEntry.Label Fields Name Description TextLabels Title XAxis XAxisMax XAxisMin YAxis YAxisMax YAxisMin"
  },
  "api/IVLab.ABREngine.Legends.ABRLegendEntry.html": {
    "href": "api/IVLab.ABREngine.Legends.ABRLegendEntry.html",
    "title": "Class ABRLegendEntry | ABREngine",
    "keywords": "Class ABRLegendEntry Controller for 3D GameObject-based legends for ABR Inheritance object Object Component Behaviour MonoBehaviour ABRLegendEntry Namespace: IVLab.ABREngine.Legends Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ABRLegendEntry : MonoBehaviour Methods | Improve this Doc View Source SetTextLabel(Label, string) Controller for 3D GameObject-based legends for ABR Declaration public void SetTextLabel(ABRLegendEntry.Label labelName, string text) Parameters Type Name Description ABRLegendEntry.Label labelName string text"
  },
  "api/IVLab.ABREngine.Legends.ABRLegendGeometry.html": {
    "href": "api/IVLab.ABREngine.Legends.ABRLegendGeometry.html",
    "title": "Class ABRLegendGeometry | ABREngine",
    "keywords": "Class ABRLegendGeometry Generate legend geometry for each data impression type defined in ABR. Methods in this class can generate the following variables and ranges: XAxis [0, 1] YAxis [0, 1] ZAxis [0, 1] Forward Up Inheritance object ABRLegendGeometry Namespace: IVLab.ABREngine.Legends Assembly: IVLab.ABREngine.Runtime.dll Syntax public static class ABRLegendGeometry Methods | Improve this Doc View Source Glyphs(int) Generate a set of n glyphs to show a legend. Declaration public static RawDataset Glyphs(int variables) Parameters Type Name Description int variables Number of variables to provide (1 var, 2 var) Returns Type Description RawDataset | Improve this Doc View Source Ribbons(int) Generate a set of ribbons to show in a legend. Declaration public static RawDataset Ribbons(int variables) Parameters Type Name Description int variables Number of variables to provide (1 var, 2 var) Returns Type Description RawDataset | Improve this Doc View Source Surface() Generate a surface to show a legend Declaration public static RawDataset Surface() Returns Type Description RawDataset | Improve this Doc View Source Volume() Generate a \"spherical\" volume for legends Declaration public static RawDataset Volume() Returns Type Description RawDataset"
  },
  "api/IVLab.ABREngine.Legends.html": {
    "href": "api/IVLab.ABREngine.Legends.html",
    "title": "Namespace IVLab.ABREngine.Legends | ABREngine",
    "keywords": "Namespace IVLab.ABREngine.Legends Classes ABRLegend Generate geometry, encodings, and legend images/GameObjects for ABR states ABRLegendEntry Controller for 3D GameObject-based legends for ABR ABRLegendGeometry Generate legend geometry for each data impression type defined in ABR. Methods in this class can generate the following variables and ranges: XAxis [0, 1] YAxis [0, 1] ZAxis [0, 1] Forward Up Enums ABRLegendEntry.Label"
  },
  "api/IVLab.ABREngine.LengthPrimitive.html": {
    "href": "api/IVLab.ABREngine.LengthPrimitive.html",
    "title": "Class LengthPrimitive | ABREngine",
    "keywords": "Class LengthPrimitive Inheritance object FloatPrimitive LengthPrimitive Implements IFloatPrimitive IPrimitive IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class LengthPrimitive : FloatPrimitive, IFloatPrimitive, IPrimitive, IABRInput Constructors | Improve this Doc View Source LengthPrimitive(float) Declaration public LengthPrimitive(float value) Parameters Type Name Description float value | Improve this Doc View Source LengthPrimitive(string) Declaration public LengthPrimitive(string value) Parameters Type Name Description string value Properties | Improve this Doc View Source ParsingRegex The regex to use to convert this from a string. Group named \"value\" should be the floating point number, group named \"units\" should be the units, if any. Declaration public override Regex ParsingRegex { get; } Property Value Type Description Regex Overrides FloatPrimitive.ParsingRegex | Improve this Doc View Source Units Declaration public override string Units { get; } Property Value Type Description string Overrides FloatPrimitive.Units Methods | Improve this Doc View Source SetFromString(string) Set the value of the primitive from a string (similar to using the string constructor) Declaration public override void SetFromString(string value) Parameters Type Name Description string value Overrides FloatPrimitive.SetFromString(string) Operators | Improve this Doc View Source implicit operator LengthPrimitive(float) Declaration public static implicit operator LengthPrimitive(float f) Parameters Type Name Description float f Returns Type Description LengthPrimitive Implements IFloatPrimitive IPrimitive IABRInput"
  },
  "api/IVLab.ABREngine.LineKeyData.html": {
    "href": "api/IVLab.ABREngine.LineKeyData.html",
    "title": "Class LineKeyData | ABREngine",
    "keywords": "Class LineKeyData Inheritance object KeyData LineKeyData Implements IHasDataset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Obsolete(\"Specific types of KeyData are obsolete and may not work correctly. Use KeyData class instead.\")] public class LineKeyData : KeyData, IHasDataset, IABRInput Constructors | Improve this Doc View Source LineKeyData(string, DataTopology) Declaration public LineKeyData(string path, DataTopology topology) Parameters Type Name Description string path DataTopology topology Implements IHasDataset IABRInput"
  },
  "api/IVLab.ABREngine.LineTextureGradient.html": {
    "href": "api/IVLab.ABREngine.LineTextureGradient.html",
    "title": "Class LineTextureGradient | ABREngine",
    "keywords": "Class LineTextureGradient Inheritance object VisAsset VisAssetGradient LineTextureGradient Implements ILineTextureVisAsset IVisAssetGradient<LineTextureVisAsset> IVisAsset IABRInput ITextureGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class LineTextureGradient : VisAssetGradient, ILineTextureVisAsset, IVisAssetGradient<LineTextureVisAsset>, IVisAsset, IABRInput, ITextureGradient Properties | Improve this Doc View Source BlendMaps Internal calculations for blend maps used for rendering Declaration public GradientBlendMap BlendMaps { get; } Property Value Type Description GradientBlendMap | Improve this Doc View Source Stops List of gradient stops (length of VisAssets - 1) Declaration public List<float> Stops { get; } Property Value Type Description List<float> | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration public int VisAssetCount { get; } Property Value Type Description int | Improve this Doc View Source VisAssets List of all VisAssets inside this gradient Declaration public List<LineTextureVisAsset> VisAssets { get; } Property Value Type Description List<LineTextureVisAsset> Methods | Improve this Doc View Source GetTexture() Obtain the first (or, only) texture in a multi-visasset gradient Declaration public Texture2D GetTexture() Returns Type Description Texture2D | Improve this Doc View Source GetTexture(int) Obtain the texture at a specific index within a multi-visasset gradient Declaration public Texture2D GetTexture(int gradientIndex) Parameters Type Name Description int gradientIndex Returns Type Description Texture2D | Improve this Doc View Source GetTexture(float) Obtain the texture at a specific t-value (percentage) within a multi-visasset gradient Declaration public Texture2D GetTexture(float gradientT) Parameters Type Name Description float gradientT Returns Type Description Texture2D | Improve this Doc View Source Initialize(Guid, List<LineTextureVisAsset>, List<float>) Initialize this gradient with a UUID, some VisAssets, and some Stops. This is used instead of a constructor because it is much more flexible. Declaration public void Initialize(Guid uuid, List<LineTextureVisAsset> visAssets, List<float> stops) Parameters Type Name Description Guid uuid List<LineTextureVisAsset> visAssets List<float> stops Implements ILineTextureVisAsset IVisAssetGradient<T> IVisAsset IABRInput ITextureGradient"
  },
  "api/IVLab.ABREngine.LineTextureVisAsset.html": {
    "href": "api/IVLab.ABREngine.LineTextureVisAsset.html",
    "title": "Class LineTextureVisAsset | ABREngine",
    "keywords": "Class LineTextureVisAsset Inheritance object VisAsset LineTextureVisAsset Implements ILineTextureVisAsset IVisAsset IABRInput ITextureGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class LineTextureVisAsset : VisAsset, ILineTextureVisAsset, IVisAsset, IABRInput, ITextureGradient Constructors | Improve this Doc View Source LineTextureVisAsset() Declaration public LineTextureVisAsset() | Improve this Doc View Source LineTextureVisAsset(Guid, Texture2D) Declaration public LineTextureVisAsset(Guid uuid, Texture2D texture) Parameters Type Name Description Guid uuid Texture2D texture | Improve this Doc View Source LineTextureVisAsset(Texture2D) Declaration public LineTextureVisAsset(Texture2D texture) Parameters Type Name Description Texture2D texture Properties | Improve this Doc View Source BlendMaps Internal calculations for blend maps used for rendering Declaration public GradientBlendMap BlendMaps { get; } Property Value Type Description GradientBlendMap | Improve this Doc View Source Texture Declaration public Texture2D Texture { get; } Property Value Type Description Texture2D | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration public int VisAssetCount { get; } Property Value Type Description int Methods | Improve this Doc View Source GetTexture() Obtain the first (or, only) texture in a multi-visasset gradient Declaration public Texture2D GetTexture() Returns Type Description Texture2D | Improve this Doc View Source GetTexture(int) Obtain the texture at a specific index within a multi-visasset gradient Declaration public Texture2D GetTexture(int gradientIndex) Parameters Type Name Description int gradientIndex Returns Type Description Texture2D | Improve this Doc View Source GetTexture(float) Obtain the texture at a specific t-value (percentage) within a multi-visasset gradient Declaration public Texture2D GetTexture(float gradientT) Parameters Type Name Description float gradientT Returns Type Description Texture2D Implements ILineTextureVisAsset IVisAsset IABRInput ITextureGradient"
  },
  "api/IVLab.ABREngine.MediaDataLoader.html": {
    "href": "api/IVLab.ABREngine.MediaDataLoader.html",
    "title": "Class MediaDataLoader | ABREngine",
    "keywords": "Class MediaDataLoader Load data from the ABREngine Media directory (specified in ABRConfig) Inheritance object MediaDataLoader Implements IDataLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class MediaDataLoader : IDataLoader Methods | Improve this Doc View Source LoadData(string) Load data specified by dataPath from a particular source Declaration public RawDataset LoadData(string dataPath) Parameters Type Name Description string dataPath Returns Type Description RawDataset Implements IDataLoader"
  },
  "api/IVLab.ABREngine.Notifier.html": {
    "href": "api/IVLab.ABREngine.Notifier.html",
    "title": "Class Notifier | ABREngine",
    "keywords": "Class Notifier Notifier for ABR state / cache updates, based on WebSockets. Inheritance object Notifier Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class Notifier Constructors | Improve this Doc View Source Notifier(Uri) Notifier for ABR state / cache updates, based on WebSockets. Declaration public Notifier(Uri serverPath) Parameters Type Name Description Uri serverPath Methods | Improve this Doc View Source ForceDisconnect() Notifier for ABR state / cache updates, based on WebSockets. Declaration public void ForceDisconnect() | Improve this Doc View Source Init() Notifier for ABR state / cache updates, based on WebSockets. Declaration public void Init() | Improve this Doc View Source Stop() Notifier for ABR state / cache updates, based on WebSockets. Declaration public void Stop()"
  },
  "api/IVLab.ABREngine.PathStateFileLoader.html": {
    "href": "api/IVLab.ABREngine.PathStateFileLoader.html",
    "title": "Class PathStateFileLoader | ABREngine",
    "keywords": "Class PathStateFileLoader Save/Load a state to a JSON file somewhere on disk Inheritance object PathStateFileLoader Implements IABRStateLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class PathStateFileLoader : IABRStateLoader Constructors | Improve this Doc View Source PathStateFileLoader() Save/Load a state to a JSON file somewhere on disk Declaration public PathStateFileLoader() Methods | Improve this Doc View Source GetState(string) Load a state based on some text (perhaps a JSON string, a file path, or URL) Declaration public JObject GetState(string stateFilePath) Parameters Type Name Description string stateFilePath Returns Type Description JObject | Improve this Doc View Source SaveState(string, string) Save a serialized JSON state with a particular name Declaration public void SaveState(string outPath, string serializedState) Parameters Type Name Description string outPath string serializedState Implements IABRStateLoader"
  },
  "api/IVLab.ABREngine.PercentPrimitive.html": {
    "href": "api/IVLab.ABREngine.PercentPrimitive.html",
    "title": "Class PercentPrimitive | ABREngine",
    "keywords": "Class PercentPrimitive Inheritance object FloatPrimitive PercentPrimitive Implements IFloatPrimitive IPrimitive IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class PercentPrimitive : FloatPrimitive, IFloatPrimitive, IPrimitive, IABRInput Constructors | Improve this Doc View Source PercentPrimitive(float) Declaration public PercentPrimitive(float value) Parameters Type Name Description float value | Improve this Doc View Source PercentPrimitive(string) Declaration public PercentPrimitive(string value) Parameters Type Name Description string value Properties | Improve this Doc View Source ParsingRegex The regex to use to convert this from a string. Group named \"value\" should be the floating point number, group named \"units\" should be the units, if any. Declaration public override Regex ParsingRegex { get; } Property Value Type Description Regex Overrides FloatPrimitive.ParsingRegex | Improve this Doc View Source Units Declaration public override string Units { get; } Property Value Type Description string Overrides FloatPrimitive.Units Methods | Improve this Doc View Source SetFromString(string) Set the value of the primitive from a string (similar to using the string constructor) Declaration public override void SetFromString(string value) Parameters Type Name Description string value Overrides FloatPrimitive.SetFromString(string) | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description string Overrides FloatPrimitive.ToString() Operators | Improve this Doc View Source implicit operator PercentPrimitive(float) Declaration public static implicit operator PercentPrimitive(float f) Parameters Type Name Description float f Returns Type Description PercentPrimitive Implements IFloatPrimitive IPrimitive IABRInput"
  },
  "api/IVLab.ABREngine.PointKeyData.html": {
    "href": "api/IVLab.ABREngine.PointKeyData.html",
    "title": "Class PointKeyData | ABREngine",
    "keywords": "Class PointKeyData Inheritance object KeyData PointKeyData Implements IHasDataset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Obsolete(\"Specific types of KeyData are obsolete and may not work correctly. Use KeyData class instead.\")] public class PointKeyData : KeyData, IHasDataset, IABRInput Constructors | Improve this Doc View Source PointKeyData(string, DataTopology) Declaration public PointKeyData(string path, DataTopology topology) Parameters Type Name Description string path DataTopology topology Implements IHasDataset IABRInput"
  },
  "api/IVLab.ABREngine.PrimitiveGradient.html": {
    "href": "api/IVLab.ABREngine.PrimitiveGradient.html",
    "title": "Class PrimitiveGradient | ABREngine",
    "keywords": "Class PrimitiveGradient A simple gradient of points associated with values. Inheritance object PrimitiveGradient Implements IPrimitiveGradient IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class PrimitiveGradient : IPrimitiveGradient, IABRInput Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. Constructors | Improve this Doc View Source PrimitiveGradient(Guid, float[], string[]) A simple gradient of points associated with values. Declaration public PrimitiveGradient(Guid inputValue, float[] points, string[] values) Parameters Type Name Description Guid inputValue float[] points string[] values Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. Properties | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. | Improve this Doc View Source InputValue A simple gradient of points associated with values. Declaration public Guid InputValue { get; } Property Value Type Description Guid Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. | Improve this Doc View Source Points A simple gradient of points associated with values. Declaration public float[] Points { get; } Property Value Type Description float[] Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. | Improve this Doc View Source Values A simple gradient of points associated with values. Declaration public string[] Values { get; } Property Value Type Description string[] Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. Methods | Improve this Doc View Source Default() Return a default 0%-100% gradient at 0.0 and 1.0 Declaration public static PrimitiveGradient Default() Returns Type Description PrimitiveGradient Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput Remarks At present, this class is expressly used to describe the opacitymap. In the future this may change, and when that happens this class will likely change as well. Implements IPrimitiveGradient IABRInput"
  },
  "api/IVLab.ABREngine.RawABRInput.html": {
    "href": "api/IVLab.ABREngine.RawABRInput.html",
    "title": "Class RawABRInput | ABREngine",
    "keywords": "Class RawABRInput Raw string values from a state JSON being passed to ABR Matches InputValue definition from ABR State Schema Parameters can have one or more inputs Inheritance object RawABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class RawABRInput Fields | Improve this Doc View Source inputGenre What type of input is it (variable, visasset, etc.) Declaration public string inputGenre Field Value Type Description string | Improve this Doc View Source inputType String representation of the C# type this ABR input is Declaration public string inputType Field Value Type Description string | Improve this Doc View Source inputValue The actual value of the input (string representation) Declaration public string inputValue Field Value Type Description string Methods | Improve this Doc View Source CanConvertToABRInput(string) Checks if the type can be converted from a raw to actual ABR input Declaration public bool CanConvertToABRInput(string type) Parameters Type Name Description string type Returns Type Description bool | Improve this Doc View Source Copy() Raw string values from a state JSON being passed to ABR Matches InputValue definition from ABR State Schema Parameters can have one or more inputs Declaration public RawABRInput Copy() Returns Type Description RawABRInput | Improve this Doc View Source ToABRInput() Convert a RawABRInput (strings from JSON) to a real ABR input assignable to data impressions Declaration public IABRInput ToABRInput() Returns Type Description IABRInput"
  },
  "api/IVLab.ABREngine.RawDataset.BinaryData.html": {
    "href": "api/IVLab.ABREngine.RawDataset.BinaryData.html",
    "title": "Class RawDataset.BinaryData | ABREngine",
    "keywords": "Class RawDataset.BinaryData Actual geometric representation of the data to load from a file / socket Inheritance object RawDataset.BinaryData Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class RawDataset.BinaryData Constructors | Improve this Doc View Source BinaryData(JsonHeader, byte[]) Actual geometric representation of the data to load from a file / socket Declaration public BinaryData(RawDataset.JsonHeader bdh, byte[] bytes) Parameters Type Name Description RawDataset.JsonHeader bdh byte[] bytes | Improve this Doc View Source BinaryData(JsonHeader, string) Actual geometric representation of the data to load from a file / socket Declaration public BinaryData(RawDataset.JsonHeader bdh, string file) Parameters Type Name Description RawDataset.JsonHeader bdh string file Properties | Improve this Doc View Source index_array Actual geometric representation of the data to load from a file / socket Declaration public int[] index_array { get; set; } Property Value Type Description int[] | Improve this Doc View Source scalar_arrays Actual geometric representation of the data to load from a file / socket Declaration public float[][] scalar_arrays { get; set; } Property Value Type Description float[][] | Improve this Doc View Source vector_arrays Actual geometric representation of the data to load from a file / socket Declaration public float[][] vector_arrays { get; set; } Property Value Type Description float[][] | Improve this Doc View Source vertices Actual geometric representation of the data to load from a file / socket Declaration public float[] vertices { get; set; } Property Value Type Description float[] Methods | Improve this Doc View Source Decode(JsonHeader, byte[]) Actual geometric representation of the data to load from a file / socket Declaration public void Decode(RawDataset.JsonHeader bdh, byte[] bytes) Parameters Type Name Description RawDataset.JsonHeader bdh byte[] bytes | Improve this Doc View Source Encode(JsonHeader, in Vector3[], in int[], in int[], in int[], in SerializableFloatArray[], in SerializableVectorArray[]) Actual geometric representation of the data to load from a file / socket Declaration public static byte[] Encode(RawDataset.JsonHeader bdh, in Vector3[] vertices, in int[] indices, in int[] cellIndexOffsets, in int[] cellIndexCounts, in SerializableFloatArray[] scalars, in SerializableVectorArray[] vectors) Parameters Type Name Description RawDataset.JsonHeader bdh Vector3[] vertices int[] indices int[] cellIndexOffsets int[] cellIndexCounts SerializableFloatArray[] scalars SerializableVectorArray[] vectors Returns Type Description byte[]"
  },
  "api/IVLab.ABREngine.RawDataset.JsonHeader.html": {
    "href": "api/IVLab.ABREngine.RawDataset.JsonHeader.html",
    "title": "Class RawDataset.JsonHeader | ABREngine",
    "keywords": "Class RawDataset.JsonHeader Header that contains metadata for a particular RawDataset Inheritance object RawDataset.JsonHeader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class RawDataset.JsonHeader Fields | Improve this Doc View Source bounds Header that contains metadata for a particular RawDataset Declaration public Bounds bounds Field Value Type Description Bounds | Improve this Doc View Source dimensions Header that contains metadata for a particular RawDataset Declaration public int[] dimensions Field Value Type Description int[] | Improve this Doc View Source meshTopology Header that contains metadata for a particular RawDataset Declaration public DataTopology meshTopology Field Value Type Description DataTopology | Improve this Doc View Source num_cell_indices Header that contains metadata for a particular RawDataset Declaration public int num_cell_indices Field Value Type Description int | Improve this Doc View Source num_cells Header that contains metadata for a particular RawDataset Declaration public int num_cells Field Value Type Description int | Improve this Doc View Source num_points Header that contains metadata for a particular RawDataset Declaration public int num_points Field Value Type Description int | Improve this Doc View Source scalarArrayNames Header that contains metadata for a particular RawDataset Declaration public string[] scalarArrayNames Field Value Type Description string[] | Improve this Doc View Source scalarMaxes Header that contains metadata for a particular RawDataset Declaration public float[] scalarMaxes Field Value Type Description float[] | Improve this Doc View Source scalarMins Header that contains metadata for a particular RawDataset Declaration public float[] scalarMins Field Value Type Description float[] | Improve this Doc View Source vectorArrayNames Header that contains metadata for a particular RawDataset Declaration public string[] vectorArrayNames Field Value Type Description string[]"
  },
  "api/IVLab.ABREngine.RawDataset.html": {
    "href": "api/IVLab.ABREngine.RawDataset.html",
    "title": "Class RawDataset | ABREngine",
    "keywords": "Class RawDataset The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Inheritance object RawDataset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Serializable] public class RawDataset Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; Constructors | Improve this Doc View Source RawDataset() The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public RawDataset() Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source RawDataset(JsonHeader, BinaryData) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public RawDataset(RawDataset.JsonHeader jh, RawDataset.BinaryData bd) Parameters Type Name Description RawDataset.JsonHeader jh RawDataset.BinaryData bd Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; Fields | Improve this Doc View Source bounds The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public Bounds bounds Field Value Type Description Bounds Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source cellIndexCounts The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public int[] cellIndexCounts Field Value Type Description int[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source cellIndexOffsets The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public int[] cellIndexOffsets Field Value Type Description int[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source dataTopology The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public DataTopology dataTopology Field Value Type Description DataTopology Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source dimensions The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public Vector3Int dimensions Field Value Type Description Vector3Int Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source indexArray The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public int[] indexArray Field Value Type Description int[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source matrixArrayNames The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public string[] matrixArrayNames Field Value Type Description string[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source matrixArrays The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public Matrix4x4[][] matrixArrays Field Value Type Description Matrix4x4[][] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source scalarArrayNames The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public string[] scalarArrayNames Field Value Type Description string[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source scalarArrays The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public SerializableFloatArray[] scalarArrays Field Value Type Description SerializableFloatArray[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source scalarMaxes The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public float[] scalarMaxes Field Value Type Description float[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source scalarMins The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public float[] scalarMins Field Value Type Description float[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source vectorArrayNames The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public string[] vectorArrayNames Field Value Type Description string[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source vectorArrays The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public SerializableVectorArray[] vectorArrays Field Value Type Description SerializableVectorArray[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source vertexArray The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration [SerializeField] public Vector3[] vertexArray Field Value Type Description Vector3[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; Methods | Improve this Doc View Source GetMatrixArray(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public Matrix4x4[] GetMatrixArray(string name) Parameters Type Name Description string name Returns Type Description Matrix4x4[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source GetScalarArray(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public float[] GetScalarArray(string name) Parameters Type Name Description string name Returns Type Description float[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source GetScalarMax(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public float GetScalarMax(string name) Parameters Type Name Description string name Returns Type Description float Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source GetScalarMin(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public float GetScalarMin(string name) Parameters Type Name Description string name Returns Type Description float Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source GetVectorArray(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public Vector3[] GetVectorArray(string name) Parameters Type Name Description string name Returns Type Description Vector3[] Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source GetVectorMax(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public Vector3 GetVectorMax(string name) Parameters Type Name Description string name Returns Type Description Vector3 Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source GetVectorMin(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public Vector3 GetVectorMin(string name) Parameters Type Name Description string name Returns Type Description Vector3 Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source HasScalarArray(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public bool HasScalarArray(string name) Parameters Type Name Description string name Returns Type Description bool Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source HasVectorArray(string) The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. Declaration public bool HasVectorArray(string name) Parameters Type Name Description string name Returns Type Description bool Examples A simple 4-vertex plane with no variables can be created like this: RawDataset ds = new RawDataset(); ds.meshTopology = MeshTopology.Triangles; ds.bounds = new Bounds(Vector3.zero, Vector3.one * 2.0f); ds.vectorArrays = new SerializableVectorArray[0]; ds.vectorArrayNames = new string[0]; ds.scalarArrays = new SerializableFloatArray[0]; ds.scalarArrayNames = new string[0]; ds.scalarMins = new float[0]; ds.scalarMaxes = new float[0]; // Construct the vertices Vector3[] vertices = { new Vector3(-1, 0, -1), // 0 new Vector3( 1, 0, -1), // 1 new Vector3(-1, 0, 1), // 2 new Vector3( 1, 0, 1), // 3 }; ds.vertexArray = vertices; // Construct triangle indices/faces - LEFT HAND RULE, outward-facing normals int[] indices = { // Bottom face 0, 1, 3, 0, 3, 2 }; ds.indexArray = indices; // How many verts per cell are there? (each triangle is a cell) int[] cellIndexCounts = { 3, 3 }; ds.cellIndexCounts = cellIndexCounts; // Where does each cell begin? int[] cellIndexOffsets = { 0, 3 }; ds.cellIndexOffsets = cellIndexOffsets; | Improve this Doc View Source ToFilePair() Convert this raw dataset into a .json and .bin pair representation. Does not save the file, only returns a tuple. Declaration public Tuple<string, byte[]> ToFilePair() Returns Type Description Tuple<string, byte[]> Returns a tuple (json data header, binary data file contents)"
  },
  "api/IVLab.ABREngine.RawDatasetAdapter.html": {
    "href": "api/IVLab.ABREngine.RawDatasetAdapter.html",
    "title": "Class RawDatasetAdapter | ABREngine",
    "keywords": "Class RawDatasetAdapter Adapter for converting other formats to ABRDataFormat. For example, lists of points => ribbons, or lists of points => glyphs. See the examples below for usage of each of these methods. Inheritance object RawDatasetAdapter Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public static class RawDatasetAdapter Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Methods | Improve this Doc View Source GridPointsToSurface(List<Vector3>, Vector2Int, Bounds, Dictionary<string, List<float>>) Convert a grid (2.5D) of points into an ABR surface data object. Declaration public static RawDataset GridPointsToSurface(List<Vector3> points, Vector2Int gridDimension, Bounds dataBounds, Dictionary<string, List<float>> scalarVars) Parameters Type Name Description List<Vector3> points Vertices of the desired mesh. Points are assumed to be in reverse column-major order, i.e. starting from -x, -z and ending at +x +z. Vector2Int gridDimension Dimensions of the mesh grid that the points make up (x vertex count and z vertex count). Bounds dataBounds The bounds of the actual vertices of the data. Dictionary<string, List<float>> scalarVars Mapping from name => float array for every scalar variable attached to the data. Float arrays are assumed to have the same ordering as points. Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we create a surface from a Cube GameObject primitive. public class RawDatasetAdapterExample : MonoBehaviour { void Start() { // 3x3 2.5D grid of points. Note their arrangement in x-based \"columns\" // -- this is a grid in the X-Z plane where only the y-coordinate is // varying. List<Vector3> gridVertices = new List<Vector3> { // column 1 new Vector3(0.0f, 0.5f, 0.0f), new Vector3(0.0f, 0.6f, 0.1f), new Vector3(0.0f, 0.4f, 0.2f), // column 2 new Vector3(0.1f, 0.3f, 0.0f), new Vector3(0.1f, 0.2f, 0.1f), new Vector3(0.1f, 0.3f, 0.2f), // column 3 new Vector3(0.2f, 0.0f, 0.0f), new Vector3(0.2f, 0.3f, 0.1f), new Vector3(0.2f, 0.1f, 0.2f), }; // Dimenisions of the grid vertices (3x3) Vector2Int dimensions = new Vector2Int(3, 3); // Each data point corresponds with a vertex above List<float> data = new List<float> { 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 2.0f, 2.0f, 2.0f, }; // Save the var so we can use it Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> {{ \"someData\", data }}; // Provide a generous bounding box Bounds b = new Bounds(Vector3.zero, Vector3.one); RawDataset abrSurface = RawDatasetAdapter.GridPointsToSurface(gridVertices, dimensions, b, scalarVars); // Or, if you don't have any variables: RawDataset abrSurface2 = RawDatasetAdapter.GridPointsToSurface(gridVertices, dimensions, b, null); } } | Improve this Doc View Source MeshToSurface(Mesh, Dictionary<string, List<float>>) Create a surfaces data object from a Unity mesh Declaration public static RawDataset MeshToSurface(Mesh mesh, Dictionary<string, List<float>> scalarVars) Parameters Type Name Description Mesh mesh The original mesh Dictionary<string, List<float>> scalarVars Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we load a triangle GameObject from our existing Unity scene and associate some data with it. public class RawDatasetAdapterExample : MonoBehaviour { void Start() { Mesh m = GameObject.Find(\"SomeTriangle\").GetComponent<MeshFilter>().mesh; // 3 vertices with scalar data values (assumed to have same number of vertices as the mesh, and the same order too) List<float> someVariable = new List<float> { 0.0f, 1.0f, 0.5f }; Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> {{ \"someVariable\", someVariable }}; RawDataset meshSurface = RawDatasetAdapter.MeshToSurface(m, scalarVars); } } | Improve this Doc View Source ObjToSurface(string) Load data from the data source. Declaration public static RawDataset ObjToSurface(string filePath) Parameters Type Name Description string filePath Data source file Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we load in a 3D model in OBJ format and convert it into ABR format. public class RawDatasetAdapterExample : MonoBehaviour { void Start() { RawDataset objSurface = RawDatasetAdapter.ObjToSurface(\"C:/Users/me/Desktop/cube.obj\"); } } | Improve this Doc View Source PointsToLine(List<List<Vector3>>, Bounds, Dictionary<string, List<float>>) Define a Line dataset from a bunch of points. Don't try to assume or calculate the full bounds for the imported data objects - explictly ask the user for them. Declaration public static RawDataset PointsToLine(List<List<Vector3>> lines, Bounds dataBounds, Dictionary<string, List<float>> scalarVars) Parameters Type Name Description List<List<Vector3>> lines One, or several, lines. Each line consists of a series of points. Bounds dataBounds The center and extents of the data in the original coordinate space Dictionary<string, List<float>> scalarVars Mapping of variable name => array of floating point numbers for each scalar variable attached to the lines. Values will be applied at each point along each segment of each line. Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! | Improve this Doc View Source PointsToLine(List<Vector3>, Bounds, Dictionary<string, List<float>>) Define a Line dataset from a bunch of points. Don't try to assume or calculate the full bounds for the imported data objects - explictly ask the user for them. This method is a shortcut for a single connected line. Declaration public static RawDataset PointsToLine(List<Vector3> line, Bounds dataBounds, Dictionary<string, List<float>> scalarVars) Parameters Type Name Description List<Vector3> line Bounds dataBounds The center and extents of the data in the original coordinate space Dictionary<string, List<float>> scalarVars Mapping of variable name => array of floating point numbers for each scalar variable attached to the lines. Values will be applied at each point along each segment of each line. Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we create a single line from a series of vertices that have data values associated with them. public class RawDatasetAdapterExample : MonoBehaviour { void Start() { List<Vector3> points = new List<Vector3> { new Vector3(0.0f, 0.0f, 0.0f), new Vector3(0.1f, 0.1f, 0.0f), new Vector3(0.2f, 0.2f, 0.0f), new Vector3(0.3f, 0.3f, 0.0f), new Vector3(0.4f, 0.4f, 0.0f), new Vector3(0.5f, 0.5f, 0.0f) }; // Each data point corresponds with a vertex above List<float> data = new List<float> { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f }; // Save the scalar var so we can use it Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> {{ \"someData\", data }}; // Provide a generous bounding box Bounds b = new Bounds(Vector3.zero, Vector3.one); RawDataset abrLine = RawDatasetAdapter.PointsToLine(points, b, scalarVars); // Or, if you don't have any variables: RawDataset abrLine2 = RawDatasetAdapter.PointsToLine(points, b, null); } } | Improve this Doc View Source PointsToPoints(List<Vector3>, Bounds, Dictionary<string, List<float>>, Dictionary<string, List<Vector3>>) Define a Point dataset from a bunch of points. Don't try to assume or calculate the full bounds for the imported data objects - explictly ask the user for them. Declaration public static RawDataset PointsToPoints(List<Vector3> points, Bounds dataBounds, Dictionary<string, List<float>> scalarVars, Dictionary<string, List<Vector3>> vectorVars) Parameters Type Name Description List<Vector3> points Source points in the original coordinate space Bounds dataBounds Center and extent of the data, in the original coordinate space Dictionary<string, List<float>> scalarVars Mapping of variable name => array of floating point numbers for each scalar variable attached to these points. Values will be applied at each point of the dataset. Dictionary<string, List<Vector3>> vectorVars Mapping of variable name => array of Vector3 for each vector variable attached to these points. Values will be applied at each point of the dataset. Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we create a points data object from a series of vertices. public class RawDatasetAdapterExample : MonoBehaviour { void Start() { List<Vector3> points = new List<Vector3> { new Vector3(0.0f, 0.0f, 0.0f), new Vector3(0.1f, 0.1f, 0.0f), new Vector3(0.2f, 0.2f, 0.0f), new Vector3(0.3f, 0.3f, 0.0f), new Vector3(0.4f, 0.4f, 0.0f), new Vector3(0.5f, 0.5f, 0.0f) }; // Each data point corresponds with a vertex above List<float> data = new List<float> { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f }; // Some vector data corresponding with each vertex List<Vector3> vectorData = new List<Vector3> { Vector3.up, Vector3.up, Vector3.up, Vector3.down, Vector3.down, Vector3.down, }; // Save the vars so we can use them Dictionary<string, List<float>> scalarVars = new Dictionary<string, List<float>> {{ \"someData\", data }}; Dictionary<string, List<Vector3>> vectorVars = new Dictionary<string, List<Vector3>> {{ \"someVectorData\", vectorData }}; // Provide a generous bounding box Bounds b = new Bounds(Vector3.zero, Vector3.one); RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(points, b, scalarVars, vectorVars); // Or, if you don't have any variables: RawDataset abrPoints2 = RawDatasetAdapter.PointsToPoints(points, b, null, null); } } | Improve this Doc View Source UnityPrimitiveToSurface(PrimitiveType) Create a Surface data object from a Unity primitive. By default, includes XAxis, YAxis, and ZAxis scalar variables. Declaration public static RawDataset UnityPrimitiveToSurface(PrimitiveType primitive) Parameters Type Name Description PrimitiveType primitive Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we create a surface from a Cube GameObject primitive. public class RawDatasetAdapterExample : MonoBehaviour { void Start() { RawDataset cubeSurface = RawDatasetAdapter.UnityPrimitiveToSurface(PrimitiveType.Cube); } } | Improve this Doc View Source VoxelsToVolume(float[], string, Vector3Int, Bounds) Convert a 1D array into an ABR volume data object. There is assumed to be a single scalar variable described by the array voxels. Declaration public static RawDataset VoxelsToVolume(float[] voxels, string voxelsName, Vector3Int volumeDimensions, Bounds dataBounds) Parameters Type Name Description float[] voxels Individual scalar values that make up the volume. All voxels are assumed to be the same size. string voxelsName Name of the variable the voxels are storing Vector3Int volumeDimensions Dimensions of the volume (number of steps in x, y, and z). Bounds dataBounds The bounds of volume in actual space. Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we create a volume from a series of voxels public class RawDatasetAdapterExample : MonoBehaviour { void Start() { // Define a 100x100x100 volume int volX = 100; int volY = 100; int volZ = 100; float[] voxels = new float[volX * volY * volZ]; // Populate voxels with \"data\" (x * y * z) int v = 0; for (int v = 0; v < voxels.Length; v++) { int z = v / (volX * volY); int vAdjusted = v - (z * volX * volY); int x = vAdjusted % volX; int y = vAdjusted / volX; voxels[v] = x * y * z; } Bounds b = new Bounds(Vector3.zero, Vector3.one); RawDataset abrVolume = RawDatasetAdapter.VoxelsToVolume(voxels, \"someData\", new Vector3Int(volX, volY, volZ), b); } } | Improve this Doc View Source VoxelsToVolume(float[][][], string, Vector3Int, Bounds) Convert a 3D grid into an ABR volume data object. There is assumed to be a single scalar variable described by the array voxels. Declaration public static RawDataset VoxelsToVolume(float[][][] voxels, string voxelsName, Vector3Int volumeDimensions, Bounds dataBounds) Parameters Type Name Description float[][][] voxels 3D voxels that make up the volume. All voxels are assumed to be the same size. string voxelsName Name of the variable the voxels are storing Vector3Int volumeDimensions Dimensions of the volume (number of steps in x, y, and z). Bounds dataBounds The bounds of volume in actual space. Returns Type Description RawDataset Remarks Note: None of these methods will actually import your data into ABR! These are simply a convenience for converting data into ABR format. After you call one of the RawDatasetAdapter methods, you MUST import it using ABREngine.Instance.Data.ImportRawDataset(...) to be able to use it in ABR! Examples In this example, we create a volume from a series of voxels public class RawDatasetAdapterExample : MonoBehaviour { void Start() { // Define a 100x100x100 volume int volX = 100; int volY = 100; int volZ = 100; float[][][] voxels = new float[volZ][][]; // Populate voxels with \"data\" (x * y * z) for (int z = 0; z < volZ; z++) { float[][] stack = new float[volY][]; for (int y = 0; y < volY; y++) { float[] col = new float[volX]; for (int x = 0; x < volX; x++) { col[x] = x * y * z; } stack[y] = col; } voxels[z] = stack; } Bounds b = new Bounds(Vector3.zero, Vector3.one); RawDataset abrVolume = RawDatasetAdapter.VoxelsToVolume(voxels, \"someData\", new Vector3Int(volX, volY, volZ), b); } }"
  },
  "api/IVLab.ABREngine.RawPrimitiveGradient.html": {
    "href": "api/IVLab.ABREngine.RawPrimitiveGradient.html",
    "title": "Class RawPrimitiveGradient | ABREngine",
    "keywords": "Class RawPrimitiveGradient Inheritance object RawPrimitiveGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class RawPrimitiveGradient Fields | Improve this Doc View Source points Declaration public List<float> points Field Value Type Description List<float> | Improve this Doc View Source values Declaration public List<string> values Field Value Type Description List<string>"
  },
  "api/IVLab.ABREngine.RawVisAssetGradient.html": {
    "href": "api/IVLab.ABREngine.RawVisAssetGradient.html",
    "title": "Class RawVisAssetGradient | ABREngine",
    "keywords": "Class RawVisAssetGradient Serializable version of the VisAsset gradients that interacts with state/schema. Each VisAsset type should be responsible for implementing their own conversion to/from this. Inheritance object RawVisAssetGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class RawVisAssetGradient Fields | Improve this Doc View Source gradientScale Serializable version of the VisAsset gradients that interacts with state/schema. Each VisAsset type should be responsible for implementing their own conversion to/from this. Declaration public string gradientScale Field Value Type Description string | Improve this Doc View Source gradientType Serializable version of the VisAsset gradients that interacts with state/schema. Each VisAsset type should be responsible for implementing their own conversion to/from this. Declaration public string gradientType Field Value Type Description string | Improve this Doc View Source points Serializable version of the VisAsset gradients that interacts with state/schema. Each VisAsset type should be responsible for implementing their own conversion to/from this. Declaration public float[] points Field Value Type Description float[] | Improve this Doc View Source uuid Serializable version of the VisAsset gradients that interacts with state/schema. Each VisAsset type should be responsible for implementing their own conversion to/from this. Declaration public string uuid Field Value Type Description string | Improve this Doc View Source visAssets Serializable version of the VisAsset gradients that interacts with state/schema. Each VisAsset type should be responsible for implementing their own conversion to/from this. Declaration public string[] visAssets Field Value Type Description string[] Methods | Improve this Doc View Source ToRaw<T>(IVisAssetGradient<T>) Convert from a regular VisAssetGradient to raw gradient for serialization/import/export/interfacing with other apps. Declaration public static RawVisAssetGradient ToRaw<T>(IVisAssetGradient<T> gradient) where T : IVisAsset Parameters Type Name Description IVisAssetGradient<T> gradient Returns Type Description RawVisAssetGradient Type Parameters Name Description T"
  },
  "api/IVLab.ABREngine.RenderHints.html": {
    "href": "api/IVLab.ABREngine.RenderHints.html",
    "title": "Class RenderHints | ABREngine",
    "keywords": "Class RenderHints Hints for rendering, such as whether a data impression should be hidden Inheritance object RenderHints Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class RenderHints Properties | Improve this Doc View Source GeometryChanged Has the impression been changed since the last render (needs to be re-rendered?) Declaration public bool GeometryChanged { get; set; } Property Value Type Description bool | Improve this Doc View Source PerIndexVisibility Index-level toggle to control visibility of individual parts of a data impression (e.g., points, lines). Declaration public BitArray PerIndexVisibility { get; set; } Property Value Type Description BitArray Remarks Index-level visibility may not be implemented for every data impression. Examples The following example shows basic usage of per-index visibility on a simple glyph data impression: public class IndexVisibilityExample : MonoBehaviour { void Start() { // Let's say the key data has 42 points. KeyData pointsKd = // some data we've imported // Create a layer for \"before\" points (blue) SimpleGlyphDataImpression di = new SimpleGlyphDataImpression(); di.keyData = // some key data we've loaded previously // Default everything to invisible (visible = false) di.RenderHints.PerIndexVisibility = new BitArray(42, false); // Register impression with the engine and render ABREngine.Instance.RegisterDataImpression(di); ABREngine.Instance.Render(); // Then, if we wanted to set some index to visible: di.RenderHints.PerIndexVisibility[10] = true; // Note: we need to tell the impression that its style has changed and // call Render() again di.RenderHints.StyleChanged = true; ABREngine.Instance.Render(); } } | Improve this Doc View Source StyleChanged Has the style of the impression been changed Declaration public bool StyleChanged { get; set; } Property Value Type Description bool | Improve this Doc View Source VisibilityChanged Has the visibility of the impression been changed (mesh renderer needs to be toggled) Declaration public bool VisibilityChanged { get; set; } Property Value Type Description bool | Improve this Doc View Source Visible Whether or not the impression is visible Declaration public bool Visible { get; set; } Property Value Type Description bool Methods | Improve this Doc View Source Copy() Hints for rendering, such as whether a data impression should be hidden Declaration public RenderHints Copy() Returns Type Description RenderHints | Improve this Doc View Source HasPerIndexVisibility() Whether or not the impression currently has per-index visibility Declaration public bool HasPerIndexVisibility() Returns Type Description bool"
  },
  "api/IVLab.ABREngine.ResourceStateFileLoader.html": {
    "href": "api/IVLab.ABREngine.ResourceStateFileLoader.html",
    "title": "Class ResourceStateFileLoader | ABREngine",
    "keywords": "Class ResourceStateFileLoader Load a state from any Resources folder within Unity (within any Package or Asset) Inheritance object ResourceStateFileLoader Implements IABRStateLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ResourceStateFileLoader : IABRStateLoader Constructors | Improve this Doc View Source ResourceStateFileLoader() Load a state from any Resources folder within Unity (within any Package or Asset) Declaration public ResourceStateFileLoader() Methods | Improve this Doc View Source GetState(string) Load a state based on some text (perhaps a JSON string, a file path, or URL) Declaration public JObject GetState(string fileName) Parameters Type Name Description string fileName Returns Type Description JObject | Improve this Doc View Source SaveState(string, string) Save a serialized JSON state with a particular name Declaration public void SaveState(string name, string serializedState) Parameters Type Name Description string name string serializedState Implements IABRStateLoader"
  },
  "api/IVLab.ABREngine.ResourceVisAssetFetcher.html": {
    "href": "api/IVLab.ABREngine.ResourceVisAssetFetcher.html",
    "title": "Class ResourceVisAssetFetcher | ABREngine",
    "keywords": "Class ResourceVisAssetFetcher Fetch VisAsset from a Resources folder (in an Asset or Package) Inheritance object ResourceVisAssetFetcher Implements IVisAssetFetcher Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ResourceVisAssetFetcher : IVisAssetFetcher Constructors | Improve this Doc View Source ResourceVisAssetFetcher() Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public ResourceVisAssetFetcher() Properties | Improve this Doc View Source ResourcePath Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public string ResourcePath { get; } Property Value Type Description string | Improve this Doc View Source VisAssetJson Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public string VisAssetJson { get; } Property Value Type Description string Methods | Improve this Doc View Source GetArtifactJson(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public JObject GetArtifactJson(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description JObject | Improve this Doc View Source GetArtifactJsonPath(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public string GetArtifactJsonPath(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description string | Improve this Doc View Source GetColormap(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public Colormap GetColormap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Colormap | Improve this Doc View Source GetColormapTexture(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public Texture2D GetColormapTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetGlyphGameObject(Guid, JObject) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public GameObject GetGlyphGameObject(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description GameObject | Improve this Doc View Source GetGlyphNormalMapTexture(Guid, JObject) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public Texture2D GetGlyphNormalMapTexture(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description Texture2D | Improve this Doc View Source GetGlyphPreview(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public Texture2D GetGlyphPreview(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetLineTexture(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public Texture2D GetLineTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceNormalMap(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public Texture2D GetSurfaceNormalMap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceTexture(Guid) Fetch VisAsset from a Resources folder (in an Asset or Package) Declaration public Texture2D GetSurfaceTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D Implements IVisAssetFetcher"
  },
  "api/IVLab.ABREngine.ResourcesDataLoader.html": {
    "href": "api/IVLab.ABREngine.ResourcesDataLoader.html",
    "title": "Class ResourcesDataLoader | ABREngine",
    "keywords": "Class ResourcesDataLoader Load data from resources folder. NOTE: The actual data files (.bin) must have their file extension changed to .txt in order to be recognized. When data are imported, the identity of each is lost so we must guess which is which - currently guessing the larger of the two files is the \"Data\" and the smaller is \"Metadata\". Inheritance object ResourcesDataLoader Implements IDataLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ResourcesDataLoader : IDataLoader Methods | Improve this Doc View Source LoadData(string) Load data specified by dataPath from a particular source Declaration public RawDataset LoadData(string dataPath) Parameters Type Name Description string dataPath Returns Type Description RawDataset Implements IDataLoader"
  },
  "api/IVLab.ABREngine.ScalarDataVariable.html": {
    "href": "api/IVLab.ABREngine.ScalarDataVariable.html",
    "title": "Class ScalarDataVariable | ABREngine",
    "keywords": "Class ScalarDataVariable Inheritance object ScalarDataVariable Implements IDataVariable<float> IABRInput IHasDataset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class ScalarDataVariable : IDataVariable<float>, IABRInput, IHasDataset Properties | Improve this Doc View Source CustomizedRange Have this var's ranges been customized? Declaration public bool CustomizedRange { get; set; } Property Value Type Description bool | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre | Improve this Doc View Source OriginalRange Save the original range in case the user wants to reset it later. Declaration public DataRange<float> OriginalRange { get; set; } Property Value Type Description DataRange<float> | Improve this Doc View Source Path The DataPath that represents this variable Declaration public string Path { get; } Property Value Type Description string | Improve this Doc View Source Range Range is calculated by the DataManager when it imports a new dataset. Range is calculated from the smallest/largest values encountered across every instance of this variable, across all datasets. Declaration public DataRange<float> Range { get; set; } Property Value Type Description DataRange<float> | Improve this Doc View Source SpecificRanges Dictionary of keyData paths that have specific ranges for this variable Declaration public Dictionary<string, DataRange<float>> SpecificRanges { get; set; } Property Value Type Description Dictionary<string, DataRange<float>> Methods | Improve this Doc View Source GetArray(KeyData) Get the actual data values in the context of this particular Key Data object Declaration public float[] GetArray(KeyData keyData) Parameters Type Name Description KeyData keyData Returns Type Description float[] | Improve this Doc View Source GetDataset() Declaration public Dataset GetDataset() Returns Type Description Dataset | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput | Improve this Doc View Source IsPartOf(KeyData) Determine if this variable is a part of the key data Declaration public bool IsPartOf(KeyData keyData) Parameters Type Name Description KeyData keyData Returns Type Description bool Implements IDataVariable<T> IABRInput IHasDataset"
  },
  "api/IVLab.ABREngine.SerializableFloatArray.html": {
    "href": "api/IVLab.ABREngine.SerializableFloatArray.html",
    "title": "Class SerializableFloatArray | ABREngine",
    "keywords": "Class SerializableFloatArray Inheritance object SerializableFloatArray Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Serializable] public class SerializableFloatArray Fields | Improve this Doc View Source array Declaration [SerializeField] public float[] array Field Value Type Description float[]"
  },
  "api/IVLab.ABREngine.SerializableVectorArray.html": {
    "href": "api/IVLab.ABREngine.SerializableVectorArray.html",
    "title": "Class SerializableVectorArray | ABREngine",
    "keywords": "Class SerializableVectorArray Inheritance object SerializableVectorArray Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Serializable] public class SerializableVectorArray Fields | Improve this Doc View Source array Declaration [SerializeField] public Vector3[] array Field Value Type Description Vector3[]"
  },
  "api/IVLab.ABREngine.SimpleGlyphDataImpression.html": {
    "href": "api/IVLab.ABREngine.SimpleGlyphDataImpression.html",
    "title": "Class SimpleGlyphDataImpression | ABREngine",
    "keywords": "Class SimpleGlyphDataImpression A \"Glyphs\" data impression that uses hand-sculpted geometry to depict point data. Inheritance object Object Component Behaviour MonoBehaviour DataImpression SimpleGlyphDataImpression Implements IHasDataset IHasKeyData ICoordSpaceConverter Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [ABRPlateType(\"Glyphs\")] public class SimpleGlyphDataImpression : DataImpression, IHasDataset, IHasKeyData, ICoordSpaceConverter Examples An example of creating a single glyph data impression and setting its colormap, color variable, and glyph could be: SimpleGlyphDataImpression gi = new SimpleGlyphDataImpression(); gi.keyData = points; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.glyph = glyph; ABREngine.Instance.RegisterDataImpression(gi); Constructors | Improve this Doc View Source SimpleGlyphDataImpression() A \"Glyphs\" data impression that uses hand-sculpted geometry to depict point data. Declaration protected SimpleGlyphDataImpression() Examples An example of creating a single glyph data impression and setting its colormap, color variable, and glyph could be: SimpleGlyphDataImpression gi = new SimpleGlyphDataImpression(); gi.keyData = points; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.glyph = glyph; ABREngine.Instance.RegisterDataImpression(gi); Fields | Improve this Doc View Source LayerName Define the layer name for this Data Impression Declaration protected const string LayerName = \"ABR_Glyph\" Field Value Type Description string Remarks Warning New Data Impressions should define a const string \"LayerName\" which corresponds to a Layer in Unity's Layer manager. | Improve this Doc View Source colorVariable Scalar color variable applied to each point of this data impression. This example switches between X-axis monotonically increasing and Y-axis monotonically increasing. Declaration [ABRInput(\"Color Variable\", UpdateLevel.Style)] public ScalarDataVariable colorVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source colormap Colormap applied to the colorVariable. This example switches between a linear white-to-green colormap and a linear black-to-white colormap. Declaration [ABRInput(\"Colormap\", UpdateLevel.Style)] public IColormapVisAsset colormap Field Value Type Description IColormapVisAsset | Improve this Doc View Source forceOutlineColor Force the use of outlineColor even if there's a colormap applied to the data. This example alternates between a white-to-green linear colormap (false) and a solid purple-blue (true) Declaration [ABRInput(\"Force Outline Color\", UpdateLevel.Geometry)] public BooleanPrimitive forceOutlineColor Field Value Type Description BooleanPrimitive | Improve this Doc View Source forwardVariable \"Forward\" direction that glyphs should point in. Declaration [ABRInput(\"Forward Variable\", UpdateLevel.Geometry)] public VectorDataVariable forwardVariable Field Value Type Description VectorDataVariable | Improve this Doc View Source glyph What glyph(s) to apply to the dataset. This can also take a GlyphGradient. This example alternates between spherical and thin cylindrical glyphs. Declaration [ABRInput(\"Glyph\", UpdateLevel.Geometry)] public IGlyphVisAsset glyph Field Value Type Description IGlyphVisAsset | Improve this Doc View Source glyphDensity Tweak the density of glyphs - subsamples the existing glyphs uniformly. Declaration [ABRInput(\"Glyph Density\", UpdateLevel.Style)] public PercentPrimitive glyphDensity Field Value Type Description PercentPrimitive | Improve this Doc View Source glyphLod Level of detail to use for glyph rendering (higher number = lower level of detail; most glyphs have 3 LODs). Default to using the second-highest level of detail, but you may need to adjust for performance reasons. Declaration [ABRInput(\"Glyph Level Of Detail\", UpdateLevel.Geometry)] public IntegerPrimitive glyphLod Field Value Type Description IntegerPrimitive | Improve this Doc View Source glyphSize Adjust the size of the glyphs (in Unity-space meters). Declaration [ABRInput(\"Glyph Size\", UpdateLevel.Style)] public LengthPrimitive glyphSize Field Value Type Description LengthPrimitive | Improve this Doc View Source glyphVariable Variable used to determine which glyph to render at which data values. This only has any effect if glyph is a GlyphGradient. Declaration [ABRInput(\"Glyph Variable\", UpdateLevel.Style)] public ScalarDataVariable glyphVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source keyData A \"Glyphs\" data impression that uses hand-sculpted geometry to depict point data. Declaration [ABRInput(\"Key Data\", UpdateLevel.Geometry)] public KeyData keyData Field Value Type Description KeyData Examples An example of creating a single glyph data impression and setting its colormap, color variable, and glyph could be: SimpleGlyphDataImpression gi = new SimpleGlyphDataImpression(); gi.keyData = points; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.glyph = glyph; ABREngine.Instance.RegisterDataImpression(gi); | Improve this Doc View Source nanColor Override the color used for NaN values in this data impression. If not supplied, will use the defaultNanColor. Declaration [ABRInput(\"NaN Color\", UpdateLevel.Style)] public IColormapVisAsset nanColor Field Value Type Description IColormapVisAsset | Improve this Doc View Source outlineColor Color of the outline Declaration [ABRInput(\"Outline Color\", UpdateLevel.Geometry)] public IColormapVisAsset outlineColor Field Value Type Description IColormapVisAsset | Improve this Doc View Source outlineWidth Width (in Unity world coords) of the outline Declaration [ABRInput(\"Outline Width\", UpdateLevel.Geometry)] public LengthPrimitive outlineWidth Field Value Type Description LengthPrimitive | Improve this Doc View Source showOutline Show/hide outline on this data impression Declaration [ABRInput(\"Show Outline\", UpdateLevel.Geometry)] public BooleanPrimitive showOutline Field Value Type Description BooleanPrimitive | Improve this Doc View Source upVariable \"Up\" direction that glyphs should point in. Declaration [ABRInput(\"Up Variable\", UpdateLevel.Geometry)] public VectorDataVariable upVariable Field Value Type Description VectorDataVariable | Improve this Doc View Source useRandomOrientation Use random forward/up directions when no Vector variables are applied for forward/up. Declaration [ABRInput(\"Use Random Orientation\", UpdateLevel.Geometry)] public BooleanPrimitive useRandomOrientation Field Value Type Description BooleanPrimitive Properties | Improve this Doc View Source MaterialNames Name of the material to use to render this DataImpression Declaration protected override string[] MaterialNames { get; } Property Value Type Description string[] Overrides DataImpression.MaterialNames Methods | Improve this Doc View Source Cleanup() When this data impression is done being used, clean up after itself if necessary. This method may need access to the GameObject the data impression is applied to. Declaration public override void Cleanup() Overrides DataImpression.Cleanup() | Improve this Doc View Source ComputeGeometry() RENDERING STEP 1. Populate rendering information (Geometry) for the DataImpression. This is triggered by the DataImpressionGroup when an Geometry happens. This step is generally expensive. Declaration public override void ComputeGeometry() Overrides DataImpression.ComputeGeometry() | Improve this Doc View Source GetDataset() By default, there's no dataset. DataImpressions should only have one dataset, and it's up to them individually to enforce that they correctly implement this. Declaration public override Dataset GetDataset() Returns Type Description Dataset Overrides DataImpression.GetDataset() | Improve this Doc View Source GetKeyData() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override KeyData GetKeyData() Returns Type Description KeyData Overrides DataImpression.GetKeyData() | Improve this Doc View Source GetKeyDataTopology() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override DataTopology GetKeyDataTopology() Returns Type Description DataTopology Overrides DataImpression.GetKeyDataTopology() | Improve this Doc View Source SetKeyData(KeyData) By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override void SetKeyData(KeyData kd) Parameters Type Name Description KeyData kd Overrides DataImpression.SetKeyData(KeyData) | Improve this Doc View Source SetupGameObject() RENDERING STEP 2. Take geometric rendering information computed in ComputeGeometry() and sets up proper game object(s) and components for this Data Impression. Transfers geometry into Unity format (e.g. a Mesh). No geometric computations should happen in this method, and it should generally be lightweight. Declaration public override void SetupGameObject() Overrides DataImpression.SetupGameObject() | Improve this Doc View Source UpdateStyling() RENDERING STEP 3. Update the \"styling\" of an impression by sending each styling parameter to the shader. Occasionally will need to set per-vertex items like transforms. This method should generally be lightweight. Declaration public override void UpdateStyling() Overrides DataImpression.UpdateStyling() | Improve this Doc View Source UpdateVisibility() RENDERING STEP 4. Update the visibility of an impression (hidden or shown) Declaration public override void UpdateVisibility() Overrides DataImpression.UpdateVisibility() Implements IHasDataset IHasKeyData ICoordSpaceConverter"
  },
  "api/IVLab.ABREngine.SimpleLineDataImpression.html": {
    "href": "api/IVLab.ABREngine.SimpleLineDataImpression.html",
    "title": "Class SimpleLineDataImpression | ABREngine",
    "keywords": "Class SimpleLineDataImpression A \"Lines\" data impression that uses hand-drawn line textures to depict line/flow data. Inheritance object Object Component Behaviour MonoBehaviour DataImpression SimpleLineDataImpression Implements IHasKeyData ICoordSpaceConverter IHasDataset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [ABRPlateType(\"Ribbons\")] public class SimpleLineDataImpression : DataImpression, IHasKeyData, ICoordSpaceConverter, IHasDataset Examples An example of creating a single line data impression and setting its colormap, color variable, and line texture could be: SimpleLineDataImpression gi = new SimpleLineDataImpression(); gi.keyData = lines; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.lineTexture = line; ABREngine.Instance.RegisterDataImpression(gi); Constructors | Improve this Doc View Source SimpleLineDataImpression() A \"Lines\" data impression that uses hand-drawn line textures to depict line/flow data. Declaration protected SimpleLineDataImpression() Examples An example of creating a single line data impression and setting its colormap, color variable, and line texture could be: SimpleLineDataImpression gi = new SimpleLineDataImpression(); gi.keyData = lines; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.lineTexture = line; ABREngine.Instance.RegisterDataImpression(gi); Fields | Improve this Doc View Source LayerName Define the layer name for this Data Impression Declaration protected const string LayerName = \"ABR_Line\" Field Value Type Description string Remarks Warning New Data Impressions should define a const string \"LayerName\" which corresponds to a Layer in Unity's Layer manager. | Improve this Doc View Source averageCount Number of \"averaging\" samples taken across the line for a smoothing effect. This example ranges from 0 to 50. Declaration [ABRInput(\"Ribbon Smooth\", UpdateLevel.Geometry)] public IntegerPrimitive averageCount Field Value Type Description IntegerPrimitive | Improve this Doc View Source colorVariable Scalar color variable applied to each point on the line of this data impression. This example switches between X-axis monotonically increasing and Y-axis monotonically increasing. Declaration [ABRInput(\"Color Variable\", UpdateLevel.Style)] public ScalarDataVariable colorVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source colormap Colormap applied to the colorVariable. This example switches between a linear white-to-green colormap and a linear black-to-white colormap. Declaration [ABRInput(\"Colormap\", UpdateLevel.Style)] public IColormapVisAsset colormap Field Value Type Description IColormapVisAsset | Improve this Doc View Source defaultCurveDirection Change the default curvature axis (if there are no existing tangents on the curve, this axis will be used) Declaration public Vector3 defaultCurveDirection Field Value Type Description Vector3 Remarks NOTE: This input mostly changes behaviour at the ends of ribbons, unless your ribbon is perfectly straight. (This setting exists because of perfectly straight ribbons which the existing ribbon has trouble with). | Improve this Doc View Source keyData A \"Lines\" data impression that uses hand-drawn line textures to depict line/flow data. Declaration [ABRInput(\"Key Data\", UpdateLevel.Geometry)] public KeyData keyData Field Value Type Description KeyData Examples An example of creating a single line data impression and setting its colormap, color variable, and line texture could be: SimpleLineDataImpression gi = new SimpleLineDataImpression(); gi.keyData = lines; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.lineTexture = line; ABREngine.Instance.RegisterDataImpression(gi); | Improve this Doc View Source lineTexture Texture applied to the line. Light areas on the texture are discarded, dark areas are kept. Can also be a LineTextureGradient Declaration [ABRInput(\"Texture\", UpdateLevel.Style)] public ILineTextureVisAsset lineTexture Field Value Type Description ILineTextureVisAsset | Improve this Doc View Source lineTextureVariable Scalar variable used to vary the line texture across its length. Declaration [ABRInput(\"Texture Variable\", UpdateLevel.Style)] public ScalarDataVariable lineTextureVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source lineWidth Width of the line, in Unity world units. Declaration [ABRInput(\"Ribbon Width\", UpdateLevel.Geometry)] public LengthPrimitive lineWidth Field Value Type Description LengthPrimitive | Improve this Doc View Source nanColor Override the color used for NaN values in this data impression. If not supplied, will use the defaultNanColor. Declaration [ABRInput(\"NaN Color\", UpdateLevel.Style)] public IColormapVisAsset nanColor Field Value Type Description IColormapVisAsset | Improve this Doc View Source nanLineTexture Override the line texture used for NaN values in this data impression. If not supplied, will use the defaultNanLine. Declaration [ABRInput(\"NaN Texture\", UpdateLevel.Style)] public ILineTextureVisAsset nanLineTexture Field Value Type Description ILineTextureVisAsset | Improve this Doc View Source ribbonBrightness Manually adjust the brightness of the ribbon regardless of lighting in the scene. Declaration [ABRInput(\"Ribbon Brightness\", UpdateLevel.Style)] public PercentPrimitive ribbonBrightness Field Value Type Description PercentPrimitive | Improve this Doc View Source ribbonCurveAngle Subtly adjust the lighting by varying the lighting normal of the ribbon Declaration [ABRInput(\"Ribbon Curve\", UpdateLevel.Geometry)] public AnglePrimitive ribbonCurveAngle Field Value Type Description AnglePrimitive | Improve this Doc View Source ribbonRotationAngle Rotate the ribbon along its central axis. This example goes from 0 degrees to 90 degrees. Declaration [ABRInput(\"Ribbon Rotation\", UpdateLevel.Geometry)] public AnglePrimitive ribbonRotationAngle Field Value Type Description AnglePrimitive | Improve this Doc View Source textureCutoff \"Cutoff\" point for discarding portions of the line. The cutoff is between 0% (fully light) and 100% (fully dark). In practice, this is performing a threshold filter. Declaration [ABRInput(\"Texture Cutoff\", UpdateLevel.Style)] public PercentPrimitive textureCutoff Field Value Type Description PercentPrimitive Remarks NOTE: This input will have no effect if there's no lineTexture applied. It has the most effect on textures that are not fully black/white. Properties | Improve this Doc View Source MaterialNames Name of the material to use to render this DataImpression Declaration protected override string[] MaterialNames { get; } Property Value Type Description string[] Overrides DataImpression.MaterialNames Methods | Improve this Doc View Source ComputeGeometry() RENDERING STEP 1. Populate rendering information (Geometry) for the DataImpression. This is triggered by the DataImpressionGroup when an Geometry happens. This step is generally expensive. Declaration public override void ComputeGeometry() Overrides DataImpression.ComputeGeometry() | Improve this Doc View Source GetDataset() By default, there's no dataset. DataImpressions should only have one dataset, and it's up to them individually to enforce that they correctly implement this. Declaration public override Dataset GetDataset() Returns Type Description Dataset Overrides DataImpression.GetDataset() | Improve this Doc View Source GetKeyData() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override KeyData GetKeyData() Returns Type Description KeyData Overrides DataImpression.GetKeyData() | Improve this Doc View Source GetKeyDataTopology() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override DataTopology GetKeyDataTopology() Returns Type Description DataTopology Overrides DataImpression.GetKeyDataTopology() | Improve this Doc View Source SetKeyData(KeyData) By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override void SetKeyData(KeyData kd) Parameters Type Name Description KeyData kd Overrides DataImpression.SetKeyData(KeyData) | Improve this Doc View Source SetupGameObject() RENDERING STEP 2. Take geometric rendering information computed in ComputeGeometry() and sets up proper game object(s) and components for this Data Impression. Transfers geometry into Unity format (e.g. a Mesh). No geometric computations should happen in this method, and it should generally be lightweight. Declaration public override void SetupGameObject() Overrides DataImpression.SetupGameObject() | Improve this Doc View Source UpdateStyling() RENDERING STEP 3. Update the \"styling\" of an impression by sending each styling parameter to the shader. Occasionally will need to set per-vertex items like transforms. This method should generally be lightweight. Declaration public override void UpdateStyling() Overrides DataImpression.UpdateStyling() | Improve this Doc View Source UpdateVisibility() RENDERING STEP 4. Update the visibility of an impression (hidden or shown) Declaration public override void UpdateVisibility() Overrides DataImpression.UpdateVisibility() Implements IHasKeyData ICoordSpaceConverter IHasDataset"
  },
  "api/IVLab.ABREngine.SimpleLineRenderInfo.html": {
    "href": "api/IVLab.ABREngine.SimpleLineRenderInfo.html",
    "title": "Class SimpleLineRenderInfo | ABREngine",
    "keywords": "Class SimpleLineRenderInfo Inheritance object SimpleLineRenderInfo Implements IDataImpressionRenderInfo Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class SimpleLineRenderInfo : IDataImpressionRenderInfo Fields | Improve this Doc View Source indices Declaration public int[][] indices Field Value Type Description int[][] | Improve this Doc View Source normals Declaration public Vector3[][] normals Field Value Type Description Vector3[][] | Improve this Doc View Source scalars Declaration public Color[][] scalars Field Value Type Description Color[][] | Improve this Doc View Source uvs Declaration public Vector2[][] uvs Field Value Type Description Vector2[][] | Improve this Doc View Source vertices Declaration public Vector3[][] vertices Field Value Type Description Vector3[][] Implements IDataImpressionRenderInfo"
  },
  "api/IVLab.ABREngine.SimpleSurfaceDataImpression.html": {
    "href": "api/IVLab.ABREngine.SimpleSurfaceDataImpression.html",
    "title": "Class SimpleSurfaceDataImpression | ABREngine",
    "keywords": "Class SimpleSurfaceDataImpression A \"Surfaces\" data impression that uses hand-drawn textures and color to show surface data. Inheritance object Object Component Behaviour MonoBehaviour DataImpression SimpleSurfaceDataImpression Implements IHasDataset IHasKeyData ICoordSpaceConverter Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [ABRPlateType(\"Surfaces\")] public class SimpleSurfaceDataImpression : DataImpression, IHasDataset, IHasKeyData, ICoordSpaceConverter Examples An example of creating a single surface data impression and setting its colormap, color variable, and texture could be: SimpleSurfaceDataImpression gi = new SimpleSurfaceDataImpression(); gi.keyData = surfs; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.lineTexture = tex; ABREngine.Instance.RegisterDataImpression(gi); Constructors | Improve this Doc View Source SimpleSurfaceDataImpression() A \"Surfaces\" data impression that uses hand-drawn textures and color to show surface data. Declaration protected SimpleSurfaceDataImpression() Examples An example of creating a single surface data impression and setting its colormap, color variable, and texture could be: SimpleSurfaceDataImpression gi = new SimpleSurfaceDataImpression(); gi.keyData = surfs; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.lineTexture = tex; ABREngine.Instance.RegisterDataImpression(gi); Fields | Improve this Doc View Source LayerName Define the layer name for this Data Impression Declaration protected const string LayerName = \"ABR_Surface\" Field Value Type Description string Remarks Warning New Data Impressions should define a const string \"LayerName\" which corresponds to a Layer in Unity's Layer manager. | Improve this Doc View Source colorVariable Scalar color variable applied to each point of this data impression. This example switches between X-axis monotonically increasing and Y-axis monotonically increasing. Declaration [ABRInput(\"Color Variable\", UpdateLevel.Style)] public ScalarDataVariable colorVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source colormap Colormap applied to the colorVariable. This example switches between a linear white-to-green colormap and a linear black-to-white colormap. Declaration [ABRInput(\"Colormap\", UpdateLevel.Style)] public IColormapVisAsset colormap Field Value Type Description IColormapVisAsset | Improve this Doc View Source keyData A \"Surfaces\" data impression that uses hand-drawn textures and color to show surface data. Declaration [ABRInput(\"Key Data\", UpdateLevel.Geometry)] public KeyData keyData Field Value Type Description KeyData Examples An example of creating a single surface data impression and setting its colormap, color variable, and texture could be: SimpleSurfaceDataImpression gi = new SimpleSurfaceDataImpression(); gi.keyData = surfs; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.lineTexture = tex; ABREngine.Instance.RegisterDataImpression(gi); | Improve this Doc View Source nanColor Override the color used for NaN values in this data impression. If not supplied, will use the defaultNanColor. Declaration [ABRInput(\"NaN Color\", UpdateLevel.Style)] public IColormapVisAsset nanColor Field Value Type Description IColormapVisAsset | Improve this Doc View Source nanPattern Override the pattern/texture used for NaN values in this data impression. If not supplied, will use the defaultNanTexture. Declaration [ABRInput(\"NaN Pattern\", UpdateLevel.Style)] public ISurfaceTextureVisAsset nanPattern Field Value Type Description ISurfaceTextureVisAsset | Improve this Doc View Source onlyOutline ONLY show the outline (don't show the actual surface) Declaration [ABRInput(\"Show Only Outline\", UpdateLevel.Style)] public BooleanPrimitive onlyOutline Field Value Type Description BooleanPrimitive | Improve this Doc View Source opacity Opacity of the surface - how see-through the surface is. Declaration [ABRInput(\"Opacity\", UpdateLevel.Style)] public PercentPrimitive opacity Field Value Type Description PercentPrimitive | Improve this Doc View Source outlineColor Color of the outline Declaration [ABRInput(\"Outline Color\", UpdateLevel.Style)] public IColormapVisAsset outlineColor Field Value Type Description IColormapVisAsset | Improve this Doc View Source outlineWidth Width (in Unity world coords) of the outline Declaration [ABRInput(\"Outline Width\", UpdateLevel.Style)] public LengthPrimitive outlineWidth Field Value Type Description LengthPrimitive | Improve this Doc View Source pattern The pattern/texture applied to the surface - can also be a SurfaceTextureGradient. Declaration [ABRInput(\"Pattern\", UpdateLevel.Style)] public ISurfaceTextureVisAsset pattern Field Value Type Description ISurfaceTextureVisAsset | Improve this Doc View Source patternIntensity Edit the intensity which the pattern is overlaid on the surface. 0% is not present at all, 10% is very faint, and 100% is full overlay. Declaration [ABRInput(\"Pattern Intensity\", UpdateLevel.Style)] public PercentPrimitive patternIntensity Field Value Type Description PercentPrimitive | Improve this Doc View Source patternSaturation Edit the saturation of the pattern(s) - 100% is full color, 0% is full grayscale. Declaration [ABRInput(\"Pattern Saturation\", UpdateLevel.Style)] public PercentPrimitive patternSaturation Field Value Type Description PercentPrimitive | Improve this Doc View Source patternSeamBlend Percentage to \"blend\" textures together at the seams to minimize the tiling effect. This example goes from 0% seam blend to 20% seam blend. Declaration [ABRInput(\"Pattern Seam Blend\", UpdateLevel.Style)] public PercentPrimitive patternSeamBlend Field Value Type Description PercentPrimitive | Improve this Doc View Source patternSize How large, in Unity meters, to make each \"tile\" of the texture/pattern on the surface. This example goes from 0.5m to 1m. Declaration [ABRInput(\"Pattern Size\", UpdateLevel.Style)] public LengthPrimitive patternSize Field Value Type Description LengthPrimitive | Improve this Doc View Source patternVariable Scalar variable used to vary the pattern across the surface. Declaration [ABRInput(\"Pattern Variable\", UpdateLevel.Style)] public ScalarDataVariable patternVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source showOutline Show/hide outline on this data impression (show the outline AND the actual surface) Declaration [ABRInput(\"Show Outline\", UpdateLevel.Style)] public BooleanPrimitive showOutline Field Value Type Description BooleanPrimitive Remarks NOTE: Outlines work best on convex objects. The wavelet in this example shows some artifacts due to its concavity. Properties | Improve this Doc View Source MaterialNames Name of the material to use to render this DataImpression Declaration protected override string[] MaterialNames { get; } Property Value Type Description string[] Overrides DataImpression.MaterialNames Methods | Improve this Doc View Source ComputeGeometry() RENDERING STEP 1. Populate rendering information (Geometry) for the DataImpression. This is triggered by the DataImpressionGroup when an Geometry happens. This step is generally expensive. Declaration public override void ComputeGeometry() Overrides DataImpression.ComputeGeometry() | Improve this Doc View Source GetDataset() By default, there's no dataset. DataImpressions should only have one dataset, and it's up to them individually to enforce that they correctly implement this. Declaration public override Dataset GetDataset() Returns Type Description Dataset Overrides DataImpression.GetDataset() | Improve this Doc View Source GetKeyData() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override KeyData GetKeyData() Returns Type Description KeyData Overrides DataImpression.GetKeyData() | Improve this Doc View Source GetKeyDataTopology() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override DataTopology GetKeyDataTopology() Returns Type Description DataTopology Overrides DataImpression.GetKeyDataTopology() | Improve this Doc View Source SetKeyData(KeyData) By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override void SetKeyData(KeyData kd) Parameters Type Name Description KeyData kd Overrides DataImpression.SetKeyData(KeyData) | Improve this Doc View Source SetupGameObject() RENDERING STEP 2. Take geometric rendering information computed in ComputeGeometry() and sets up proper game object(s) and components for this Data Impression. Transfers geometry into Unity format (e.g. a Mesh). No geometric computations should happen in this method, and it should generally be lightweight. Declaration public override void SetupGameObject() Overrides DataImpression.SetupGameObject() | Improve this Doc View Source UpdateStyling() RENDERING STEP 3. Update the \"styling\" of an impression by sending each styling parameter to the shader. Occasionally will need to set per-vertex items like transforms. This method should generally be lightweight. Declaration public override void UpdateStyling() Overrides DataImpression.UpdateStyling() | Improve this Doc View Source UpdateVisibility() RENDERING STEP 4. Update the visibility of an impression (hidden or shown) Declaration public override void UpdateVisibility() Overrides DataImpression.UpdateVisibility() Implements IHasDataset IHasKeyData ICoordSpaceConverter"
  },
  "api/IVLab.ABREngine.SimpleSurfaceRenderInfo.html": {
    "href": "api/IVLab.ABREngine.SimpleSurfaceRenderInfo.html",
    "title": "Class SimpleSurfaceRenderInfo | ABREngine",
    "keywords": "Class SimpleSurfaceRenderInfo Inheritance object SimpleSurfaceRenderInfo Implements IDataImpressionRenderInfo Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class SimpleSurfaceRenderInfo : IDataImpressionRenderInfo Fields | Improve this Doc View Source indices Declaration public int[] indices Field Value Type Description int[] | Improve this Doc View Source normals Declaration public Vector3[] normals Field Value Type Description Vector3[] | Improve this Doc View Source scalars Declaration public Color[] scalars Field Value Type Description Color[] | Improve this Doc View Source topology Declaration public DataTopology topology Field Value Type Description DataTopology | Improve this Doc View Source vertices Declaration public Vector3[] vertices Field Value Type Description Vector3[] Implements IDataImpressionRenderInfo"
  },
  "api/IVLab.ABREngine.SimpleVolumeDataImpression.html": {
    "href": "api/IVLab.ABREngine.SimpleVolumeDataImpression.html",
    "title": "Class SimpleVolumeDataImpression | ABREngine",
    "keywords": "Class SimpleVolumeDataImpression A \"Volumes\" data impression that uses a user-defined transfer (opacity) map and a colormap to show volumetric data. Inheritance object Object Component Behaviour MonoBehaviour DataImpression SimpleVolumeDataImpression Implements IHasDataset IHasKeyData ICoordSpaceConverter Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [ABRPlateType(\"Volumes\")] public class SimpleVolumeDataImpression : DataImpression, IHasDataset, IHasKeyData, ICoordSpaceConverter Examples An example of creating a single volume data impression and setting its colormap and opacity map could be: SimpleVolumeDataImpression gi = new SimpleVolumeDataImpression(); gi.keyData = volume; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.opacityMap = PrimitiveGradient.Default(); ABREngine.Instance.RegisterDataImpression(gi); Constructors | Improve this Doc View Source SimpleVolumeDataImpression() A \"Volumes\" data impression that uses a user-defined transfer (opacity) map and a colormap to show volumetric data. Declaration protected SimpleVolumeDataImpression() Examples An example of creating a single volume data impression and setting its colormap and opacity map could be: SimpleVolumeDataImpression gi = new SimpleVolumeDataImpression(); gi.keyData = volume; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.opacityMap = PrimitiveGradient.Default(); ABREngine.Instance.RegisterDataImpression(gi); Fields | Improve this Doc View Source LayerName Define the layer name for this Data Impression Declaration protected const string LayerName = \"ABR_Volume\" Field Value Type Description string Remarks Warning New Data Impressions should define a const string \"LayerName\" which corresponds to a Layer in Unity's Layer manager. | Improve this Doc View Source colorVariable Scalar color variable applied to each voxel of this data impression affects both the colormap and the opacitymap. Declaration [ABRInput(\"Color Variable\", UpdateLevel.Geometry)] public ScalarDataVariable colorVariable Field Value Type Description ScalarDataVariable | Improve this Doc View Source colormap Colormap applied to the colorVariable. This example switches between a linear white-to-green colormap and a linear black-to-white colormap. Declaration [ABRInput(\"Colormap\", UpdateLevel.Style)] public IColormapVisAsset colormap Field Value Type Description IColormapVisAsset | Improve this Doc View Source keyData A \"Volumes\" data impression that uses a user-defined transfer (opacity) map and a colormap to show volumetric data. Declaration [ABRInput(\"Key Data\", UpdateLevel.Geometry)] public KeyData keyData Field Value Type Description KeyData Examples An example of creating a single volume data impression and setting its colormap and opacity map could be: SimpleVolumeDataImpression gi = new SimpleVolumeDataImpression(); gi.keyData = volume; gi.colorVariable = yAxis; gi.colormap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; gi.opacityMap = PrimitiveGradient.Default(); ABREngine.Instance.RegisterDataImpression(gi); | Improve this Doc View Source nanColor Override the color used for NaN values in this data impression. If not supplied, will use the defaultNanColor. Declaration [ABRInput(\"NaN Color\", UpdateLevel.Style)] public IColormapVisAsset nanColor Field Value Type Description IColormapVisAsset | Improve this Doc View Source nanOpacity Override the color used for NaN values in this data impression. If not supplied, will be 0% opacity. Declaration public PercentPrimitive nanOpacity Field Value Type Description PercentPrimitive | Improve this Doc View Source opacitymap The real power of volume rendering is in the opacity map, or transfer function. For example, with a \"spike\" transfer function changing over time like this, we can achieve a sort of contour or isosurface scanning through the volume. Declaration [ABRInput(\"Opacitymap\", UpdateLevel.Style)] public PrimitiveGradient opacitymap Field Value Type Description PrimitiveGradient | Improve this Doc View Source volumeBrightness Brightness multiplier for the entire volume, irrespective of lighting. Declaration [ABRInput(\"Volume Brightness\", UpdateLevel.Style)] public PercentPrimitive volumeBrightness Field Value Type Description PercentPrimitive | Improve this Doc View Source volumeLighting Should the current scene's lighting affect the volume or not? Declaration [ABRInput(\"Volume Lighting\", UpdateLevel.Style)] public BooleanPrimitive volumeLighting Field Value Type Description BooleanPrimitive Remarks Lighting is often useful for understanding 3D structures and creating atmospheric effects, but may not be useful for nitty-gritty data interpretation. | Improve this Doc View Source volumeOpacityMultiplier Opacity multiplier for the entire volume; gets multiplied on top of the opacitymap. Declaration [ABRInput(\"Volume Opacity Multiplier\", UpdateLevel.Style)] public PercentPrimitive volumeOpacityMultiplier Field Value Type Description PercentPrimitive Properties | Improve this Doc View Source MaterialNames Name of the material to use to render this DataImpression Declaration protected override string[] MaterialNames { get; } Property Value Type Description string[] Overrides DataImpression.MaterialNames Methods | Improve this Doc View Source ComputeGeometry() RENDERING STEP 1. Populate rendering information (Geometry) for the DataImpression. This is triggered by the DataImpressionGroup when an Geometry happens. This step is generally expensive. Declaration public override void ComputeGeometry() Overrides DataImpression.ComputeGeometry() | Improve this Doc View Source GetDataset() By default, there's no dataset. DataImpressions should only have one dataset, and it's up to them individually to enforce that they correctly implement this. Declaration public override Dataset GetDataset() Returns Type Description Dataset Overrides DataImpression.GetDataset() | Improve this Doc View Source GetKeyData() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override KeyData GetKeyData() Returns Type Description KeyData Overrides DataImpression.GetKeyData() | Improve this Doc View Source GetKeyDataTopology() By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override DataTopology GetKeyDataTopology() Returns Type Description DataTopology Overrides DataImpression.GetKeyDataTopology() | Improve this Doc View Source SetKeyData(KeyData) By default, there's no data. DataImpressions should only have one KeyData, and it's up to them individually to enforce that they correctly implement this. Declaration public override void SetKeyData(KeyData kd) Parameters Type Name Description KeyData kd Overrides DataImpression.SetKeyData(KeyData) | Improve this Doc View Source SetupGameObject() RENDERING STEP 2. Take geometric rendering information computed in ComputeGeometry() and sets up proper game object(s) and components for this Data Impression. Transfers geometry into Unity format (e.g. a Mesh). No geometric computations should happen in this method, and it should generally be lightweight. Declaration public override void SetupGameObject() Overrides DataImpression.SetupGameObject() | Improve this Doc View Source UpdateStyling() RENDERING STEP 3. Update the \"styling\" of an impression by sending each styling parameter to the shader. Occasionally will need to set per-vertex items like transforms. This method should generally be lightweight. Declaration public override void UpdateStyling() Overrides DataImpression.UpdateStyling() | Improve this Doc View Source UpdateVisibility() RENDERING STEP 4. Update the visibility of an impression (hidden or shown) Declaration public override void UpdateVisibility() Overrides DataImpression.UpdateVisibility() Implements IHasDataset IHasKeyData ICoordSpaceConverter"
  },
  "api/IVLab.ABREngine.SocketDataListener.html": {
    "href": "api/IVLab.ABREngine.SocketDataListener.html",
    "title": "Class SocketDataListener | ABREngine",
    "keywords": "Class SocketDataListener Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. Inheritance object SocketDataListener Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class SocketDataListener Constructors | Improve this Doc View Source SocketDataListener(int) Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. Declaration public SocketDataListener(int port) Parameters Type Name Description int port Fields | Improve this Doc View Source listener Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. Declaration [SerializeField] public TcpListener listener Field Value Type Description TcpListener | Improve this Doc View Source port Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. Declaration public int port Field Value Type Description int Methods | Improve this Doc View Source DoAcceptSocketCallback(IAsyncResult) Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. Declaration public void DoAcceptSocketCallback(IAsyncResult ar) Parameters Type Name Description IAsyncResult ar | Improve this Doc View Source StartServer() Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. Declaration public void StartServer() | Improve this Doc View Source StopServer() Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. Declaration public void StopServer()"
  },
  "api/IVLab.ABREngine.SocketTextData.html": {
    "href": "api/IVLab.ABREngine.SocketTextData.html",
    "title": "Struct SocketTextData | ABREngine",
    "keywords": "Struct SocketTextData Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public struct SocketTextData Fields | Improve this Doc View Source bindata Declaration public byte[] bindata Field Value Type Description byte[] | Improve this Doc View Source data Declaration public string data Field Value Type Description string | Improve this Doc View Source json Declaration public string json Field Value Type Description string | Improve this Doc View Source label Declaration public string label Field Value Type Description string"
  },
  "api/IVLab.ABREngine.StateLocalVisAssetFetcher.html": {
    "href": "api/IVLab.ABREngine.StateLocalVisAssetFetcher.html",
    "title": "Class StateLocalVisAssetFetcher | ABREngine",
    "keywords": "Class StateLocalVisAssetFetcher Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Inheritance object StateLocalVisAssetFetcher Implements IVisAssetFetcher Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class StateLocalVisAssetFetcher : IVisAssetFetcher Fields | Improve this Doc View Source ARTIFACT_DATA Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public const string ARTIFACT_DATA = \"artifactDataContents\" Field Value Type Description string | Improve this Doc View Source VISASSET_JSON Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public const string VISASSET_JSON = \"artifactJson\" Field Value Type Description string | Improve this Doc View Source VISASSET_STATE Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public const string VISASSET_STATE = \"localVisAssets\" Field Value Type Description string Methods | Improve this Doc View Source GetArtifactJson(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public JObject GetArtifactJson(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description JObject | Improve this Doc View Source GetArtifactJsonPath(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public string GetArtifactJsonPath(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description string | Improve this Doc View Source GetColormap(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public Colormap GetColormap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Colormap | Improve this Doc View Source GetColormapTexture(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public Texture2D GetColormapTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetGlyphGameObject(Guid, JObject) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public GameObject GetGlyphGameObject(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description GameObject | Improve this Doc View Source GetGlyphNormalMapTexture(Guid, JObject) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public Texture2D GetGlyphNormalMapTexture(Guid uuid, JObject lodJson) Parameters Type Name Description Guid uuid JObject lodJson Returns Type Description Texture2D | Improve this Doc View Source GetGlyphPreview(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public Texture2D GetGlyphPreview(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetLineTexture(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public Texture2D GetLineTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceNormalMap(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public Texture2D GetSurfaceNormalMap(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D | Improve this Doc View Source GetSurfaceTexture(Guid) Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. Declaration public Texture2D GetSurfaceTexture(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description Texture2D Implements IVisAssetFetcher"
  },
  "api/IVLab.ABREngine.SurfaceKeyData.html": {
    "href": "api/IVLab.ABREngine.SurfaceKeyData.html",
    "title": "Class SurfaceKeyData | ABREngine",
    "keywords": "Class SurfaceKeyData Inheritance object KeyData SurfaceKeyData Implements IHasDataset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Obsolete(\"Specific types of KeyData are obsolete and may not work correctly. Use KeyData class instead.\")] public class SurfaceKeyData : KeyData, IHasDataset, IABRInput Constructors | Improve this Doc View Source SurfaceKeyData(string, DataTopology) Declaration public SurfaceKeyData(string path, DataTopology topology) Parameters Type Name Description string path DataTopology topology Implements IHasDataset IABRInput"
  },
  "api/IVLab.ABREngine.SurfaceTextureGradient.html": {
    "href": "api/IVLab.ABREngine.SurfaceTextureGradient.html",
    "title": "Class SurfaceTextureGradient | ABREngine",
    "keywords": "Class SurfaceTextureGradient Inheritance object VisAsset VisAssetGradient SurfaceTextureGradient Implements ISurfaceTextureVisAsset IVisAssetGradient<SurfaceTextureVisAsset> IVisAsset IABRInput ITextureGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class SurfaceTextureGradient : VisAssetGradient, ISurfaceTextureVisAsset, IVisAssetGradient<SurfaceTextureVisAsset>, IVisAsset, IABRInput, ITextureGradient Properties | Improve this Doc View Source BlendMaps Internal calculations for blend maps used for rendering Declaration public GradientBlendMap BlendMaps { get; } Property Value Type Description GradientBlendMap | Improve this Doc View Source Stops List of gradient stops (length of VisAssets - 1) Declaration public List<float> Stops { get; } Property Value Type Description List<float> | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration public int VisAssetCount { get; } Property Value Type Description int | Improve this Doc View Source VisAssets List of all VisAssets inside this gradient Declaration public List<SurfaceTextureVisAsset> VisAssets { get; } Property Value Type Description List<SurfaceTextureVisAsset> Methods | Improve this Doc View Source GetTexture() Obtain the first (or, only) texture in a multi-visasset gradient Declaration public Texture2D GetTexture() Returns Type Description Texture2D | Improve this Doc View Source GetTexture(int) Obtain the texture at a specific index within a multi-visasset gradient Declaration public Texture2D GetTexture(int gradientIndex) Parameters Type Name Description int gradientIndex Returns Type Description Texture2D | Improve this Doc View Source GetTexture(float) Obtain the texture at a specific t-value (percentage) within a multi-visasset gradient Declaration public Texture2D GetTexture(float gradientT) Parameters Type Name Description float gradientT Returns Type Description Texture2D | Improve this Doc View Source Initialize(Guid, List<SurfaceTextureVisAsset>, List<float>) Initialize this gradient with a UUID, some VisAssets, and some Stops. This is used instead of a constructor because it is much more flexible. Declaration public void Initialize(Guid uuid, List<SurfaceTextureVisAsset> visAssets, List<float> stops) Parameters Type Name Description Guid uuid List<SurfaceTextureVisAsset> visAssets List<float> stops Implements ISurfaceTextureVisAsset IVisAssetGradient<T> IVisAsset IABRInput ITextureGradient"
  },
  "api/IVLab.ABREngine.SurfaceTextureVisAsset.html": {
    "href": "api/IVLab.ABREngine.SurfaceTextureVisAsset.html",
    "title": "Class SurfaceTextureVisAsset | ABREngine",
    "keywords": "Class SurfaceTextureVisAsset Inheritance object VisAsset SurfaceTextureVisAsset Implements ISurfaceTextureVisAsset IVisAsset IABRInput ITextureGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class SurfaceTextureVisAsset : VisAsset, ISurfaceTextureVisAsset, IVisAsset, IABRInput, ITextureGradient Constructors | Improve this Doc View Source SurfaceTextureVisAsset() Declaration public SurfaceTextureVisAsset() | Improve this Doc View Source SurfaceTextureVisAsset(Guid, Texture2D, Texture2D) Declaration public SurfaceTextureVisAsset(Guid uuid, Texture2D texture, Texture2D normalMap) Parameters Type Name Description Guid uuid Texture2D texture Texture2D normalMap | Improve this Doc View Source SurfaceTextureVisAsset(Texture2D, Texture2D) Declaration public SurfaceTextureVisAsset(Texture2D texture, Texture2D normalMap) Parameters Type Name Description Texture2D texture Texture2D normalMap Properties | Improve this Doc View Source BlendMaps Internal calculations for blend maps used for rendering Declaration public GradientBlendMap BlendMaps { get; } Property Value Type Description GradientBlendMap | Improve this Doc View Source NormalMap Declaration public Texture2D NormalMap { get; } Property Value Type Description Texture2D | Improve this Doc View Source Texture Declaration public Texture2D Texture { get; } Property Value Type Description Texture2D | Improve this Doc View Source VisAssetCount How many VisAssets are in the gradient? (1 if it's not a gradient) Declaration public int VisAssetCount { get; } Property Value Type Description int Methods | Improve this Doc View Source GetTexture() Obtain the first (or, only) texture in a multi-visasset gradient Declaration public Texture2D GetTexture() Returns Type Description Texture2D | Improve this Doc View Source GetTexture(int) Obtain the texture at a specific index within a multi-visasset gradient Declaration public Texture2D GetTexture(int gradientIndex) Parameters Type Name Description int gradientIndex Returns Type Description Texture2D | Improve this Doc View Source GetTexture(float) Obtain the texture at a specific t-value (percentage) within a multi-visasset gradient Declaration public Texture2D GetTexture(float gradientT) Parameters Type Name Description float gradientT Returns Type Description Texture2D Implements ISurfaceTextureVisAsset IVisAsset IABRInput ITextureGradient"
  },
  "api/IVLab.ABREngine.TextStateFileLoader.html": {
    "href": "api/IVLab.ABREngine.TextStateFileLoader.html",
    "title": "Class TextStateFileLoader | ABREngine",
    "keywords": "Class TextStateFileLoader Load a state from a serialized JSON string Inheritance object TextStateFileLoader Implements IABRStateLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class TextStateFileLoader : IABRStateLoader Constructors | Improve this Doc View Source TextStateFileLoader() Load a state from a serialized JSON string Declaration public TextStateFileLoader() Methods | Improve this Doc View Source GetState(string) Load a state based on some text (perhaps a JSON string, a file path, or URL) Declaration public JObject GetState(string jsonText) Parameters Type Name Description string jsonText Returns Type Description JObject | Improve this Doc View Source SaveState(string, string) Save a serialized JSON state with a particular name Declaration public void SaveState(string name, string serializedState) Parameters Type Name Description string name string serializedState Implements IABRStateLoader"
  },
  "api/IVLab.ABREngine.TypeExtentions.html": {
    "href": "api/IVLab.ABREngine.TypeExtentions.html",
    "title": "Class TypeExtentions | ABREngine",
    "keywords": "Class TypeExtentions Inheritance object TypeExtentions Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public static class TypeExtentions Methods | Improve this Doc View Source ImplicitlyConvertsTo(Type, Type) Check if a type implicitly converts to another. Source: https://stackoverflow.com/a/2075975 Declaration public static bool ImplicitlyConvertsTo(this Type type, Type destinationType) Parameters Type Name Description Type type Type destinationType Returns Type Description bool"
  },
  "api/IVLab.ABREngine.UnityObjectSerializer.html": {
    "href": "api/IVLab.ABREngine.UnityObjectSerializer.html",
    "title": "Class UnityObjectSerializer | ABREngine",
    "keywords": "Class UnityObjectSerializer Custom converter to allow less verbose Newtonsoft serialization of Unity builtin objects. This converter manually handles several cases, add more as they become necessary. Inheritance object JsonConverter UnityObjectSerializer Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class UnityObjectSerializer : JsonConverter Constructors | Improve this Doc View Source UnityObjectSerializer() Build the custom converter and define both the types that are allowed to be serialized and the string keys that are allowed to exist post-serialization Declaration public UnityObjectSerializer() Properties | Improve this Doc View Source CanRead Gets a value indicating whether this Newtonsoft.Json.JsonConverter can read JSON. Declaration public override bool CanRead { get; } Property Value Type Description bool true if this Newtonsoft.Json.JsonConverter can read JSON; otherwise, false. Overrides Newtonsoft.Json.JsonConverter.CanRead Methods | Improve this Doc View Source CanConvert(Type) We only provide serializers for these types Declaration public override bool CanConvert(Type type) Parameters Type Name Description Type type Returns Type Description bool Overrides JsonConverter.CanConvert(Type) | Improve this Doc View Source ReadJson(JsonReader, Type, object, JsonSerializer) Reads the JSON representation of the object. Declaration public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) Parameters Type Name Description JsonReader reader The Newtonsoft.Json.JsonReader to read from. Type objectType Type of the object. object existingValue The existing value of object being read. JsonSerializer serializer The calling serializer. Returns Type Description object The object value. Overrides JsonConverter.ReadJson(JsonReader, Type, object, JsonSerializer) | Improve this Doc View Source WriteJson(JsonWriter, object, JsonSerializer) Writes the JSON representation of the object. Declaration public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) Parameters Type Name Description JsonWriter writer The Newtonsoft.Json.JsonWriter to write to. object value The value. JsonSerializer serializer The calling serializer. Overrides JsonConverter.WriteJson(JsonWriter, object, JsonSerializer)"
  },
  "api/IVLab.ABREngine.UpdateLevel.html": {
    "href": "api/IVLab.ABREngine.UpdateLevel.html",
    "title": "Enum UpdateLevel | ABREngine",
    "keywords": "Enum UpdateLevel How \"deep\" a particular update needs to go to fully address this ABR Input Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public enum UpdateLevel Fields Name Description Geometry Data updates generally need to address geometric information and/or populate data on a per-vertex basis, hence they are usually slow/expensive. Style Style updates are generally lightweight and only consist of updating uniforms on the GPU, for example changing the colormap or glyph size."
  },
  "api/IVLab.ABREngine.VectorDataVariable.html": {
    "href": "api/IVLab.ABREngine.VectorDataVariable.html",
    "title": "Class VectorDataVariable | ABREngine",
    "keywords": "Class VectorDataVariable Inheritance object VectorDataVariable Implements IDataVariable<Vector3> IABRInput IHasDataset Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class VectorDataVariable : IDataVariable<Vector3>, IABRInput, IHasDataset Properties | Improve this Doc View Source CustomizedRange Have this var's ranges been customized? Declaration public bool CustomizedRange { get; set; } Property Value Type Description bool | Improve this Doc View Source Genre \"Genre\" of the input - is it Data, a visual element, or something else? Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre | Improve this Doc View Source OriginalRange Save the original range in case the user wants to reset it later. Declaration public DataRange<Vector3> OriginalRange { get; set; } Property Value Type Description DataRange<Vector3> | Improve this Doc View Source Path The DataPath that represents this variable Declaration public string Path { get; } Property Value Type Description string | Improve this Doc View Source Range Range is calculated by the DataManager when it imports a new dataset. Range is calculated from the smallest/largest values encountered across every instance of this variable, across all datasets. Declaration public DataRange<Vector3> Range { get; set; } Property Value Type Description DataRange<Vector3> | Improve this Doc View Source SpecificRanges Dictionary of keyData paths that have specific ranges for this variable Declaration public Dictionary<string, DataRange<Vector3>> SpecificRanges { get; set; } Property Value Type Description Dictionary<string, DataRange<Vector3>> Methods | Improve this Doc View Source GetArray(KeyData) Get the actual data values in the context of this particular Key Data object Declaration public Vector3[] GetArray(KeyData keyData) Parameters Type Name Description KeyData keyData Returns Type Description Vector3[] | Improve this Doc View Source GetDataset() Declaration public Dataset GetDataset() Returns Type Description Dataset | Improve this Doc View Source GetRawABRInput() Get the \"raw\" ABR input - the one that is represented in the state JSON Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput | Improve this Doc View Source IsPartOf(KeyData) Determine if this variable is a part of the key data Declaration public bool IsPartOf(KeyData keyData) Parameters Type Name Description KeyData keyData Returns Type Description bool Implements IDataVariable<T> IABRInput IHasDataset"
  },
  "api/IVLab.ABREngine.VisAsset.html": {
    "href": "api/IVLab.ABREngine.VisAsset.html",
    "title": "Class VisAsset | ABREngine",
    "keywords": "Class VisAsset Generic type for all VisAssets to inherit from Inheritance object VisAsset ColormapVisAsset GlyphVisAsset LineTextureVisAsset SurfaceTextureVisAsset VisAssetGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class VisAsset Fields | Improve this Doc View Source VisAssetTypeMap Typemap where we can look up ABR visasset types and convert to C# types. The typestring that defines this VisAsset type, from the ABR Schema. Should match one of: #/definitions/VisAssetType Declaration public static Dictionary<string, Type> VisAssetTypeMap Field Value Type Description Dictionary<string, Type> Properties | Improve this Doc View Source Genre Generic type for all VisAssets to inherit from Declaration public ABRInputGenre Genre { get; } Property Value Type Description ABRInputGenre | Improve this Doc View Source ImportTime Generic type for all VisAssets to inherit from Declaration public DateTime ImportTime { get; set; } Property Value Type Description DateTime | Improve this Doc View Source Uuid Generic type for all VisAssets to inherit from Declaration public Guid Uuid { get; set; } Property Value Type Description Guid Methods | Improve this Doc View Source GetRawABRInput() Generic type for all VisAssets to inherit from Declaration public RawABRInput GetRawABRInput() Returns Type Description RawABRInput | Improve this Doc View Source IsValidVisAssetType(string) Check if a ABR VisAsset schema type is valid with this system Declaration public static bool IsValidVisAssetType(string vaType) Parameters Type Name Description string vaType Returns Type Description bool"
  },
  "api/IVLab.ABREngine.VisAssetGradient.html": {
    "href": "api/IVLab.ABREngine.VisAssetGradient.html",
    "title": "Class VisAssetGradient | ABREngine",
    "keywords": "Class VisAssetGradient Concrete implementation of a VisAsset Gradient, which is a collection of VisAssets that also counts as a single VisAsset. Inheritance object VisAsset VisAssetGradient GlyphGradient LineTextureGradient SurfaceTextureGradient Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class VisAssetGradient : VisAsset Methods | Improve this Doc View Source FromRaw<T, S>(RawVisAssetGradient) Convert from a RawVisAssetGradient to a regular gradient for internal use. Declaration public static T FromRaw<T, S>(RawVisAssetGradient raw) where T : IVisAssetGradient<S>, new() where S : IVisAsset Parameters Type Name Description RawVisAssetGradient raw Returns Type Description T Type Parameters Name Description T S"
  },
  "api/IVLab.ABREngine.VisAssetLoader.html": {
    "href": "api/IVLab.ABREngine.VisAssetLoader.html",
    "title": "Class VisAssetLoader | ABREngine",
    "keywords": "Class VisAssetLoader Use a particular fetcher to try and get the VisAsset from its source, and construct the requisite Unity objects and IVisAsset to add. Inheritance object VisAssetLoader Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class VisAssetLoader Constructors | Improve this Doc View Source VisAssetLoader() Use a particular fetcher to try and get the VisAsset from its source, and construct the requisite Unity objects and IVisAsset to add. Declaration public VisAssetLoader() Methods | Improve this Doc View Source LoadVisAsset(Guid) Use a particular fetcher to try and get the VisAsset from its source, and construct the requisite Unity objects and IVisAsset to add. Declaration public IVisAsset LoadVisAsset(Guid uuid) Parameters Type Name Description Guid uuid Returns Type Description IVisAsset | Improve this Doc View Source LoadVisAsset(Guid, IVisAssetFetcher) Use a particular fetcher to try and get the VisAsset from its source, and construct the requisite Unity objects and IVisAsset to add. Declaration public IVisAsset LoadVisAsset(Guid uuid, IVisAssetFetcher _fetcher) Parameters Type Name Description Guid uuid IVisAssetFetcher _fetcher Returns Type Description IVisAsset"
  },
  "api/IVLab.ABREngine.VisAssetManager.html": {
    "href": "api/IVLab.ABREngine.VisAssetManager.html",
    "title": "Class VisAssetManager | ABREngine",
    "keywords": "Class VisAssetManager The VisAssetManager is where all VisAssets are stored within the ABREngine. VisAssets can be loaded and fetched from various sources defined in VisAssetFetchers. Currently, VisAssets may be loaded from any of the following: The state itself (`localVisAssets`) The media directory on the machine ABR is running on Any Resources folder (in Assets or in any Package) A VisAsset server Inheritance object VisAssetManager Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax public class VisAssetManager Examples VisAssets can be loaded manually from your media folder, resources folder, or a network resource. This example loads a colormap 66b3cde4-034d-11eb-a7e6-005056bae6d8 from Resources (it's included in the ABREngine/Resources/media folder). public class VisAssetManagerExample : MonoBehaviour { void Start() { // Note, we could've used `LoadVisAsset` explicitly here, but // GetVisAsset will automatically try to load the VisAsset if it // doesn't already exist. ColormapVisAsset cmap = ABREngine.Instance.VisAssets.GetVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\")); } void Update() { // If you want to access the colormap later, you can use `GetVisAsset`. ColormapVisAsset cmapInUpdate = ABREngine.Instance.VisAssets.GetVisAsset<ColormapVisAsset>(new System.Guid(\"66b3cde4-034d-11eb-a7e6-005056bae6d8\"); } } You can also get the \"default\" visasset for a few VisAsset types. Keep in mind that the GetDefault<T>() method may not be defined for the VisAsset type that you want to get! public class VisAssetManagerExample : MonoBehaviour { void Start() { ColormapVisAsset cmap = ABREngine.Instance.VisAssets.GetDefault<ColormapVisAsset>() as ColormapVisAsset; } } Constructors | Improve this Doc View Source VisAssetManager(string) Initialize a new VisAssetManager and define all of the places VisAssets may be loaded from. Declaration public VisAssetManager(string visassetPath) Parameters Type Name Description string visassetPath Path to the VisAssets folder within ABR's media folder. Fields | Improve this Doc View Source VISASSET_JSON Name of the artifact.json files that each VisAsset has Declaration public const string VISASSET_JSON = \"artifact.json\" Field Value Type Description string | Improve this Doc View Source appDataPath Application data path for internal access Declaration public string appDataPath Field Value Type Description string Properties | Improve this Doc View Source LocalVisAssets Any (custom) visassets that are solely described inside the state and do not exist on disk or on a server somewhere. Declaration public JObject LocalVisAssets { get; set; } Property Value Type Description JObject | Improve this Doc View Source VisAssetGradients Any VisAsset gradients that are contained within the state (updated directly from state) Declaration public Dictionary<string, RawVisAssetGradient> VisAssetGradients { get; set; } Property Value Type Description Dictionary<string, RawVisAssetGradient> Methods | Improve this Doc View Source GetDefault<T>() Obtain the default visasset for a particular type, if there is one. Declaration public IVisAsset GetDefault<T>() where T : IVisAsset Returns Type Description IVisAsset Type Parameters Name Description T Remarks If using the VisAsset immediately as the type T, you will likely need to do a cast (e.g. ColormapVisAsset c = ....GetDefault<ColormapVisAsset>() as ColormapVisAsset). | Improve this Doc View Source GetVisAsset<T>(Guid) Get a visasset by its unique identifier. Declaration public T GetVisAsset<T>(Guid uuid) where T : IVisAsset Parameters Type Name Description Guid uuid UUID of the VisAsset to get from the engine. Returns Type Description T Returns the VisAsset, if found. If not found, tries to load the VisAsset then return it. Type Parameters Name Description T Any VisAsset type. | Improve this Doc View Source GetVisAssets() Get the UUIDs of every VisAsset that's been imported into ABR Declaration public List<Guid> GetVisAssets() Returns Type Description List<Guid> Returns a list containing UUIDs of each VisAsset in ABR. | Improve this Doc View Source LoadVisAsset(Guid, bool) Load a particular VisAsset described by its UUID. Declaration public IVisAsset LoadVisAsset(Guid visAssetUUID, bool replaceExisting = false) Parameters Type Name Description Guid visAssetUUID bool replaceExisting Returns Type Description IVisAsset Returns the IVisAsset that was loaded, or null if the VisAsset was not found. | Improve this Doc View Source LoadVisAssetPalette() Load all VisAssets located in the Media directory into memory. Declaration [Obsolete(\"LoadVisAssetPalette is obsolete because it only takes into consideration VisAssets in the media directory\")] public void LoadVisAssetPalette() | Improve this Doc View Source LoadVisAsset<T>(Guid, bool) Load a VisAsset of a specific type. Declaration public T LoadVisAsset<T>(Guid visAssetUUID, bool replaceExisting = false) where T : IVisAsset Parameters Type Name Description Guid visAssetUUID UUID of the VisAsset to load from any VisAsset loader. bool replaceExisting Returns Type Description T Returns the VisAsset of type T that was loaded, or null if the VisAsset was not found. Type Parameters Name Description T Any VisAsset type. | Improve this Doc View Source TryGetVisAsset(Guid, out IVisAsset) Attempt to retrieve a VisAsset. Declaration public bool TryGetVisAsset(Guid guid, out IVisAsset visAsset) Parameters Type Name Description Guid guid IVisAsset visAsset Returns Type Description bool Returns true if the VisAsset is currently loaded into the memory. | Improve this Doc View Source UnloadVisAsset(Guid) Unload a particular VisAsset described by its UUID. Declaration public void UnloadVisAsset(Guid visAssetUUID) Parameters Type Name Description Guid visAssetUUID Remarks Note that this method does not check if the VisAsset is in use, so be careful when calling it!"
  },
  "api/IVLab.ABREngine.VolumeKeyData.html": {
    "href": "api/IVLab.ABREngine.VolumeKeyData.html",
    "title": "Class VolumeKeyData | ABREngine",
    "keywords": "Class VolumeKeyData Inheritance object KeyData VolumeKeyData Implements IHasDataset IABRInput Namespace: IVLab.ABREngine Assembly: IVLab.ABREngine.Runtime.dll Syntax [Obsolete(\"Specific types of KeyData are obsolete and may not work correctly. Use KeyData class instead.\")] public class VolumeKeyData : KeyData, IHasDataset, IABRInput Constructors | Improve this Doc View Source VolumeKeyData(string, DataTopology) Declaration public VolumeKeyData(string path, DataTopology topology) Parameters Type Name Description string path DataTopology topology Implements IHasDataset IABRInput"
  },
  "api/IVLab.ABREngine.html": {
    "href": "api/IVLab.ABREngine.html",
    "title": "Namespace IVLab.ABREngine | ABREngine",
    "keywords": "Namespace IVLab.ABREngine Classes ABRConfig This Scriptable Object controls the ABR configuration before startup. On engine startup, a copy is instantiated for use at runtime. ABRConfig.Consts Global access to constants in the ABR Engine. Sync this with settings.py in the ABRServer~. ABRConfig.GroupToDataMatrixOverrideFields ABRDataContainer ABREngine The ABREngine class is the main operational MonoBehaviour Singleton for the ABREngine-UnityPackage. It is in charge of kicking off all startup processes for ABR, including setting up connections with the server, the data listener, VisAssets and Data managers, etc. ABRInputAttribute Input attribute used for annotating an ABR input to a data impression (VisAsset, DataVariable, etc.) ABRInputIndexerModule Convenience class to avoid having to repeatedly manage reflection when adjusting ABR inputs to Data Impressions. ABRLight ABRLightManager Transfer any lights in the ABR scene to variables in the volume rendering shader. ABRPlateType Attribute to match up this class with the string plate name from the ABR Schema ABRServer The ABRServer class functions as a passthrough to the Python server. It defines several helpful constants and functions for working with the server (e.g., starting, stopping, etc.) ABRStateParser The ABRStateParser takes a (text) ABR state from JSON and loads its components into Unity, or takes the current state of objects in the Unity scene and translates it back into text. AnglePrimitive BooleanPrimitive ColormapVisAsset DataImpression Main class for Data Impressions (layers) in an ABR visualization. Every Data Impression is a GameObject in the scene. DataImpressionGroup A DataImpressionGroup is a group of data impressions within ABR. DataImpressionGroups can be constrained within a defined bounding box (see ABRDataContainer), and can automatically rescale all of their data to stay within this container. Each time a new KeyData object is loaded into a data impression in this group, the GroupToDataMatrix and GroupBounds are updated. DataManager Manager where all datasets, key data, and variables live. This class makes the connection between Datasets and RawDatasets. This class is useful for obtaining any KeyData and Variables needed to apply to Data Impressions. DataPath A path to a data source, be it a KeyData object, a Scalar Variable, a Vector Variable, or something else. Should take the form of Organization/DatasetName/* Example: TACC/GulfOfMexico/KeyData/bathymetry Example: TACC/GulfOfMexico/ScalarVar/temperature DataPoint A DataPoint describes a point in a dataset. Often, this is useful when querying a dataset, for example, to find the closest data point to a given point in world space. DataRange<T> Range descriptor for a variable, including a min and max. Dataset Lightweight container for a collection of KeyData objects and variables that share a common coordinate space. Its bounding box contains all of data, and the rendered objects are children of this object's GameObject. FilePathVisAssetFetcher Fetch VisAsset from somewhere on local disk FloatPrimitive GlyphGradient GlyphVisAsset GradientBlendMap Collection of essential textures for making texture-based VisAsset gradients happen. The blend maps are controlled via the BlendMaps and StopMaps texture arrays. HttpDataLoader Load data from a remote source HttpStateFileLoader Save/Load a state from a web URL HttpVisAssetFetcher Fetch VisAssets from a URL via HTTP InstancedMeshRenderer Custom-tailored Instanced Mesh Renderer for rendering glyphs in ABR. When using this, developers should make sure that \"Use Instanced\" is checked on the material that these glyphs are using. InstancedSurfaceDataImpression An Instanced Surface data impression (very similar to glyphs, except geometries are specified from data rather than VisAssets) Note This data impression type is not supported by the ABR design interface, hence the lack of ABRInputAttribute annotations for its instance variables. IntegerPrimitive KeyData Lightweight container for a data object. From Key Data objects, scalar and vector variables can be obtained (see the example below). LengthPrimitive LineKeyData LineTextureGradient LineTextureVisAsset MediaDataLoader Load data from the ABREngine Media directory (specified in ABRConfig) Notifier Notifier for ABR state / cache updates, based on WebSockets. PathStateFileLoader Save/Load a state to a JSON file somewhere on disk PercentPrimitive PointKeyData PrimitiveGradient A simple gradient of points associated with values. RawABRInput Raw string values from a state JSON being passed to ABR Matches InputValue definition from ABR State Schema Parameters can have one or more inputs RawDataset The raw variable arrays and geometry for a Data Object. RawDatasets can be loaded from a pair of .json and .bin files (JsonHeader and BinaryData, respectively). This RawDataset defines the specification for each of these files. RawDataset is not to be confused with Dataset, which represents a collection of RawDatasets which share a coordinate space, key data, and variables. RawDataset.BinaryData Actual geometric representation of the data to load from a file / socket RawDataset.JsonHeader Header that contains metadata for a particular RawDataset RawDatasetAdapter Adapter for converting other formats to ABRDataFormat. For example, lists of points => ribbons, or lists of points => glyphs. See the examples below for usage of each of these methods. RawPrimitiveGradient RawVisAssetGradient Serializable version of the VisAsset gradients that interacts with state/schema. Each VisAsset type should be responsible for implementing their own conversion to/from this. RenderHints Hints for rendering, such as whether a data impression should be hidden ResourceStateFileLoader Load a state from any Resources folder within Unity (within any Package or Asset) ResourceVisAssetFetcher Fetch VisAsset from a Resources folder (in an Asset or Package) ResourcesDataLoader Load data from resources folder. NOTE: The actual data files (.bin) must have their file extension changed to .txt in order to be recognized. When data are imported, the identity of each is lost so we must guess which is which - currently guessing the larger of the two files is the \"Data\" and the smaller is \"Metadata\". ScalarDataVariable SerializableFloatArray SerializableVectorArray SimpleGlyphDataImpression A \"Glyphs\" data impression that uses hand-sculpted geometry to depict point data. SimpleLineDataImpression A \"Lines\" data impression that uses hand-drawn line textures to depict line/flow data. SimpleLineRenderInfo SimpleSurfaceDataImpression A \"Surfaces\" data impression that uses hand-drawn textures and color to show surface data. SimpleSurfaceRenderInfo SimpleVolumeDataImpression A \"Volumes\" data impression that uses a user-defined transfer (opacity) map and a colormap to show volumetric data. SocketDataListener Listener for incoming upstream data, for example, from a Send2ABR plugin for ParaView. Operation of this class is controlled by the ABRConfig option dataListenerPort. StateLocalVisAssetFetcher Fetch a VisAsset from the currently loaded ABR state. Currently only valid for ColormapVisAssets. SurfaceKeyData SurfaceTextureGradient SurfaceTextureVisAsset TextStateFileLoader Load a state from a serialized JSON string TypeExtentions UnityObjectSerializer Custom converter to allow less verbose Newtonsoft serialization of Unity builtin objects. This converter manually handles several cases, add more as they become necessary. VectorDataVariable VisAsset Generic type for all VisAssets to inherit from VisAssetGradient Concrete implementation of a VisAsset Gradient, which is a collection of VisAssets that also counts as a single VisAsset. VisAssetLoader Use a particular fetcher to try and get the VisAsset from its source, and construct the requisite Unity objects and IVisAsset to add. VisAssetManager The VisAssetManager is where all VisAssets are stored within the ABREngine. VisAssets can be loaded and fetched from various sources defined in VisAssetFetchers. Currently, VisAssets may be loaded from any of the following: The state itself (`localVisAssets`) The media directory on the machine ABR is running on Any Resources folder (in Assets or in any Package) A VisAsset server VolumeKeyData Structs SocketTextData Interfaces IABRInput Interface that includes every input to a data impression. Every type of ABR input should fit into a specific ABRInputGenre. IABRStateLoader Generic state loader for ABR. Implementations should allow both retrieving a state (GetState) and saving a state (SaveState). IColormapVisAsset ICoordSpaceConverter Interface to implement for helpers to convert between Data Space and Unity's World Space. IDataAccessor Interface to implement to share easier access to data within ABR. IDataImpressionRenderInfo IDataLoader Generic interface to fetch a RawDataset from somewhere IDataVariable<T> Lightweight / high level container for a data variable. Variables keep track of their ranges and path, but the actual Data Arrays are preserved within the original RawDataset. IFloatPrimitive Represents a numeric primitive value (e.g. 10deg, 96cm, or 4.6) IGlyphVisAsset IHasDataset Should be assigned to anything that is associated with a dataset (e.g. KeyData, Variables, and even DataImpressions once they have valid KeyData) IHasKeyData Indicator that a particular object has some key data attached to it - useful for most DataImpressions. IIntegerPrimitive Represents an integer primitive value IKeyDataRenderInfo ILineTextureVisAsset IPrimitive Representative of a primitive element (usually used in ABR Inputs). These should match the primitive input types in the schema. IPrimitiveGradient ISurfaceTextureVisAsset ITextureGradient A VisAsset gradient described by a texture (or, series of textures) IVisAsset IVisAssetFetcher Generic fetcher that supports fetching all types of VisAssets from a particular source. IVisAssetGradient<T> A gradient consisting of VisAssets of any type. NOTE: Texture-based gradients (Surface/Line textures and colormaps) must have 4 or fewer elements. IVolumeCoordSpaceConverter Interface to implement for helpers to convert between Data Space and Unity's World Space. IVolumeDataAccessor Interface to implement to share easier access to volume data within ABR. Enums ABRInputGenre Possible genres of a visualization input DataPath.DataPathType DataTopology Extension of Unity's MeshTopology enum that defines more generic \"data\" topology, including voxels. UpdateLevel How \"deep\" a particular update needs to go to fully address this ABR Input Delegates ABREngine.StateChangeDelegate Delegate callback that is called whenever the ABRState is updated. This is useful for applications that build on ABR and need to know when the state has been updated. OnStateChanged for usage."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Overview | ABREngine",
    "keywords": "API Overview Here are the most important classes start out making visualizations with C# and ABR. Check out the Creating a C# ABR visualization tutorial for more examples. ABREngine Class Importance ABREngine This is the main ABR Engine class. ABREngine is a singleton, meaning that you will most often access an instance of this class with ABREngine.Instance. ABRConfig Main configuration class for ABR. Create an ABRConfig using Assets > Create > ABR > ABR Configuration and modify as necessary. ABRStateParser Main class for serializing and deserializing ABR states Data Data Loading Class Importance DataManager Main \"manager\" object where data are stored. Single instance of this class is ABREngine.Instance.Data. KeyData High-level representation of geometric data. See Key Data. RawDataset Low-level representation of geometric data. See Basic Terminology RawDatasetAdapter Factory used to create ABR-compatible raw datasets from existing data you have (e.g., creating a surface out of a bunch of @UnityEngine.Vector3 s) MediaDataLoader Load data from the media folder ResourcesDataLoader Load data from any Unity Resources folder - useful for bundling data with a project. HttpDataLoader Load data from a network (http) source (must be set up with ABR data server) Data Variables and Ranges Class Importance ScalarDataVariable Scalar variables (single value at each point in the dataset) VectorDataVariable Vector variables (3 values at each point in the dataset) @IVLab.ABREngine.DataRange Representation of a data range (min/max, only meaningful for scalar variables VisAssets Class Importance VisAssetManager Main \"manager\" object where VisAssets are stored. Single instance of this class is ABREngine.Instance.VisAssets. VisAssetLoader Responsible for loading visassets, deciding which VisAsset fetcher to use, and error handling VisAsset Every VisAsset is one of these ColormapVisAsset Imported from a colormap.xml and have a GetGradient() method to get a Texture2D LineTextureVisAsset Imported from a horizontal.png texture, have a GetTexture() method to get a Texture2D SurfaceTextureVisAsset Imported from a texture.png texture, have a GetTexture() method to get a Texture2D GlyphVisAsset LOD-Separated, imported from a LOD1.obj and normal-mapped with a LOD1.png. VisAssetGradient Gradients of multiple VisAssets (applies to every VisAsset type except Colormaps) Data Impressions Class Importance DataImpression Main class that all data impressions inherit from SimpleSurfaceDataImpression Data impression for surfaces. Takes key data type \"Surface\" SimpleLineDataImpression Data impression for ribbon-formed lines. Takes key data type \"Lines\" SimpleGlyphDataImpression Data impression for glyphs. Takes key data type \"Points\" SimpleVolumeDataImpression Data impression for volume data. Takes key data type \"Volume\" (a structured grid) InstancedSurfaceDataImpression Data impression for a series of instanced surfaces (same geometry repeated over many different transforms)"
  },
  "index.html": {
    "href": "index.html",
    "title": "Artifact-Based Rendering Engine | ABREngine",
    "keywords": "Artifact-Based Rendering Engine Getting Started Installation Guide Introduction and Overview Key classes organized by theme / functionality Core concepts About ABR We introduce Artifact-Based Rendering (ABR), a framework of tools, algorithms, and processes that makes it possible to produce real, data-driven 3D scientific visualizations with a visual language derived entirely from colors, lines, textures, and forms created using traditional physical media or found in nature. A theory and process for ABR is presented to address three current needs: (i) designing better visualizations by making it possible for non-programmers to rapidly design and critique many alternative data-to-visual mappings; (ii) expanding the visual vocabulary used in scientific visualizations to depict increasingly complex multivariate data; (iii) bringing a more engaging, natural, and human-relatable handcrafted aesthetic to data visualization. New tools and algorithms to support ABR include front-end applets for constructing artifact-based colormaps, optimizing 3D scanned meshes for use in data visualization, and synthesizing textures from artifacts. These are complemented by an interactive rendering engine with custom algorithms and interfaces that demonstrate multiple new visual styles for depicting point, line, surface, and volume data. A within-the-research-team design study provides early evidence of the shift in visualization design processes that ABR is believed to enable when compared to traditional scientific visualization systems. Qualitative user feedback on applications to climate science and brain imaging support the utility of ABR for scientific discovery and public communication. This Unity package provides features and functionality for the Artifact-Based Rendering technique, as described by the paper from VIS 2019."
  },
  "manual/abr-server.html": {
    "href": "manual/abr-server.html",
    "title": "ABR Server | ABREngine",
    "keywords": "ABR Server This folder contains the code for the ABR server and the ABR Compose Design Interface. This is how you create visualizations quickly and visually in ABR! Installation Before you begin, this tutorial assumes that you have a modern version of Python (>= 3.10) installed; the commands shown here are NOT guaranteed to work with other versions of Python. In this tutorial, we set up the Python configuration for the ABR Server app, which enables you to create visualizations with the ABR Compose design interface. Effectively, we are setting up a \"local\" copy of each package the ABR Server depends on to reduce the chance of conflicts. If you're interested in learning more, check out the pipenv project for more information. If you're on Windows, replace python3 with py. Tip Run all these commands from a terminal in the ABRServer~ folder ( /Packages/ABREngine-UnityPackage/ABRServer~). If you have the read-only Unity package (i.e., you just installed ABR from the Unity Package Manager), use the menu option ABR > Open ABRServer~ folder to open the ABRServer folder. After you've opened the folder, follow the instructions for your operating system to open a terminal. Windows MacOS Linux Windows Terminal instructions Git Bash instructions Command Prompt (cmd) instructions From Finder, the easiest way to open a terminal on a Mac is: Enable Path Bar (View > Show Path Bar) Once you've opened Finder to the ABRServer~ folder, right/two-finger click on the rightmost folder in the newly enabled Path Bar Click \"Open in Terminal\" In most Linux distributions, you can click the \"Open Folder in Terminal...\" in the right-click context menu. To get started, first make sure you have the pipenv package installed in Python. We are using python3 -m pip instead of pip directly to ensure we have the correct pip/Python version pairing. python3 -m pip install --user pipenv Then, install the local dependencies: python3 -m pipenv install Note The first time you run this command, you may need to provide Python path. You can usually get the Python path with a command like which python3 or where python3. Again, on Windows, replace python3 with py. For example: Windows MacOS Linux py -m pipenv --python=/c/Python311/python.exe install python3 -m pipenv --python=/opt/homebrew/bin/python3 install python3 -m pipenv --python=/usr/bin/python3 install Then, to get ready to run the server, \"activate\" the Pipenv by entering a shell: python3 -m pipenv shell Note If you reboot or close the terminal, you will need to re-run the above command. Running the server The server can be run local-only (on localhost:8000 by default): python3 manage.py runserver The server can also be broadcast to other devices (i.e., if you want to run the server on a desktop and use the design interface with a tablet): python manage.py runserver 0.0.0.0:8000 After this command is running, test it but opening http://localhost:8000 in a web browser! You should see the ABR design interface appear: Development with the server This step is optional, and only recommended if you are editing the Python or JavaScript files for the Server or Design Interface. To enable live-reloading (automatically refresh browser when a file is changed), run these commands in separate terminals (the settings_dev enables live-reloading to work): python manage.py livereload python manage.py runserver --settings=abr_server.settings_dev"
  },
  "manual/changelog.html": {
    "href": "manual/changelog.html",
    "title": "| ABREngine",
    "keywords": ""
  },
  "manual/concepts/core-concepts.html": {
    "href": "manual/concepts/core-concepts.html",
    "title": "Core Concepts | ABREngine",
    "keywords": "Key Data VisAssets Data Impressions Basic Terminology Media Folder"
  },
  "manual/concepts/data-impressions.html": {
    "href": "manual/concepts/data-impressions.html",
    "title": "Data Impressions | ABREngine",
    "keywords": "Data Impressions Every \"layer\" in the visualization is represented by a data impression. In the ABR design interface, each impression is shown by a \"tower\"; for example this data impression represents the ground's surface in the simulation, and we've applied some scalar data variables and styling to it. ABR has four types of data impressions: SimpleSurfaceDataImpression SimpleLineDataImpression SimpleGlyphDataImpression SimpleVolumeDataImpression Using Data Impressions in Code To construct a data impression, use the KeyData, Variables, and VisAssets that you have loaded in in the previous examples and link them into the data impression by assigning to instance variables like keyData, colormap, colorVariable etc. See the documentation links above for the values that can be changed for each Data Impression. For example, to create the same effect as the \"tower\" in the previous image, we might use code like this: // Import ground data KeyData groundData = ABREngine.Instance.Data.ImportRawDataset(...); // Import the colormap ColormapVisAsset cmap = ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(...); // Create a new data impression for the ground SimpleSurfaceDataImpression ground = DataImpression.Create<SimpleSurfaceDataImpression>(\"Ground\"); ground.keyData = groundData; ground.colormap = cmap; ground.colorVariable = groundData.GetScalarVariable(...); // Register the data impression with the engine ABREngine.Instance.RegisterDataImpression(ground);"
  },
  "manual/concepts/key-data.html": {
    "href": "manual/concepts/key-data.html",
    "title": "Key Data | ABREngine",
    "keywords": "Key Data For data visualizations that have a spatial structure, the geometric structure itself is a critical part of the data. In fact, access to individual data variables is usually \"keyed\" off these geometric structures. You can't ask, \"What is the average temperature at _________\", without filling in the blank with some geometric identifier. There are some choices; we could fill in the blank with a point, a line, a surface, or a volume in space, but we need something to act as that structure upon which the data variables are defined. We call this geometric structure the \"key data\". Key Data Types Key data are the \"building blocks\" upon which visualizations are created. ABR currently supports four types of key data: Surfaces Lines Points Volumes Every key data has its own geometric structure and variables applied to it. You can think of the Key Data as the \"canvas\" upon which the variables are painted, for example, this visualization of a wavelet is a surface key data object representing the wavy blob surface: Then, we can \"paint\" a visualization on these geometric data by pairing one of the key data's scalar variables (in this case, the X Axis) with a colormap (in this case, a white to green linear map): Key Data Identification Every key data object is identified by a \"Data Path\" string comprised of 4 parts: <Organization>/<Dataset>/KeyData/<KeyDataName> Organization: The governing body that owns the dataset, for example \"TACC\", \"UMN\", \"Brown\", etc. Dataset: A label for the dataset the key data is a part of, for example \"GulfOfMexico\". KeyDataName: The label for this particular key data object, for example \"NitrateSampling\". All in all, for a nitrate point sampling from the Gulf of Mexico, we might end up with a data path string like: E3SM/GulfOfMexico/KeyData/NitrateSampling Using Key Data in Code In scripting, we can obtain an ABR KeyData object by importing some data into ABR. The key data object has some variables. For example, to get a KeyData object from a RawDataset (more on this later) and list its scalar variables, we might write some C# code like this: string keyDataName = \"E3SM/GulfOfMexico/KeyData/NitrateSampling\"; KeyData kd = ABREngine.Instance.Data.ImportRawDataset(keyDataName, nitrateRawData); foreach (ScalarDataVariable s in kd.GetScalarVariables()) { Debug.Log(s); } // Would print out something like \"Temperature, Salinity, ...\" Check out the KeyData and DataManager classes for more examples and further documentation, and be sure to also look at the Creating a C# ABR Visualization tutorial."
  },
  "manual/concepts/media-folder.html": {
    "href": "manual/concepts/media-folder.html",
    "title": "The Media Folder | ABREngine",
    "keywords": "The Media Folder The media folder is where all datasets and visassets are stored. Every ABR project should have one or more media folders. By default in the ABR configuration, the media folder is located in the Application.persistentDataPath. However, this can be changed to a more convenient location, including the Unity project's own Assets folder by modifying the mediaPath in the ABR Configuration that is used for the ABREngine."
  },
  "manual/concepts/terminology-starter.html": {
    "href": "manual/concepts/terminology-starter.html",
    "title": "Basic ABREngine Terminology | ABREngine",
    "keywords": "Basic ABREngine Terminology Beyond the key data, visasset, and data impression metaphors, there are also some new concepts and terminology that you'll need to work with the ABR Engine via C# scripting in Unity. ABREngine The ABREngine is the main class with which visualizations are constructed. ABREngine exists as a singleton object in the Unity scene, that is, there is only ONE instance of ABREngine the entire time Unity is running. You can access the running instance easily in code with ABREngine.Instance; for example, you can use any of the following important methods and objects in this manner: ABREngine.Instance.VisAssets - single instanceSingle instance of the VisAssetManager (you can load or get visassets with this object) ABREngine.Instance.Data - Single instance of the DataManager (you can load or get data with this object) ABREngine.Instance.RegisterDataImpression() - Connect the data and visuals together in the engine ABRengine.Instance.Render() - Display the visualization RawDataset A RawDataset is a standardized geometric dataset (points, lines, surface, volume) formatted in a way that ABR can import it. RawDatasets MUST be imported to be used in ABR. RawDataset objects can be obtained from from the RawDatasetAdapter class and import it immediately after. The following example shows how to construct and import a simple dataset of 3 points: // Build a simple list of 3D points List<Vector3> points = new List<Vector3> { Vector3.zero, Vector3.one, 2*Vector3.one }; // We need to provide a bounding box for the data so ABR knows where it can safely place the visualization in space. // The data should NEVER go outside these bounds. Bounds b = new Bounds(Vector3.zero, 2*Vector3.one); // Standardize these points into a format ABR can understand RawDataset abrPoints = RawDatasetAdapter.PointsToPoints(points, b, null, null); // Then, import the data so we can use it in a visualization KeyData pointsKD = ABREngine.Instance.Data.ImportRawDataset(abrPoints); Read the docs on ABREngine.Instance.Data.ImportRawDataset() and RawDatasetAdapter for more information. DataImpressionGroup Data impressions can be \"grouped\" in your ABR scene, which makes it easier to move data impressions around (e.g., for a side-by-side visualization). Check out the DataImpressionGroup example in the ABREngine for more information."
  },
  "manual/concepts/visassets.html": {
    "href": "manual/concepts/visassets.html",
    "title": "VisAssets (Visualization Assets) | ABREngine",
    "keywords": "VisAssets (Visualization Assets) VisAssets are visual building blocks or elements of a visualization sourced from real-world artifacts and materials. ABR currently supports four types of VisAssets: Name Colormap Line Texture Glyph Example C# Class ColormapVisAsset LineTextureVisAsset SurfaceTextureVisAsset GlyphVisAsset Using VisAssets in code: Each VisAsset has a unique identifier, known as a UUID (or a Guid in C# (Links to an external site.)) - this is the long hex number you may have seen in your ABR media folder. When programming with ABR, you'll need to use these UUIDs to load and reference VisAssets, since there's not an easy way to tell the computer \"I want that blue linear colormap over there\". The general process for loading VisAssets in C# scripts is: Find the UUID of the VisAsset you want. Usually this can be accomplished by right/two-finger clicking the VisAsset in question in a browser (either from the ABR Design Interface or the Sculpting Vis Library), then copy/pasting the long hex UUID from your browser's URL bar (e.g. 5a761a72-8bcb-11ea-9265-005056bae6d8). Create a Guid object to store this UUID. Load the VisAsset using VisAssetManager LoadVisAsset method. For example, in code, you might load a colormap like this (note the use of LoadVisAsset and Guid): ColormapVisAsset cmap = ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(new Guid(\"5a761a72-8bcb-11ea-9265-005056bae6d8\")); See the VisAssetManager for more details and example loading code."
  },
  "manual/install.html": {
    "href": "manual/install.html",
    "title": "Installation Guide | ABREngine",
    "keywords": "To install ABREngine in a Unity Project The first sections refer to the ABREngine Unity Package. For install instructions on the ABR Server, see the ABR Server section below. Install via the Unity Package Manager To use the package in a read-only mode, the same way you would for packages downloaded directly from Unity: In Unity, open Window -> Package Manager. Click the + button Select Add package from git URL Paste https://github.com/ivlab/ABREngine-UnityPackage.git for the latest package After ABREngine is installed, close and reopen your Unity project. Click \"Ignore\" when it prompts you about compile errors in the project. Now, there should be a new \"ABR\" menu tab that has appeared on the top bar (next to \"Window\"). Click ABR > Import ABR Dependencies. This will install all of ABR's dependencies automatically. Installing all the dependencies will take some time. If you get a permission denied error, try clicking \"Import ABR Dependencies\" again. Once you've set up the ABREngine package, there are a couple more steps to make sure your editor is set up correctly. We recommend using either Visual Studio Code or Visual Studio to develop, since they are both well-supported by Unity. Tip Ensure that your external script editor is set up correctly, and that under \"Generate .csproj files for:\", \"Embedded Packages\", \"Local Packages\", and \"Local Tarball\" are all checked. Additionally, make sure you have the latest .NET SDK installed. Avoid using dotnet versions installed from places besides this official installer, e.g., homebrew on MacOS. Editing with Visual Studio Code In Package Manager, uninstall the \"Visual Studio Code Editor\" package (it is outdated, and now uses the same package as Visual Studio) Install or update the \"Visual Studio Editor\" package to the latest version (you will likely need to periodically keep this up to date). In Unity preferences / External Tools, set the editor to \"Visual Studio Code\", and make sure Generate .csproj files is checked for at least \"Embedded\" and \"Local\" packages. In the Project tab, right-click anywhere in the open space and click \"Open C# Project\". If all is configured correctly, VS Code should now open. Editing with Visual Studio In Package Manager, uninstall the \"Visual Studio Code Editor\" package Install or update the \"Visual Studio Editor\" package to the latest version (you will likely need to periodically keep this up to date). In Unity preferences / External Tools, set the editor to \"Visual Studio\", and make sure Generate .csproj files is checked for at least \"Embedded\" and \"Local\" packages. In the Project tab, right-click anywhere in the open space and click \"Open C# Project\". If all is configured correctly, Visual Studio should now open. Next steps: Get started creating a visualization We recommend that you read the Introduction and Overview before going any further, and also checking out the Core Concepts! After you've read the introduction, to get started creating a visualization: Follow the instructions below to start the ABR server. Import the ABR Vis App example by opening the package manager and navigating to the ABR package, twirling down \"Samples\", and clicking \"Import\" for the \"ABR Vis App\" sample. Follow the ABR Vis App tutorial. If you're looking to make additions or changes to the ABREngine package itself, head to Development Mode for more information. ABR Server This folder contains the code for the ABR server and the ABR Compose Design Interface. This is how you create visualizations quickly and visually in ABR! Installation Before you begin, this tutorial assumes that you have a modern version of Python (>= 3.10) installed; the commands shown here are NOT guaranteed to work with other versions of Python. In this tutorial, we set up the Python configuration for the ABR Server app, which enables you to create visualizations with the ABR Compose design interface. Effectively, we are setting up a \"local\" copy of each package the ABR Server depends on to reduce the chance of conflicts. If you're interested in learning more, check out the pipenv project for more information. If you're on Windows, replace python3 with py. Tip Run all these commands from a terminal in the ABRServer~ folder ( /Packages/ABREngine-UnityPackage/ABRServer~). If you have the read-only Unity package (i.e., you just installed ABR from the Unity Package Manager), use the menu option ABR > Open ABRServer~ folder to open the ABRServer folder. After you've opened the folder, follow the instructions for your operating system to open a terminal. Windows MacOS Linux Windows Terminal instructions Git Bash instructions Command Prompt (cmd) instructions From Finder, the easiest way to open a terminal on a Mac is: Enable Path Bar (View > Show Path Bar) Once you've opened Finder to the ABRServer~ folder, right/two-finger click on the rightmost folder in the newly enabled Path Bar Click \"Open in Terminal\" In most Linux distributions, you can click the \"Open Folder in Terminal...\" in the right-click context menu. To get started, first make sure you have the pipenv package installed in Python. We are using python3 -m pip instead of pip directly to ensure we have the correct pip/Python version pairing. python3 -m pip install --user pipenv Then, install the local dependencies: python3 -m pipenv install Note The first time you run this command, you may need to provide Python path. You can usually get the Python path with a command like which python3 or where python3. Again, on Windows, replace python3 with py. For example: Windows MacOS Linux py -m pipenv --python=/c/Python311/python.exe install python3 -m pipenv --python=/opt/homebrew/bin/python3 install python3 -m pipenv --python=/usr/bin/python3 install Then, to get ready to run the server, \"activate\" the Pipenv by entering a shell: python3 -m pipenv shell Note If you reboot or close the terminal, you will need to re-run the above command. Running the server The server can be run local-only (on localhost:8000 by default): python3 manage.py runserver The server can also be broadcast to other devices (i.e., if you want to run the server on a desktop and use the design interface with a tablet): python manage.py runserver 0.0.0.0:8000 After this command is running, test it but opening http://localhost:8000 in a web browser! You should see the ABR design interface appear: Development with the server This step is optional, and only recommended if you are editing the Python or JavaScript files for the Server or Design Interface. To enable live-reloading (automatically refresh browser when a file is changed), run these commands in separate terminals (the settings_dev enables live-reloading to work): python manage.py livereload python manage.py runserver --settings=abr_server.settings_dev Development Mode Collectively, the lab now recommends a development process where you start by adding the package to your project in read-only mode, as described above. This way, your Unity project files will always maintain a link to download the latest version of the package from git whenever the project is loaded, and all users of the package will be including it the same way. If/when you have a need to edit the package, the process is then to \"temporarily\" switch into development mode by cloning a temporary copy of the package. Then, edit this source as needed, test your edits for as long as you like, etc. When you get to a good stopping point, commit and push the changes to github from within this temporary clone inside the Packages directory. Once the latest version of your package is on github, you can then \"switch out of development mode\" by deleting the cloned repo. This will cause Unity to revert to using the read-only version of the package, which it keeps in its internal package cache, and we can trigger Unity to update this version to the latest by removing the packages-lock.json file. In summary: Follow the read-only mode steps above. Navigate your terminal or Git tool into your Unity project's main folder and clone this repository into the packages folder, e.g., cd Packages; git clone git@github.com:ivlab/ABREngine-UnityPackage.git edu.umn.cs.ivlab.abrengine. This will create a folder that contains all the sourcecode in the package. Go for it. Edit the source you just checked out; add files, etc. However, BE VERY CAREFUL NOT TO ADD THE ABREngine-UnityPackage FOLDER TO YOUR PROJECT'S GIT REPO. We are essentially cloning one git repo inside another here, but we do not want to add the package repo as a submodule or subdirectory of the project's repo, we just want to temporarily work with the source. When you are ready to commit and push changes to the package repo, go for it. JUST MAKE SURE YOU DO THIS FROM WITHIN THE Packages/edu.umn.cs.ivlab.abrengine DIRECTORY! Once these changes are up on github, you can switch out of \"development mode\" by simply deleting the ABREngine-UnityPackage directory. The presence of that directory is like a temporary override. Once it is gone, Unity will revert back to using the cached version of ABREngine that it originally downloaded from git. The final step is to force a refresh of the package cache so that Unity will pull in the new version of the package you just saved to github. In Unity 2021+, you can open the Package Manager, select the ABREngine Package, and click \"Update\". In earlier versions of Unity, you must manually delete the packages-lock.json file inside your project's Packages folder to update the package."
  },
  "manual/intro.html": {
    "href": "manual/intro.html",
    "title": "Introduction and Overview | ABREngine",
    "keywords": "Artifact-Based Rendering Engine The purpose of the Artifact-Based Rendering Engine (ABR Engine) is to provide artists with tools and techniques to create high-fidelity visualizations of multivariate spatiotemporal data using their own traditional-media creations, such as: Colormaps inspired by nature Sketched / inked lines Textures gathered from the real world Hand-sculpted clay glyphs With ABR as a tool in their studio, artists have created images like the following: Gulf of Mexico biogeochemistry visualization created by artist Stephanie Zeller Ocean currents underneath the Filchner-Ronne Ice Shelf in the antarctic by artist Francesca Samsel The ABR Engine was created and is maintained by the Sculpting Visualizations Collective. Getting Started with ABR ABR can be used as both a programming-free visualization design tool (i.e., ABR Compose mode), and as a standalone visualization package in Unity (i.e., C# mode). Before getting into specifics of either of these modes, it is important to understand a few concepts about ABR. Give each of these core concepts a read through before diving into creating with ABR: Key Data VisAssets Data Impressions Basic Terminology Media Folder Next steps Follow along with the ABR Vis App tutorial to set up ABR to create your first visualization. This tutorial introduces ABR Compose mode. Follow along with the ABR C# Introduction tutorial to set up ABR with C#. This tutorial introduces scripting with ABR, which enables you to develop deeply customized and interactive applications with ABR."
  },
  "manual/license.html": {
    "href": "manual/license.html",
    "title": "| ABREngine",
    "keywords": "GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands show w' and show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/. The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read https://www.gnu.org/licenses/why-not-lgpl.html."
  },
  "manual/troubleshooting.html": {
    "href": "manual/troubleshooting.html",
    "title": "Troubleshooting | ABREngine",
    "keywords": "Troubleshooting ABR The ABREngine and its surrounding components are research code, so you may run into problems as you are building visualizations. We've collected a sample of the most common problems encountered here, and if you encounter one that's not listed and are able to solve it, please click the \"Improve this Doc\" button on the right to contribute to this document!"
  },
  "manual/tutorials/abr-cs.html": {
    "href": "manual/tutorials/abr-cs.html",
    "title": "ABR C# Introduction | ABREngine",
    "keywords": "Creating your first C# ABR Visualization Before you begin, make sure you have Unity open and have followed the ABR install instructions. During this tutorial, we'll make a visualization of some 3D surface data like this: Part 0: Getting used to C# Syntax and the ABREngine Even if you've done lots of C# Scripting previously, this part is still worth reading because it's important to be aware of a few design patterns the ABREngine uses. Tip 1: Use of .Instance Like other object-oriented programming languages, C# uses classes, and you access the member variables and functions of those classes with a . So, in the line above, ABREngine is a class (one of the most important in ABR), and .Instance refers to a member variable inside the ABREngine class. Whenever you see a member variable named Instance, it's a good bet that this code is using a Singleton Design Pattern. In short, this means it is a class that is used sort of like a global variable, where the code enforces that only one instance of this class can ever exist within the program. In Unity programming, you will see this used a lot for classes that are \"in charge\" of coordinating or sharing important resources across the whole program, so often these will be named \"Engine\" or \"Manager\" or something similar. It's a good practice to make such classes \"singletons\" when your code assumes you will never have more than one \"engine\" or \"manager\". The convention is that you can refer to this single instance of the engine or manager class from anywhere in your program by simply writing Classname.Instance -- in this case, ABREngine.Instance. Tip 2: C# Properties Since ABREngine.Instance refers to the single instance of the ABREngine class that exists in our program, anything that comes after this must be a member variable, property, or function of the ABREngine class. If you go to the ABREngine documentation and scroll down a bit, you'll find VisAssets listed under the \"Properties\" section. In C#, Properties are used like getter/setting methods in many other languages - they just provide access to get and/or set data stored internally in the class. Tip 3: Generics with <> Notation Many ABREngine methods have a generic type parameter in angle brackets, for example ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(new Guid(\"5a761a72-8bcb-11ea-9265-005056bae6d8\")) has a type parameter ColormapVisAsset. The method declaration for the generic method @IVLab.ABREngine.ABREngine.LoadVisAsset might look something like: public class ABREngine { public T LoadVisAsset<T>(Guid visAssetID) { ... } } Here, the compiler knows that wherever it sees a T inside this function it should replace it with whatever class name you give it when you call the function. So, when we write LoadVisAsset<ColormapVisAsset>(...) it's like calling a ColormapVisAsset-specific version of the LoadVisAsset function. It is good to have this syntax in mind when programming with Unity because some of the most frequently used function in Unity, like @UnityEngine.GameObject.GetComponent use the same approach. Part 1: Setup Part 1.1: Unity Setup First, import the ABR C# sample. You can do this by opening the package manager and navigating to the ABR package, twirling down \"Samples\", and clicking \"Import\" for the \"ABR CSharp Starter\" sample. Once the sample has loaded, open the \"Main\" scene in the \"Scenes\" folder. You should see a scene like the following: Further, we need some data to visualize! In Unity, click ABR > Copy Example Data to Media Folder. This will make some example data available to the ABR design interface and the ABR Engine! (if you have already done this in the ABR Vis App tutorial, you don't need to do it again.) Part 1.2: Scripting Setup You will need a code editing environment to complete this tutorial. Please refer to the Installation Guide instructions for information on how to set up C# scripting in Unity with your preferred code editor. Part 2: Creating a C# Script to drive your visualization Some ABR visualizations use the ABR design interface, but in this tutorial we will solely focus on making a visualization with C# code. We will have a single script, \"VisDriver.cs\", that creates our visualization by creating ABR key data, VisAssets and telling ABR to render these with data impressions. In the starter template, we've already added the ABREngine GameObject, but if you wanted to create one yourself, you can click GameObject > ABR > ABREngine. Keep in mind there should only be one ABREngine GameObject in any scene. In the starter template, we've already created the VisDriver.cs script, but if you wanted to create another one, you can click Assets > Create > C# Script. To edit the script, right/two-finger click the \"VisDriver\" script in the Project tab (in the Scripts folder) and click \"Open C# Project\". Part 3: Making a visualization Note If you have not already done so, please take a glance at the Basic ABREngine Terminology page to familiarize yourself with the technical terms that are used below. After clicking \"Open C# Project\" and navigating to VisDriver.cs in your code editor, you should see that Unity has populated a new MonoBehaviour Class named VisDriver. This part will walk you through the steps to create your first script-based visualization with ABR, which will end up looking like this: In general, the process for creating an ABR visualization follows this process: Import data using LoadData(string) Import VisAssets using VisAssetManager.GetVisAsset Create a DataImpression to combine the data and visuals together (using DataImpression.Create). Use ABREngine.RegisterDataImpression to add the impression to the engine. Render the data and visuals to the screen using Render() Importing the ABREngine Before we add any ABR code, we need to add the following code to the header of the VisDriver.cs file under using UnityEngine: using IVLab.ABREngine; This line of code makes the power of ABR available to you in this script. 1. Import some data For simplicity, we're going to put all our visualization code in the Start() method, so you can delete the Update() method at this point. Now, in the Start() method, we'll begin by importing some example data that's available for you to use in ABR. Copy and past the following code into your Start() method: // 1. Load the dataset from disk (see ABREngine-UnityPackage/Runtime/Resources/media/datasets) for the raw data files // (this is the data that was loaded when you clicked *ABR > Copy Example Data to Media Folder* earlier!) string contourDataPath = \"Demo/Wavelet/KeyData/RTData230\"; KeyData contour = ABREngine.Instance.Data.LoadData(contourDataPath); 2. Putting it together in a data impression Data impressions are the \"layers\" of the visualization. So, to combine data and VisAssets, we need to create a data impression and assign data to it: // 2. Create surface data impression and assign key data SimpleSurfaceDataImpression surf = DataImpression.Create<SimpleSurfaceDataImpression>(\"Contour Impression\"); surf.keyData = contour; 3. Registering and rendering Finally, to get our data to show up at all, we need to first Register the data impression we created with the ABREngine. This only needs to be done once right after the Data Impression is created. // 3.a. Register the data impression so ABR knows about it ABREngine.Instance.RegisterDataImpression(surf); Then Render() the visualization. This needs to be done every time something changes, such as a colormap or data value. // 3.b. Render the visualization ABREngine.Instance.Render(); At this point, check your work. Go back to Unity and press the \"Play\" button triangle in the top toolbar. If everything is working correctly, you should see a gray/white blob-like visualization in the center of your game view - this is the \"RTData230\" surface data you imported in Step 1! 4. Import a colormap VisAsset To add some color to the visualization, we'll need a colormap. Add the following code to your Start() method. Copy/paste this code right after the existing Step 1 code: // 1.b. Import a Colormap VisAsset ColormapVisAsset cmap = ABREngine.Instance.VisAssets.LoadVisAsset<ColormapVisAsset>(new System.Guid(\"5a761a72-8bcb-11ea-9265-005056bae6d8\")); 5. Assign colormap and color variable to data impression The data and the colormap visasset are linked together in the surf data impression created in Step 2. Let's add some more code between steps 2 and 3: // 2.b. Assign colormap to data impression surf.colormap = cmap; // 2.c. Assign color variable to data impression surf.colorVariable = contour.GetScalarVariable(\"XAxis\"); This code will first link the colormap you imported in Step 4 to the data impression, then it will look in the \"Contour\" key data object and find a scalar variable \"XAxis\". See Key Data for more information on key data. At this point, go back to Unity and try running the visualization again. Your game view should now look like this: Note You can see a completed version of the tutorial in the VisDriverTutorial.cs file in the same folder as the original VisDriver.cs file. Tip You can use this script and example as a starting point anytime you make a C# visualization in ABR! Next Steps Now that you're familiar with the basics of creating a C# Visualization with ABR, check out the following resources for working with ABR in Unity: ABR Configuration Advanced Editor Usage placing data impression groups in your scene (handling data and world space) simultaneously using ABR COmpose and C# scripting Creating and loading datasets Interactivity Styling"
  },
  "manual/tutorials/abr-vis-app.html": {
    "href": "manual/tutorials/abr-vis-app.html",
    "title": "ABR Vis App | ABREngine",
    "keywords": "ABR Vis App This example is a pre-built app that you can use to design visualizations with the ABR Compose design interface. Follow along with this tutorial to get started building your first visualization. Part 1: Setup Before you begin, make sure you have installed ABR and all its dependencies. First, import the ABR Vis App sample. You can do this by opening the package manager and navigating to the ABR package, twirling down \"Samples\", and clicking \"Import\" for the \"ABR Vis App\" sample. When Unity asks about importing the TextMeshPro (TMP) essentials, click Import TMP Essential. Once the sample has loaded, open the \"Main\" scene in the \"Scenes\" folder of \"ABR Vis App\". You should see a scene like the following: Tip In the ABREngine GameObject, make sure the ABRConfig_VisApp configuration is selected! Lastly, we need some data to visualize! In Unity, click ABR > Copy Example Data to Media Folder. This will make some example data available to the ABR design interface and the ABR Engine! Part 2: Running the server To design visualizations with the ABR design interface, you'll need to start the ABR server. Instructions for this can be found in the ABR Server README. Essentially, the ABR Compose design interface lives within the ABR Server, so you need to run that Python server first in order to design visualizations with ABR. Once the server is installed, the only command you should need to run is: python3 manage.py runserver Tip Recall that this command is run in a terminal inside the ABRServer~ folder, which can be opened from Unity by clicking ABR > Open ABRServer~ Folder. You may also need to re-activate the pipenv if you've closed the terminal; do so by running python3 -m pipenv shell in the ABRServer~ folder. After you've started the server, visit http://localhost:8000 in a web browser. You should now see the ABR design interface: Next steps At this point, you're ready to get started designing a visualization! Your next step is to follow along with the Creating your first ABR Visualization with the ABR Design Interface tutorial. If you're interested in using your own data with ABR, check out Importing Data. If you'd like to design visualizations using C# scripting, check out ABR C# Introduction."
  },
  "manual/tutorials/advanced-usage.html": {
    "href": "manual/tutorials/advanced-usage.html",
    "title": "Advanced ABR Usage | ABREngine",
    "keywords": "Advanced usage of ABR and C# This page shows many advanced usages of ABR and for integrating it into your existing Unity projects. Creating a dataset from scratch: Introduces the basics of how datasets work in ABR by creating a cube. Interactive State Modification: Loads a state from JSON then modifies it interactively. Interactive Filtering and Querying: Works through several key concepts, including data space vs. world space, filtering data, copying and linking styles between data impressions. Culminating Example: Interactive Visualization of Mount St. Helens. Demonstrates features like VisAsset Gradients, Data Containers, Data Impression Groups, Per-Index Visibility, and Interactivity. Creating a Dataset From Scratch Interactive State Modification Interactive Filtering and Querying Real Data Example"
  },
  "manual/tutorials/creating-design-interface-vis.html": {
    "href": "manual/tutorials/creating-design-interface-vis.html",
    "title": "Creating your first ABR Visualization with the ABR Design Interface | ABREngine",
    "keywords": "Creating your first ABR Visualization with the ABR Design Interface Often, the most effective way to create a visualization is visually! So, we've provided a way to create visualizations using a drag-and-drop approach: The ABR Design Interface (ABR Compose). If you haven't already, please follow all the instructions in Installation Guide to install the ABREngine Unity Package, design interface and visualization manager before continuing. Note This tutorial assumes that you have completed the setup steps shown in the ABR Vis App tutorial. Part 1: Checking the ABREngine GameObject and configuration Verify that the ABREngine GameObject is in your scene, and that the \"ABRConfig_VisApp\" is selected as the ABR Configuration: Part 2: Verifying the design interface connection Ensure the ABR Server is running as described in the ABR Vis App tutorial. In a browser, go to http://localhost:8000 to open the Design Interface. In Unity, press the Play button. You should see the following output or similar: Part 3: Next Steps Import some VisAssets (see videos below) Creating a visualization (see videos below) Optionally, follow the Importing Data tutorial to load additional data besides the example dataset. Optionally, follow the ABR C# Introduction tutorial to learn how to create a visualization in ABR using C# code in Unity. Note These videos were created with an older version of ABR so the interface looks slightly different. However, the processes remain much the same!"
  },
  "manual/tutorials/importing-data.html": {
    "href": "manual/tutorials/importing-data.html",
    "title": "Importing Data | ABREngine",
    "keywords": "Importing Data ABR data files consist of two parts - a .bin file and a .json file. Every piece of Key Data will have both these files, and they will be organized in folders according to their data path. For example, for the Gulf of Mexico dataset, we might have the following folder structure: media/ datasets/ E3SM/ --> \"Organization\" GulfOfMexico/ --> \"Dataset\" KeyData/ --> \"KeyData - required\" Bathymetry.bin --> binary file where data are stored Bathymetry.json --> header file describing the binary ChlorophyllPoints.bin ChlorophyllPoints.json Terrain.bin Terrain.json There are two main options for importing data to ABR: Downloading an existing dataset from the IVLab's ABR Data Archive Import Data from ParaView Option 1: Download data from ABR Data Archive We've curated a set of publicly available data for you to check out on the ABR Data Archive. To download these into your project, you first need to find where your The Media Folder is. If you're using the ABR Design Interface, you'll need to look in the ABRComponents folder. Otherwise, check out your Persistent Data Path, or whatever other media folder you may have created and set in ABRConfig. Once you've located this folder, download the dataset you want from the archive and unzip it into the datasets folder within the media folder. Be mindful that the directory structure should look exactly like described at the top of this page. Option 2: Import data from ParaView ParaView is a popular, open-source data analysis and visualization toolkit developed by KitWare. Step 1: Download and install the required components Download ParaView. We've tested the ABR-to-ParaView connector with ParaView version 5.9. Follow the EasyParaViewToABR directions below: Easy ParaView to ABR data converter This ParaView plugin enables direct conversion between ParaView data and ABR data. NOTE: this plugin assumes you're using at least ParaView 5.8. Installation Copy the <./EasyParaViewToABR> folder to your user folder. For example, on Windows: C:/Users/bridger/EasyParaViewToABR For example, on Mac: /Users/bridger/EasyParaViewToABR For example, on Linux: /home/bridger/EasyParaViewToABR Open ParaView. Go to Tools > Manage Plugins Click Load New... Select the EasyParaViewToABR.py file in the folder you just downloaded (Optional) Twirl down the newly created EasyParaViewToABR menu item and check the \"AutoLoad\" box Usage Part 1: Setting up ABR Config Open your Unity Project that uses ABR Click on the ABREngine GameObject in your scene and Open the Current ABR Config Under the \"Network-Based VisAssets and Data Configuration\" section, change the \"Data Listener Port\" to 1900 (should match ParaView plugin below) Part 2: Transferring Data from ParaView to ABR Make sure ABR is running!! In the ParaView pipeline browser, select the data you would like to transfer to ABR. Make sure your data are in the correct format. Look at the \"Information\" tab in ParaView to see the data's \"Type\". ABR will accept any of the following - if it's not in one of these formats you may need to convert (see Converting data to ABR-acceptable format) Polygonal mesh Unstructured grid Uniform rectiliear grid Once your data are in the right format, add a new EasyParaViewToABR filter by going to Filters > Alphabetical, or typing Ctrl + Space and seraching \"EasyParaViewToABR\" Input the required information in the Properties window (see Example below). Dataset: higher-level dataset this Key Data is a part of Key Data Name: descriptive name for the key data you are sending to ABR Organization: descriptive name for the organization that owns the data Host: (optional) IP address of the machine ABR is running on Port: (optional) Port that the ABR data listener is running on Click the green 'Apply' button to send your data to ABR! You may need to stop the Unity project and start it again for the data to show up. Converting data to ABR-acceptable format If you have VOLUME data, make sure it's a Uniform Rectilinear Grid by adding a 'Resample to Image' filter. If you have SURFACE data, make sure it's either a Polygonal Mesh or an Unstructured Grid by adding an 'Extract Surface' or 'Append Datasets' filter, respectively. Additionally, make sure that your surface is made up of triangles by performing a 'Triangulate' filter. If you have LINE data, make sure it's an Unstructured Grid by using the 'Append Datasets' filter. If you have POINTS data, make sure it's an Unstructured Grid by using the 'Append Datasets' filter."
  },
  "manual/tutorials/tutorials.html": {
    "href": "manual/tutorials/tutorials.html",
    "title": "ABR Tutorials and Example Code | ABREngine",
    "keywords": "ABR Tutorials and Example Code We recommend looking through the tutorials and examples in the following order: ABR Vis App Creating your first ABR Visualization with the ABR Design Interface Importing Data ABR C# Introduction Advanced ABR Usage"
  }
}